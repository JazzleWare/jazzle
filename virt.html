<html><head><script src="./dist/jazzle.js"></script></head><body><script>
var build = function(options) {

var resolver = new jazzle.VirtualResourceResolver();
resolver.set('./src/Liquid/core.js', '  import {HAS, ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\n// TODO: liquids leave no signs in any scope the don\'t belong to --\n//       they record it in their list of referencing scopes if they\n//       contain any significant names, but they are not recorded in the lsi\n//       of the scope\'s unresolved references; nothing looks actually wrong with this approach,\n//       except that it is in total contrast to the one taken in the previous version\ncls.track =\nfunction(scope) {\n  if (this.rsMap === null)\n    this.rsMap = {};\n\n  var cur = scope, root = this.ref.scope ;\n  this.ref.d++;\n  while (true) {\n    if (cur.hasSignificantNames() || cur.isAnyFn() || cur.isCatch()) {\n      if (HAS.call(this.rsMap, cur.scopeID))\n        break;\n      this.rsMap[cur.scopeID] = true;\n      this.ref.rsList.push(cur);\n    }\n    if (cur === root)\n      break;\n    cur = cur.parent;\n    ASSERT.call(this, cur,\n      \'reached topmost while pulling up a liquid\');\n  }\n  return this;\n};\n\n\n');
resolver.set('./src/Liquid/whole.js', '  import \'./core.js\';\n');
resolver.set('./src/Liquid/cls.js', '  import Decl from \'../Decl/cls.js\';\n  import {DT_LIQUID} from \'../other/scope-constants.js\';\n\nexport default function Liquid(category) {\n  Decl.call(this);\n  this.type |= DT_LIQUID;\n  this.category = category;\n}\n\n import {createObj} from \'../other/util.js\';\n export var cls = Liquid.prototype = createObj(Decl.prototype);\n');
resolver.set('./src/Actix/new-core.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.ii =\nfunction(inactiveIf) {\n  ASSERT.call(this, this.inactiveIf === null, \'inactiveIf\' );\n  this.inactiveIf = inactiveIf;\n  return this;\n\n};\n\n\n');
resolver.set('./src/Actix/whole.js', '  import \'./new-core.js\';\n');
resolver.set('./src/Actix/cls.js', 'import {ASSERT, activeID_new, ANESS_UNKNOWN} from \'../other/constants.js\';\n\nexport default function Actix(role) { // activity ctx\n  ASSERT.call(this, arguments.length === 1, \'len\' );\n  this.ai = activeID_new();\n  this.activeIf = null;\n  this.activeness = ANESS_UNKNOWN;\n  this.ns = 0;\n  this.role = role;\n  this.inactiveIf = null;\n}\n\nexport var cls = Actix.prototype;\n');
resolver.set('./src/FileResourceResolver/cls.js', 'import Parser from \'../Parser/cls.js\';\nimport {ASSERT} from \'../other/constants.js\';\nimport {createObj} from \'../other/util.js\';\nimport PathMan from \'../PathMan/cls.js\';\nimport ResourceResolver from \'../ResourceResolver/cls.js\';\n\nexport default function FileResourceResolver(fs) {\n  ResourceResolver.call(this);\n  this.fs = fs;\n}\n\nvar RRcls = ResourceResolver.prototype;\nvar cls = FileResourceResolver.prototype = createObj(RRcls);\n\nexport function normalize(str) {\n  var list = [], start = 0, len = 0, manp = new PathMan();\n  while (true) {\n    len = manp.len(str, start);\n    if (len === 0) \n      break;\n    var elem = manp.trimSlash(str.substr(start, len));\n    if (elem === \'..\') list.pop();\n    else { list.push(elem); }\n    start += len;\n  }\n  return list.join(\'/\');\n};\n\ncls.asNode =\nfunction(uri) {\n  uri = normalize(uri);\n  var src = this.fs.readFileSync(uri, \'utf-8\').toString();\n  var newParser = new Parser(src, {sourceType: \'module\'});\n  newParser.bundleScope = this.bundleScope;\n  var n = newParser.parseProgram();\n  n[\'#scope\'][\'#uri\'] = uri;\n  n[\'#scope\'][\'#loader\'] = \"\";\n  return n;\n}\n\ncls.hasInCache =\nfunction(uri) {\n  uri = normalize(uri);\n  return RRcls.hasInCache.call(this, uri);\n};\n\ncls.loadCached =\nfunction(uri) {\n  uri = normalize(uri);\n  return RRcls.loadCached.call(this, uri);\n};\n\ncls.cache =\nfunction(uri, n) {\n  uri = normalize(uri);\n  return RRcls.cache.call(this, uri, n);\n};\n\ncls.loadNew =\nfunction(uri) {\n  uri = normalize(uri);\n  return RRcls.loadNew.call(this, uri);\n};\n');
resolver.set('./src/SortedObj/core.js', '  import {HAS, ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.set = function(name, val) {\n  if (!HAS.call(this.obj, name))\n    this.keys.push(name);\n  return this.obj[name] = val;\n};\n\ncls.at = function(i) {\n  return i < this.keys.length ? this.obj[this.keys[i]] : void 0;\n};\n\ncls.get = function(name) {\n  return this.obj[name]; \n};\n\ncls.remove = function(name) {\n  if (!HAS.call(this.obj, name))\n    return false;\n  delete this.obj[name];\n\n  var list = this.keys;\n  var i = list.length - 1; // slighty optimize for pops\n\n  while (name !== list[i])\n    i--;\n\n  while (i < list.length-1) {\n    list[i] = list[i+1];\n    i++;\n  }\n\n  list.pop();\n  return true;\n};\n\ncls.has = function(name) {\n  return HAS.call(this.obj, name);\n};\n\ncls.length = function() {\n  return this.keys.length;\n};\n\ncls.pop = function(out) {\n  var list = this.keys;\n  ASSERT.call(this, list.length, \'len\' );\n  var name = list.pop();\n  var elem = this.obj[name]; delete this.obj[name];\n  if (out) { out.name = name; out.value = elem; }\n  else out = elem;\n  return out;\n};\n\n\n');
resolver.set('./src/SortedObj/whole.js', '  import \'./core.js\';\n');
resolver.set('./src/SortedObj/cls.js', '  import {createObj} from \'../other/util.js\';\n\nexport default function SortedObj(obj) {\n  this.keys = [];\n  this.obj = obj || {};\n}\n\n export var cls = SortedObj.prototype;\n');
resolver.set('./src/FunScope/core.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.setRefsAndArgRefs =\nfunction(refs) {\n  ASSERT.call(this, !this.inBody, \'sraar must be in args\');\n  var len = refs.length(), e = 0;\n  while (e < len) refs.at(e++).scope = this;\n  this.argRefs = refs;\n  this.refs = this.argRefs;\n};\n\ncls.getNonLocalLoopLexicals =\nfunction() {\n  var argRefs = this.argRefs, e = 0, len = argRefs.length(), target = null;\n  var list = null;\n  while (e < len) {\n    var ref = argRefs.at(e++);\n    if (ref === null)\n      continue;\n\n    target = ref.getDecl_nearest();\n    if (target === this.scopeName)\n      continue;\n    if (target === this.spArguments)\n      continue;\n    if (target === this.spThis)\n      continue;\n    if (target.isLiquid()) {\n      switch (target.category) {\n      case \'<this>\':\n      case \'<arguments>\':\n      case \'scall\': continue;\n      }\n    }\n\n    ASSERT.call(this, !target.isLiquid(), \'got liquid\');\n    ASSERT.call(this, !this.owns(target), \'local\');\n\n    if (target.isLexicalLike() && target.ref.scope.insideLoop()) {\n      var mname = _m(target.name);\n      var ll = this.getClosureLLINOSA_m(mname);\n      if (ll) ASSERT.call(this, ll === target, \'ll\');\n      else {\n        (list || (list = [])).push(target);\n        this.insertClosureLLINOSA_m(mname, target);\n      }\n    }\n  }\n\n  return list;\n};\n\n\n');
resolver.set('./src/FunScope/new-core.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\n// the only names that are checked via hasClosureLLINOSA_m are the ones already known to be external refs\n// this is because the routine below is only called during getLoopLexicals. while there, the LLINOSA names\n// are then queried against the scope\'s closureLLINOSA. if not found, they will be added to the ll array, and will be recorded in the scope\'s closureLLINOSA\n// else it means the parent fn has them in its closure, and they need not get into yet another closure:\n//\n// var a = []; while (a.length < 12) { let len = a.length; a.push(function() { return len-- * (function() { return len })() }) }\n//\n// withOUT:\n// var a = [];\n// while (a.length < 12) {\n//   var len = {v: void 0};\n//   len.v = a.length;\n//   a.push(function(len) {\n//     return function() {\n//       return len.v-- * function(len) { return function() { return len.v } }(len)();\n//     };\n//   }(len));\n// }\n//\n// WITH:\n// var a = [];\n// while (a.length < 12) {\n//   var len = {v: void 0};\n//   len.v = a.length;\n//   a.push(function(len) {\n//     return function() {\n//       return len.v-- * function() { return len.v };\n//     };\n//   }(len));\n// }\n\ncls.getClosureLLINOSA_m =\nfunction(mname) {\n  return this.closureLLINOSA[mname]; \n};\n\n// CLs are only inserted when an fn\'s outer-loop-lexicals are getting calculated;\ncls.insertClosureLLINOSA_m =\nfunction(mname, llinosa) {\n  ASSERT.call(this, !this.getClosureLLINOSA_m(mname), \'closure-l\');\n  this.closureLLINOSA[mname] = llinosa;\n};\n\n\n');
resolver.set('./src/FunScope/whole.js', '  import \'./core.js\';\n  import \'./new-core.js\';\n  import \'./hand-over.js\';\n  import \'./sp.js\';\n  import \'./synth-names.js\';\n  import \'./strict.js\';\n  import \'./can.js\';\n  import \'./args-unique.js\';\n');
resolver.set('./src/FunScope/hand-over.js', '  import {ref_arguments_m, ref_this_m, ref_scall_m} from \'../other/ref-cat.js\';\n  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.handOver_m =\nfunction(mname, ref) {\n  if (!this.isArrow()) {\n    if (ref_arguments_m(mname))\n      return this.spCreate_arguments(ref);\n\n    if (this.isExpr() &&\n      this.scopeName &&\n      this.scopeName.hasName_m(mname))\n      return this.scopeName.ref.absorbDirect(ref);\n  }\n\n  return this.parent.refIndirect_m(mname, ref);\n};\n\ncls.refInHead =\nfunction(mname, ref) {\n  if (!this.isArrow()) {\n    if (ref_this_m(mname))\n      return this.spCreate_this(ref);\n    if (ref_scall_m(mname)) {\n      ASSERT.call(this, this.isCtor(),\n        \'a scall ref must only come in a ctor scope\');\n      return this.spCreate_scall(ref);\n    }\n  }\n\n  return this.focRefAny_m(mname).absorbDirect(ref);\n};\n\n\n');
resolver.set('./src/FunScope/sp.js', '  import {ASSERT} from \'../other/constants.js\';\n  import Liquid from \'../Liquid/cls.js\';\n  import {cls} from \'./cls.js\';\n\ncls.spCreate_arguments =\nfunction(ref) {\n  ASSERT.call(this, ref,\n    \'ref must be provided to create an argumentsSP\');\n\n  var spArguments = new Liquid(\'<arguments>\')\n    .r(ref)\n    .n(\'arguments\');\n\n  return this.spArguments = spArguments;\n};\n\ncls.spCreate_scall =\nfunction(ref) {\n  ASSERT.call(this, this.isCtor(),\n    \'only ctor scopes are allowed to create scall\');\n  ASSERT.call(this, ref,\n    \'ref must be provided to create a scallSP\');\n\n  var lg = this.gocLG(\'scall\');\n  var spSuperCall = lg.newL();\n  lg.seal();\n\n  spSuperCall.ref = null;\n  spSuperCall.r(ref);\n  spSuperCall.name = \'s\';\n\n  return this.spSuperCall = spSuperCall;\n};\n\n\n');
resolver.set('./src/FunScope/synth-names.js', '  import {ref_arguments_m} from \'../other/ref-cat.js\';\n  import {ASSERT, HAS} from \'../other/constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.synth_ref_may_escape_m =\nfunction(mname) { return !ref_arguments_m(mname); };\n\ncls.synth_name_is_valid_binding_m =\nfunction(mname) { return true; };\n\ncls.synth_ref_find_homonym_m =\nfunction(mname, r) {\n  this.isBooted || this.synth_boot(r);\n  var synth = this.findSynth_m(mname)\n  if (synth === null && this.scopeName && this.scopeName.hasName_m(mname))\n    synth = this.scopeName;\n  return synth;\n};\n\ncls.synth_decl_find_homonym_m =\nfunction(mname, r) {\n  this.isBooted || this.synth_boot(r);\n  return this.findSynth_m(mname);\n};\n\ncls.synth_boot =\nfunction(r) {\n  if (this.renamer === null) this.renamer = r;\n  this.synth_boot_init();\n  ASSERT.call(this, !this.inBody, \'inBody\');\n  this.synth_args();\n  this.activateBody();\n  this.synth_defs_to(this);\n  this.deactivateBody();\n};\n\ncls.synth_start =\nfunction(r) {\n  this.isBooted || this.synth_boot(r);\n  this.synth_externals();\n};\n\n// TODO: save extenals on hand-over to obviate the chore below\ncls.synth_externals =\nfunction() {\n  ASSERT.call(this, !this.inBody, \'inBody\');\n  var list = this.argRefs, e = 0, len = list.length();\n  while (e < len) {\n    var item = list.at(e++);\n    if (item) {\n      var target = item.getDecl_nearest(), mname = \"\";\n      if (target.isLiquid()) {\n        ASSERT.call(this, target.category === \'<this>\' ||\n          target.category === \'<arguments>\' || target.category === \'scall\', \'liq\');\n        continue;\n      }\n\n      //  TODO: synth_boot has to trigger if target.isImported\n      if (target.synthName === \"\") {\n        ASSERT.call(\n          this,\n          target.isGlobal() || target.isImported(), \n          \'unsynthesized name can only be an import binding\'\n        );\n      }\n      else {\n        ASSERT.call(this, target.synthName !== \"\", \'synth\');\n\n        mname = _m(target.synthName);\n        var synth = this.findSynth_m(mname);\n        if (synth !== target) {\n          ASSERT.call(this, synth === null, \'override\');\n          this.insertSynth_m(mname, target);\n        }\n      }\n    }\n  }\n};\n\ncls.synth_args =\nfunction() {\n  var list = this.argList, nmap = {}, e = list.length - 1;\n  while (e >= 0) {\n    var arg = list[e], mname = _m(arg.name);\n    arg = arg.ref.getDecl_nearest(); // must not be a dupl (TODO:should eliminate this)\n    if (!HAS.call(nmap, mname)) {\n      nmap[mname] = arg;\n      this.synthDecl(arg);\n    }\n    e--;\n  }\n};\n\n\n');
resolver.set('./src/FunScope/strict.js', '  import {arorev} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.verifyForStrictness =\nfunction() {\n  this.verifyUniqueArgs();\n  var list = this.argList, i = 0;\n  while (i < list.length) {\n    var elem = list[i++];\n    if (arorev(elem.name))\n      this.parser.err(\'binding.to.arguments.or.eval\');\n    if (this.parser.isResv(elem.name))\n      this.parser.err(\'invalid.argument.in.strict.mode\');\n  }\n};\n\n\n');
resolver.set('./src/FunScope/can.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.canDup =\nfunction() {\n  ASSERT.call(this, !this.inBody,\n    \'canDup allowed in args only\');\n  return !this.insideUniqueArgs() &&\n         !this.insideStrict();\n};\n\n\n');
resolver.set('./src/FunScope/cls.js', '  import ConcreteScope from \'../ConcreteScope/cls.js\';\n  import {ST_FN} from \'../other/scope-constants.js\';\n  import SortedObj from \'../SortedObj/cls.js\';\n\n// TODO: inBody makes the logic brittle\nexport default function FunScope(parent, type) {\n  ConcreteScope.call(this, parent, type|ST_FN);\n\n  this.argList = [];\n  this.argMap = {};\n  this.argRefs = new SortedObj();\n  this.prologue = [];\n  this.scopeName = null;\n  this.firstNonSimple = \n  this.firstDup =\n  this.firstEvalOrArguments = null;\n  this.inBody = false;\n  this.bodyRefs = new SortedObj();\n\n  this.closureLLINOSA = null;\n\n  this.refs = this.argRefs;\n\n  this.spArguments = null;\n  this.spSuperCall = null;\n\n}\n\n import {createObj} from \'../other/util.js\';\n export var cls = FunScope.prototype = createObj(ConcreteScope.prototype);\n');
resolver.set('./src/FunScope/args-unique.js', '  import {SF_UNIQUE} from \'../other/scope-constants.js\';\n  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.insideUniqueArgs =\nfunction() { return this.flags & SF_UNIQUE; };\n\ncls.exitUniqueArgs =\nfunction() {\n  ASSERT.call(this, !this.inBody,\n    \'must be in args\');\n  ASSERT.call(this, this.insideUniqueArgs(),\n    \'must be in unique args\');\n  this.flags &= ~SF_UNIQUE;\n};\n\ncls.enterUniqueArgs =\nfunction() {\n  if (!this.canDup())\n    return;\n\n  this.verifyUniqueArgs();\n  this.flags |= SF_UNIQUE;\n};\n\ncls.verifyUniqueArgs =\nfunction() { this.firstDup && this.parser.err(\'argsdup\'); };\n\n\n');
resolver.set('./src/other/constants.js', '  import {char2int} from \'./util.js\';\n\nvar CH_1 = char2int(\'1\'),\n    CH_2 = char2int(\'2\'),\n    CH_3 = char2int(\'3\'),\n    CH_4 = char2int(\'4\'),\n    CH_5 = char2int(\'5\'),\n    CH_6 = char2int(\'6\'),\n    CH_7 = char2int(\'7\'),\n    CH_8 = char2int(\'8\'),\n    CH_9 = char2int(\'9\'),\n    CH_0 = char2int(\'0\'),\n\n    CH_a = char2int(\'a\'), CH_A = char2int(\'A\'),\n    CH_b = char2int(\'b\'), CH_B = char2int(\'B\'),\n    CH_e = char2int(\'e\'), CH_E = char2int(\'E\'),\n    CH_d = char2int(\'d\'), CH_D = char2int(\'D\'),\n    CH_g = char2int(\'g\'),\n    CH_f = char2int(\'f\'), CH_F = char2int(\'F\'),\n    CH_c = char2int(\'c\'),\n    CH_i = char2int(\'i\'),\n    CH_m = char2int(\'m\'),\n    CH_n = char2int(\'n\'),\n    CH_o = char2int(\'o\'), CH_O = char2int(\'O\'),\n    CH_r = char2int(\'r\'),\n    CH_s = char2int(\'s\'), CH_S = char2int(\'S\'),\n    CH_t = char2int(\'t\'),\n    CH_u = char2int(\'u\'), CH_U = char2int(\'U\'),\n    CH_v = char2int(\'v\'),\n    CH_w = char2int(\'w\'), CH_W = char2int(\'W\'),\n    CH_x = char2int(\'x\'), CH_X = char2int(\'X\'),\n    CH_y = char2int(\'y\'),\n    CH_z = char2int(\'z\'), CH_Z = char2int(\'Z\'),\n\n    CH_UNDERLINE = char2int(\'_\'),\n    CH_$ = char2int(\'$\'),\n\n    CH_VTAB = char2int(\'\\v\'),\n    CH_BACK = char2int(\'\\b\'),\n    CH_FORM_FEED   = char2int( \'\\f\') ,\n    CH_TAB = char2int(\'\\t\'),\n    CH_CARRIAGE_RETURN = char2int(\'\\r\'),\n    CH_LINE_FEED = char2int(\'\\n\'),\n\n    CH_WHITESPACE = char2int(\' \'),\n\n    CH_BACKTICK = char2int(\'`\'),\n    CH_SINGLE_QUOTE = char2int(\'\\\'\'),\n    CH_MULTI_QUOTE = char2int(\'\"\'),\n    CH_BACK_SLASH = char2int((\'\\\\\')),\n\n    CH_DIV = char2int(\'/\'),\n    CH_MUL = char2int(\'*\'),\n    CH_MIN = char2int(\'-\'),\n    CH_ADD = char2int(\'+\'),\n    CH_AND = char2int(\'&\'),\n    CH_XOR = char2int(\'^\'),\n    CH_MODULO = char2int(\'%\'),\n    CH_OR = char2int(\'|\'),\n    CH_EQUALITY_SIGN = char2int(\'=\'),\n\n    CH_SEMI = char2int(\';\'),\n    CH_COMMA = char2int(\',\'),\n    CH_SINGLEDOT = char2int(\'.\'),\n    CH_COLON = char2int((\':\')),\n    CH_QUESTION = char2int(\'?\'),\n\n    CH_EXCLAMATION = char2int(\'!\'),\n    CH_COMPLEMENT = char2int(\'~\'),\n\n    CH_ATSIGN = char2int(\'@\'),\n\n    CH_LPAREN = char2int(\'(\'),\n    CH_RPAREN = char2int(\')\'),\n    CH_LSQBRACKET = char2int(\'[\'),\n    CH_RSQBRACKET = char2int(\']\'),\n    CH_LCURLY = char2int(\'{\'),\n    CH_RCURLY = char2int(\'}\'),\n    CH_LESS_THAN = char2int(\'<\'),\n    CH_GREATER_THAN = char2int(\'>\')\n ;\n\nvar PAREN = \'paren\';\nvar PAREN_NODE = PAREN;\n\nvar INTERMEDIATE_ASYNC = \'intermediate-async\';\n\nvar FUNCTION_TYPE = typeof function() {};\nvar STRING_TYPE = typeof \"string\";\nvar NUMBER_TYPE = typeof 0;\nvar BOOL_TYPE = typeof false;\n\nvar OPTIONS =\n[\n  \'ecmaVersion\',\'sourceType\',\'onToken\',\'program\',\n  \'onComment\',\'allowReturnOutsideFunction\',\'allowImportExportEverywhere\',\n  \'sourceFile\',\'directSourceFile\',\n//\'preserveParens\',\n  \'allowHashBang\' ];\n\nvar HAS = {}.hasOwnProperty;\n\nvar B = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\';\nvar I_31 = allOnes(31);\n\nfunction allOnes(len) { var n = 0, s = 0; while (s < len) n += (1 << s++); return n; }\n\n\nfunction ASSERT(cond, message) { if (!cond) throw new Error(message); }\nfunction ASSERT_EQ(val,ex) { ASSERT.call(this, val === ex, \'val must be <\'+ex+\'>, not <\'+val+\'>\'); }\n\nvar ACTIVE_ID = 0;\nfunction activeID_new() { return ++ACTIVE_ID; }\n\nvar CTX_NONE = 0,\n    CTX_PARAM = 1,\n    CTX_FOR = CTX_PARAM << 1,\n    CTX_PAT = CTX_FOR << 1,\n    CTX_NULLABLE = CTX_PAT << 1,\n    CTX_HASPROTO = CTX_NULLABLE << 1,\n    CTX_HASPROTOTYPE = CTX_HASPROTO << 1,\n    CTX_CTOR_NOT_ALLOWED = CTX_HASPROTOTYPE << 1,\n    CTX_DEFAULT = CTX_CTOR_NOT_ALLOWED << 1,\n    CTX_HAS_A_PARAM_ERR = CTX_DEFAULT << 1,\n    CTX_HAS_AN_ASSIG_ERR = CTX_HAS_A_PARAM_ERR << 1,\n    CTX_HAS_A_SIMPLE_ERR = CTX_HAS_AN_ASSIG_ERR << 1,\n    CTX_NO_SIMPLE_ERR = CTX_HAS_A_SIMPLE_ERR << 1,\n    CTX_ASYNC_NO_NEWLINE_FN = CTX_NO_SIMPLE_ERR << 1,\n    CTX_PARPAT = CTX_PARAM|CTX_PAT,\n    CTX_PARPAT_ERR = CTX_HAS_A_PARAM_ERR|CTX_HAS_AN_ASSIG_ERR|CTX_HAS_A_SIMPLE_ERR,\n    CTX_TOP = CTX_PAT|CTX_NO_SIMPLE_ERR;\n\nvar ARGLEN_GET = 0,\n    ARGLEN_SET = 1,\n    ARGLEN_ANY = -1;\n\nvar EC_NONE = 0,\n    EC_NEW_HEAD = 1,\n    EC_START_STMT = 2,\n    EC_EXPR_HEAD = EC_START_STMT << 1,\n    EC_CALL_HEAD = EC_EXPR_HEAD << 1,\n    EC_NON_SEQ = EC_CALL_HEAD << 1,\n    EC_IN = EC_NON_SEQ << 1,\n    EC_ATTACHED = EC_IN << 1,\n    EC_JZ = EC_ATTACHED << 1;\n\nvar EST_BREAKABLE = 1,\n    EST_OMITTABLE = EST_BREAKABLE << 1,\n    EST_NONE = 0;\n\nvar SP_BREAKABLE = 1, SP_OMITTABLE = SP_BREAKABLE << 1, SP_NONE = 0;\n\nvar ETK_NONE = 0,\n    ETK_ID = 1,\n    ETK_MIN = ETK_ID << 1,\n    ETK_DIV = ETK_MIN << 1,\n    ETK_ADD = ETK_DIV << 1,\n    ETK_NUM = ETK_ADD << 1,\n    ETK_STR = ETK_NUM << 1,\n    ETK_NL = ETK_STR << 1,\n    ETK_COMMENT = ETK_NL << 1;\n\nvar PE_NO_NONVAR = 1,\n    PE_NO_LABEL = PE_NO_NONVAR << 1,\n    PE_LEXICAL = PE_NO_NONVAR,\n    PE_NONE = 0;\n\nvar CHK_T = 1,\n    CHK_V = CHK_T << 1,\n    CHK_NONE = 0;\n\n// `this` state\nvar THS_NEEDS_CHK = 1,\n    THS_IS_REACHED = THS_NEEDS_CHK << 1,\n    THS_NONE = 0;\n\nvar ANESS_UNKNOWN = -2,\n    ANESS_CHECKING = -1,\n    ANESS_INACTIVE = 0,\n    ANESS_ACTIVE = 1;\n\nvar ACT_BARE = 0,\n    ACT_DECL = 1,\n    ACT_SCOPE = 2;\n\nvar CVTZ_T = 1,\n    CVTZ_C = CVTZ_T << 1,\n    CVTZ_NONE = 0;\n\n\n export {CH_1, CH_2, CH_3, CH_4, CH_5, CH_6, CH_7, CH_8, CH_9, CH_0, CH_a, CH_A, CH_b, CH_B, CH_e, CH_E, CH_d, CH_D, CH_g, CH_f, CH_F, CH_c, CH_i, CH_m, CH_n, CH_o, CH_O, CH_r, CH_s, CH_S, CH_t, CH_u, CH_U, CH_v, CH_w, CH_W, CH_x, CH_X, CH_y, CH_z, CH_Z, CH_UNDERLINE, CH_$, CH_VTAB, CH_BACK, CH_FORM_FEED, CH_TAB, CH_CARRIAGE_RETURN, CH_LINE_FEED, CH_WHITESPACE, CH_BACKTICK, CH_SINGLE_QUOTE, CH_MULTI_QUOTE, CH_BACK_SLASH, CH_DIV, CH_MUL, CH_MIN, CH_ADD, CH_AND, CH_XOR, CH_MODULO, CH_OR, CH_EQUALITY_SIGN, CH_SEMI, CH_COMMA, CH_SINGLEDOT, CH_COLON, CH_QUESTION, CH_EXCLAMATION, CH_COMPLEMENT, CH_ATSIGN, CH_LPAREN, CH_RPAREN, CH_LSQBRACKET, CH_RSQBRACKET, CH_LCURLY, CH_RCURLY, CH_LESS_THAN, CH_GREATER_THAN, PAREN, PAREN_NODE, INTERMEDIATE_ASYNC, FUNCTION_TYPE, STRING_TYPE, NUMBER_TYPE, BOOL_TYPE, OPTIONS, HAS, B, I_31, allOnes, ASSERT, ASSERT_EQ, ACTIVE_ID, activeID_new, CTX_NONE, CTX_PARAM, CTX_FOR, CTX_PAT, CTX_NULLABLE, CTX_HASPROTO, CTX_HASPROTOTYPE, CTX_CTOR_NOT_ALLOWED, CTX_DEFAULT, CTX_HAS_A_PARAM_ERR, CTX_HAS_AN_ASSIG_ERR, CTX_HAS_A_SIMPLE_ERR, CTX_NO_SIMPLE_ERR, CTX_ASYNC_NO_NEWLINE_FN, CTX_PARPAT, CTX_PARPAT_ERR, CTX_TOP, ARGLEN_GET, ARGLEN_SET, ARGLEN_ANY, EC_NONE, EC_NEW_HEAD, EC_START_STMT, EC_EXPR_HEAD, EC_CALL_HEAD, EC_NON_SEQ, EC_IN, EC_ATTACHED, EC_JZ, EST_BREAKABLE, EST_OMITTABLE, EST_NONE, SP_BREAKABLE, SP_OMITTABLE, SP_NONE, ETK_NONE, ETK_ID, ETK_MIN, ETK_DIV, ETK_ADD, ETK_NUM, ETK_STR, ETK_NL, ETK_COMMENT, PE_NO_NONVAR, PE_NO_LABEL, PE_LEXICAL, PE_NONE, CHK_T, CHK_V, CHK_NONE, THS_NEEDS_CHK, THS_IS_REACHED, THS_NONE, ANESS_UNKNOWN, ANESS_CHECKING, ANESS_INACTIVE, ANESS_ACTIVE, ACT_BARE, ACT_DECL, ACT_SCOPE, CVTZ_T, CVTZ_C, CVTZ_NONE};\n');
resolver.set('./src/other/scope-util.js', '  import {ASSERT, CH_MODULO} from \'./constants.js\';\n\nfunction _m(name) { return name+\'%\'; }\nfunction _u(name) {\n  ASSERT.call(this, name.charCodeAt(name.length-1) === CH_MODULO,\n    \'only mangled names are allowed to get unmangled\');\n  return name.substring(0, name.length-1);\n}\nfunction _full(nameSpace, name) { return nameSpace+\':\'+name; }\n\n export {_m, _u, _full};\n');
resolver.set('./src/other/globals.js', '\nvar Emitters = {};\nvar TransformByLeft = {};\nvar Transformers = {}; \nvar UntransformedEmitters = {};\n\n export {Emitters, TransformByLeft, Transformers, UntransformedEmitters};\n');
resolver.set('./src/other/scope-constants.js', '  import {_m} from \'./scope-util.js\';\n\nvar ST_GLOBAL = 1,\n    ST_MODULE = ST_GLOBAL << 1,\n    ST_SCRIPT = ST_MODULE << 1,\n    ST_EXPR = ST_SCRIPT << 1,\n    ST_DECL = ST_EXPR << 1,\n    ST_OBJ = ST_DECL << 1,\n    ST_FN = ST_OBJ << 1,\n    ST_CLS = ST_FN << 1,\n    ST_CLSMEM = ST_CLS << 1,\n    ST_STATICMEM = ST_CLSMEM << 1,\n    ST_OBJMEM = ST_STATICMEM << 1,\n    ST_METH = ST_OBJMEM << 1,\n    ST_CTOR = ST_METH << 1,\n    ST_SETTER = ST_CTOR << 1,\n    ST_GETTER = ST_SETTER << 1,\n    ST_ACCESSOR = ST_GETTER|ST_SETTER,\n    ST_ARROW = ST_GETTER << 1,\n    ST_BUNDLE = ST_ARROW << 1,\n    ST_GEN = ST_BUNDLE << 1,\n    ST_ASYNC = ST_GEN << 1,\n    ST_BLOCK = ST_ASYNC << 1,\n    ST_BARE = ST_BLOCK << 1,\n    ST_CATCH = ST_BARE << 1,\n    ST_PAREN = ST_CATCH << 1,\n    ST_NONE = 0;\n\nvar SA_THROW = 1,\n    SA_AWAIT = SA_THROW << 1,\n    SA_BREAK = SA_AWAIT << 1,\n    SA_YIELD = SA_BREAK << 1,\n    SA_RETURN = SA_YIELD << 1,\n    SA_CONTINUE = SA_RETURN << 1,\n    SA_NEW_TARGET = SA_CONTINUE << 1,\n    SA_CALLSUPER = SA_NEW_TARGET << 1,\n    SA_MEMSUPER = SA_CALLSUPER << 1,\n    SA_NONE = 0;\n\nvar SF_LOOP = 1,\n    SF_UNIQUE = SF_LOOP << 1,\n    SF_STRICT = SF_UNIQUE << 1,\n    SF_ARGS = SF_STRICT << 1,\n    SF_INSIDEIF = SF_ARGS << 1,\n    SF_COND = SF_INSIDEIF << 1,\n    SF_FORINIT = SF_COND << 1,\n    SF_WITH_SCALL = SF_FORINIT << 1,\n    SF_HERITAGE = SF_WITH_SCALL << 1,\n    SF_WITH_SMEM = SF_HERITAGE << 1,\n    SF_INSIDEPROLOGUE = SF_WITH_SMEM << 1,\n    SF_NONE = 0;\n\nvar DT_CLS = 1,\n    DT_FN = DT_CLS << 1,\n    DT_CONST = DT_FN << 1,\n    DT_VAR = DT_CONST << 1,\n    DT_CATCHARG = DT_VAR << 1,\n    DT_SPECIAL = DT_CATCHARG << 1,\n    DT_LIQUID = DT_SPECIAL << 1,\n    DT_LET = DT_LIQUID << 1,\n    DT_ARGUMENTS = DT_LET << 1,\n    DT_FNARG = DT_ARGUMENTS << 1,\n    DT_CLSNAME = DT_FNARG << 1,\n    DT_IDEFAULT = DT_CLSNAME << 1,\n    DT_IALIASED = DT_IDEFAULT << 1,\n    DT_INAMESPACE = DT_IALIASED << 1,\n    DT_INFERRED = DT_INAMESPACE << 1,\n    DT_GLOBAL = DT_INFERRED << 1,\n    DT_FNNAME = DT_GLOBAL << 1,\n    DT_EDEFAULT = DT_FNNAME << 1,\n    DT_EALIASED = DT_EDEFAULT << 1,\n    DT_ESELF = DT_EALIASED << 1,\n    DT_EFW = DT_ESELF << 1,\n    DT_BOMB = DT_EFW << 1 ,\n    DT_EXPORTED = DT_EDEFAULT|DT_EALIASED|DT_ESELF,\n    DT_IMPORTED = DT_IDEFAULT|DT_IALIASED|DT_INAMESPACE,\n    DT_NONE = 0;\n\nvar RS_ARGUMENTS = _m(\'arguments\'),\n    RS_SCALL = _m(\'special:scall\'),\n    RS_THIS = _m(\'special:this\');\n\nvar ATS_DISTINCT = 1,\n    ATS_UNSURE = ATS_DISTINCT << 1,\n    ATS_SAME = ATS_UNSURE << 1;\n\n//   line sourcemap\n//var LSM_NEED_NO_LINKPOINT = 1,\n//    LSM_MUST_HAVE_LINKPOINT = LSM_MUST_HAVE_LINKPOINT << 1,\n//    LSM_RECORDED_LINKPOINT = LSM_MUST_HAVE_LINKPOINT << 1,\n//    LSM_NONE = 0;\n \n\n export {ST_GLOBAL, ST_MODULE, ST_SCRIPT, ST_EXPR, ST_DECL, ST_OBJ, ST_FN, ST_CLS, ST_CLSMEM, ST_STATICMEM, ST_OBJMEM, ST_METH, ST_CTOR, ST_SETTER, ST_GETTER, ST_ACCESSOR, ST_ARROW, ST_BUNDLE, ST_GEN, ST_ASYNC, ST_BLOCK, ST_BARE, ST_CATCH, ST_PAREN, ST_NONE, SA_THROW, SA_AWAIT, SA_BREAK, SA_YIELD, SA_RETURN, SA_CONTINUE, SA_NEW_TARGET, SA_CALLSUPER, SA_MEMSUPER, SA_NONE, SF_LOOP, SF_UNIQUE, SF_STRICT, SF_ARGS, SF_INSIDEIF, SF_COND, SF_FORINIT, SF_WITH_SCALL, SF_HERITAGE, SF_WITH_SMEM, SF_INSIDEPROLOGUE, SF_NONE, DT_CLS, DT_FN, DT_CONST, DT_VAR, DT_CATCHARG, DT_SPECIAL, DT_LIQUID, DT_LET, DT_ARGUMENTS, DT_FNARG, DT_CLSNAME, DT_IDEFAULT, DT_IALIASED, DT_INAMESPACE, DT_INFERRED, DT_GLOBAL, DT_FNNAME, DT_EDEFAULT, DT_EALIASED, DT_ESELF, DT_EFW, DT_BOMB, DT_EXPORTED, DT_IMPORTED, DT_NONE, RS_ARGUMENTS, RS_SCALL, RS_THIS, ATS_DISTINCT, ATS_UNSURE, ATS_SAME};\n');
resolver.set('./src/other/lexer-constants.js', '  import {ASSERT, HAS} from \'./constants.js\';\n\nvar VDT_VOID = 1;\nvar VDT_TYPEOF = 2;\nvar VDT_NONE = 0;\nvar VDT_DELETE = 4;\nvar VDT_AWAIT = 8;\n\nvar TK_NONE = 0;\nvar TK_EOF = 1 << 8;\nvar TK_NUM = TK_EOF << 1;\nvar TK_ID = TK_NUM << 1;\nvar TK_SIMP_ASSIG = TK_ID << 1;\nvar TK_UNARY = TK_SIMP_ASSIG << 1;\nvar TK_SIMP_BINARY = TK_UNARY << 1;\nvar TK_AA_MM = TK_SIMP_BINARY << 1;\nvar TK_OP_ASSIG = TK_AA_MM << 1;\nvar TK_YIELD = TK_OP_ASSIG << 1;\nvar TK_ELLIPSIS = TK_YIELD << 1;\nvar TK_DIV = TK_ELLIPSIS << 1;\nvar TK_UNBIN = TK_SIMP_BINARY|TK_UNARY;\nvar TK_ANY_ASSIG = TK_SIMP_ASSIG|TK_OP_ASSIG;\nvar TK_ANY_BINARY = TK_SIMP_BINARY|TK_ANY_ASSIG;\n\nvar BINP = {};\n\nvar PREC_NONE = 0; // [<start>]\nvar PREC_COMMA = nextl(PREC_NONE); // ,\nvar PREC_ASSIG = nextr(PREC_COMMA); // =, [<op>]=\nvar PREC_COND = nextl(PREC_ASSIG); // ?:\n\nvar PREC_LOG_OR =\nBINP[\'||\'] = \nnextl(PREC_COND); // ||\n\nvar PREC_LOG_AND = \nBINP[\'&&\'] = \nnextl(PREC_LOG_OR); // &&\n\nvar PREC_BIT_OR = \nBINP[\'|\'] = \nnextl(PREC_LOG_AND); // |\n\nvar PREC_BIT_XOR = \nBINP[\'^\'] = \nnextl(PREC_BIT_OR); // ^\n\nvar PREC_BIT_AND = \nBINP[\'&\'] = \nnextl(PREC_BIT_XOR); // &\n\nvar PREC_EQ = \nBINP[\'!=\'] = BINP[\'===\'] = BINP[\'==\'] = BINP[\'!==\'] = \nnextl(PREC_BIT_AND); // !=, ===, ==, !==\n\nvar PREC_COMP =\nBINP[\'>\'] = BINP[\'<=\'] = BINP[\'<\'] = BINP[\'>=\'] = \nnextl(PREC_EQ); // >, <=, <, >=, instanceof, in\n\nvar PREC_SH =\nBINP[\'>>>\'] = BINP[\'>>\'] = BINP[\'<<\'] = \nnextl(PREC_COMP); // >>>, >>, <<\n\nvar PREC_ADD = BINP[\'+\'] = BINP[\'-\'] = nextl(PREC_SH); // +, -\nvar PREC_MUL = BINP[\'/\'] = BINP[\'%\'] = BINP[\'*\'] =  nextl(PREC_ADD); // *, /\nvar PREC_EX = BINP[\'**\'] = nextl(PREC_MUL); // **\n\nvar PREC_UNARY = nextr(PREC_EX); // delete, void, -, +, typeof; not really a right-associative thing\nvar PREC_UP = nextr(PREC_UNARY); // ++, --; not really a right-associative thing\n\nvar FL_HEADLESS_FLOAT = 0,\n    FL_SIMPLE_FLOAT = 1,\n    FL_GET_E = 2;\n\nfunction isLA(nPrec) { return !isRA(nPrec); }\nfunction nextl(nPrec) { return (nPrec&1) ? nPrec + 1 : nPrec + 2; }\nfunction nextr(nPrec) { return (nPrec&1) ? nPrec + 2 : nPrec + 1; }\nfunction isLog(nPrec) {\n  switch (nPrec) {\n  case PREC_LOG_AND:\n  case PREC_LOG_OR:\n    return true;\n  }\n  return false;\n}\nfunction bp(o) {\n  ASSERT.call(this, HAS.call(BINP, o), \'unknown operator\');\n  return BINP[o];\n}\nfunction isRA(nPrec) { return nPrec&1; }\n\n export {VDT_VOID, VDT_TYPEOF, VDT_NONE, VDT_DELETE, VDT_AWAIT, TK_NONE, TK_EOF, TK_NUM, TK_ID, TK_SIMP_ASSIG, TK_UNARY, TK_SIMP_BINARY, TK_AA_MM, TK_OP_ASSIG, TK_YIELD, TK_ELLIPSIS, TK_DIV, TK_UNBIN, TK_ANY_ASSIG, TK_ANY_BINARY, BINP, PREC_NONE, PREC_COMMA, PREC_ASSIG, PREC_COND, PREC_LOG_OR, PREC_LOG_AND, PREC_BIT_OR, PREC_BIT_XOR, PREC_BIT_AND, PREC_EQ, PREC_COMP, PREC_SH, PREC_ADD, PREC_MUL, PREC_EX, PREC_UNARY, PREC_UP, FL_HEADLESS_FLOAT, FL_SIMPLE_FLOAT, FL_GET_E, isLA, nextl, nextr, isLog, bp, isRA};\n');
resolver.set('./src/other/error-constants.js', '\nvar ERR_FLAG_LEN = 0;\n\nvar ERR_P_SYN = 1 << ERR_FLAG_LEN++,\n    ERR_A_SYN = 1 << ERR_FLAG_LEN++,\n    ERR_S_SYN = 1 << ERR_FLAG_LEN++,\n    ERR_P_SEM = 1 << ERR_FLAG_LEN++,\n    ERR_A_SEM = 1 << ERR_FLAG_LEN++,\n    ERR_S_SEM = 1 << ERR_FLAG_LEN++,\n    ERR_PIN = 1 << ERR_FLAG_LEN++, // looks like it need not have any sub-type yet\n    ERR_SYN = ERR_P_SYN|ERR_A_SYN|ERR_S_SYN,\n    ERR_SEM = ERR_P_SEM|ERR_A_SEM|ERR_S_SEM,\n    ERR_I = 0;\n\nfunction newErr(flags) {\n  return (ERR_I++ << ERR_FLAG_LEN)|flags;\n}\n\nvar ERR_NONE_YET = 0,\n    // [([a])] = 12; <p syntactic, a syntactic, s none>\n    ERR_PAREN_UNBINDABLE = newErr(ERR_P_SYN|ERR_A_SYN),\n\n    // { a = 12 }; <p none, a none, s syntactic>@pin@\n    ERR_SHORTHAND_UNASSIGNED = newErr(ERR_S_SYN|ERR_PIN),\n\n    // [...a, b] = [...e,] = 12 ; <p syntactic, a syntactic, s none>@pin@\n    ERR_NON_TAIL_REST = newErr(ERR_P_SYN|ERR_PIN|ERR_A_SYN),\n\n    // [arguments, [arguments=12], [arguments]=12, eval] = \'l\'; <p none, a none, s semantic>\n    ERR_ARGUMENTS_OR_EVAL_ASSIGNED = newErr(ERR_S_SEM),\n\n    // function* l() { ([e=yield])=>12 }; <p semantic or syntactic, a semantic or syntactic, s none>\n    ERR_YIELD_OR_SUPER = newErr(ERR_P_SEM|ERR_A_SEM),\n\n    // (a, ...b); <p none, a none, s syntactic>\n    ERR_UNEXPECTED_REST = newErr(ERR_S_SYN),\n\n    // (); <p none, a none, s syntactic>\n    ERR_EMPTY_LIST_MISSING_ARROW = newErr(ERR_S_SYN),\n\n    // (a,); <p none, a none, s syntactic>@pin@\n    ERR_NON_TAIL_EXPR = newErr(ERR_S_SYN|ERR_PIN),\n\n    // async a\n    ERR_INTERMEDIATE_ASYNC = newErr(ERR_S_SYN),\n\n    /* async\n       (a)=>12 */\n    ERR_ASYNC_NEWLINE_BEFORE_PAREN = newErr(ERR_P_SYN),\n\n    ERR_ARGUMENTS_OR_EVAL_DEFAULT = newErr(ERR_S_SYN),\n \n    // function l() { \'\\12\'; \'use strict\'; }\n    ERR_PIN_OCTAL_IN_STRICT = newErr(ERR_S_SYN|ERR_PIN),\n\n    // for (a i\\u0074 e) break;\n    ERR_PIN_UNICODE_IN_RESV = newErr(ERR_S_SYN|ERR_PIN),\n\n    // [ a -= 12 ] = 12; <p syntactic, a syntactic, s none>@pin@\n    ERR_PIN_NOT_AN_EQ = newErr(ERR_S_SYN|ERR_PIN);\n\n// if a new error is a syntactic error, and the current error is a semantic one, then replace\nfunction agtb(a, b) {\n  return (a & ERR_SYN) ?\n    (b & ERR_SYN) === 0 :\n    false;\n}\n\n// TODO: choose a more descriptive name\nvar NORMALIZE_COMMON = [\'li0\', \'c0\', \'col0\', \'li\', \'c\', \'col\', \'loc0\', \'loc\'];\n\n export {ERR_FLAG_LEN, ERR_P_SYN, ERR_A_SYN, ERR_S_SYN, ERR_P_SEM, ERR_A_SEM, ERR_S_SEM, ERR_PIN, ERR_SYN, ERR_SEM, ERR_I, newErr, ERR_NONE_YET, ERR_PAREN_UNBINDABLE, ERR_SHORTHAND_UNASSIGNED, ERR_NON_TAIL_REST, ERR_ARGUMENTS_OR_EVAL_ASSIGNED, ERR_YIELD_OR_SUPER, ERR_UNEXPECTED_REST, ERR_EMPTY_LIST_MISSING_ARROW, ERR_NON_TAIL_EXPR, ERR_INTERMEDIATE_ASYNC, ERR_ASYNC_NEWLINE_BEFORE_PAREN, ERR_ARGUMENTS_OR_EVAL_DEFAULT, ERR_PIN_OCTAL_IN_STRICT, ERR_PIN_UNICODE_IN_RESV, ERR_PIN_NOT_AN_EQ, agtb, NORMALIZE_COMMON};\n');
resolver.set('./src/other/unicode.js', '  import {fromRunLenCodes} from \'./util.js\';\n  import {D_INTBITLEN, M_INTBITLEN} from \'./int-constants.js\';\n\nvar IDS_ = fromRunLenCodes([0,8472,1,21,1,3948,2],\n fromRunLenCodes([0,65,26,6,26,47,1,10,1,4,1,5,23,1,31,1,458,4,12,14,5,7,1,1,1,129,\n5,1,2,2,4,1,1,6,1,1,3,1,1,1,20,1,83,1,139,8,166,1,38,2,1,7,39,72,27,5,3,45,43,35,2,\n1,99,1,1,15,2,7,2,10,3,2,1,16,1,1,30,29,89,11,1,24,33,9,2,4,1,5,22,4,1,9,1,3,1,23,\n25,71,21,79,54,3,1,18,1,7,10,15,16,4,8,2,2,2,22,1,7,1,1,3,4,3,1,16,1,13,2,1,3,14,2,\n19,6,4,2,2,22,1,7,1,2,1,2,1,2,31,4,1,1,19,3,16,9,1,3,1,22,1,7,1,2,1,5,3,1,18,1,15,\n2,23,1,11,8,2,2,2,22,1,7,1,2,1,5,3,1,30,2,1,3,15,1,17,1,1,6,3,3,1,4,3,2,1,1,1,2,3,\n2,3,3,3,12,22,1,52,8,1,3,1,23,1,16,3,1,26,3,5,2,35,8,1,3,1,23,1,10,1,5,3,1,32,1,1,\n2,15,2,18,8,1,3,1,41,2,1,16,1,16,3,24,6,5,18,3,24,1,9,1,1,2,7,58,48,1,2,12,7,58,2,\n1,1,2,2,1,1,2,1,6,4,1,7,1,3,1,1,1,1,2,2,1,4,1,2,9,1,2,5,1,1,21,4,32,1,63,8,1,36,27,\n5,115,43,20,1,16,6,4,4,3,1,3,2,7,3,4,13,12,1,17,38,1,1,5,1,2,43,1,333,1,4,2,7,1,1,\n1,4,2,41,1,4,2,33,1,4,2,7,1,1,1,4,2,15,1,57,1,4,2,67,37,16,16,86,2,6,3,620,2,17,1,\n26,5,75,3,11,7,13,1,4,14,18,14,18,14,13,1,3,15,52,35,1,4,1,67,88,8,41,1,1,5,70,10,\n31,49,30,2,5,11,44,4,26,54,23,9,53,82,1,93,47,17,7,55,30,13,2,10,44,26,36,41,3,10,\n36,107,4,1,4,3,2,9,192,64,278,2,6,2,38,2,6,2,8,1,1,1,1,1,1,1,31,2,53,1,7,1,1,3,3,1,\n7,3,4,2,6,4,13,5,3,1,7,116,1,13,1,16,13,101,1,4,1,2,10,1,1,2,6,6,1,1,1,1,1,1,16,2,\n4,5,5,4,1,17,41,2679,47,1,47,1,133,6,4,3,2,12,38,1,1,5,1,2,56,7,1,16,23,9,7,1,7,1,\n7,1,7,1,7,1,7,1,7,1,7,550,3,25,9,7,5,2,5,4,86,4,5,1,90,1,4,5,41,3,94,17,27,53,16,512,\n6582,74,20950,42,1165,67,46,2,269,3,16,10,2,20,47,16,31,2,80,39,9,2,103,2,35,2,8,63,\n11,1,3,1,4,1,23,29,52,14,50,62,6,3,1,1,1,12,28,10,23,25,29,7,47,28,1,16,5,1,10,10,\n5,1,41,23,3,1,8,20,23,3,1,3,50,1,1,3,2,2,5,2,1,1,1,24,3,2,11,7,3,12,6,2,6,2,6,9,7,\n1,7,1,43,1,10,10,115,29,11172,12,23,4,49,8452,366,2,106,38,7,12,5,5,1,1,10,1,13,1,\n5,1,1,1,2,1,2,1,108,33,363,18,64,2,54,40,12,116,5,1,135,36,26,6,26,11,89,3,6,2,6,2,\n6,2,3,35,12,1,26,1,19,1,2,1,15,2,14,34,123,69,53,267,29,3,49,47,32,16,27,5,38,10,30,\n2,36,4,8,1,5,42,158,98,40,8,52,156,311,9,22,10,8,152,6,2,1,1,44,1,2,3,1,2,23,10,23,\n9,31,65,19,1,2,10,22,10,26,70,56,6,2,64,1,15,4,1,3,1,27,44,29,3,29,35,8,1,28,27,54,\n10,22,10,19,13,18,110,73,55,51,13,51,784,53,75,45,32,25,26,36,41,35,3,1,12,48,14,4,\n21,1,1,1,35,18,1,25,84,7,1,1,1,4,1,15,1,10,7,47,38,8,2,2,2,22,1,7,1,2,1,5,3,1,18,1,\n12,5,286,48,20,2,1,1,184,47,41,4,36,48,20,1,59,43,85,26,390,64,31,1,448,57,1287,922,\n102,111,17,196,2748,1071,4049,583,8633,569,7,31,113,30,18,48,16,4,31,21,5,19,880,69,\n11,1,66,13,16480,2,3070,107,5,13,3,9,7,10,5990,85,1,71,1,2,2,1,2,2,2,4,1,12,1,1,1,\n7,1,65,1,4,2,8,1,7,1,28,1,4,1,5,1,1,3,7,1,340,2,25,1,25,1,31,1,25,1,31,1,25,1,31,1,\n25,1,31,1,25,1,8,4148,197,1339,4,1,27,1,2,1,1,2,1,1,10,1,4,1,1,1,1,6,1,4,1,1,1,1,1,\n1,3,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,4,1,7,1,4,1,4,1,1,1,10,1,17,5,3,1,5,1,17,\n4420,42711,41,4149,11,222,2,5762,10590,542]));\n\nvar IDC_ = fromRunLenCodes([0,183,1,719,1,4065,9,1640,1],fromRunLenCodes ( ( [ 0 ,\n48,10,7,26,4,1,1,26,47,1,10,1,1,1,2,1,5,23,1,31,1,458,4,12,14,5,7,1,1,1,17,117,1,2,\n2,4,1,1,6,5,1,1,1,20,1,83,1,139,1,5,2,166,1,38,2,1,7,39,9,45,1,1,1,2,1,2,1,1,8,27,\n5,3,29,11,5,74,4,102,1,8,2,10,1,19,2,1,16,59,2,101,14,54,4,1,5,46,18,28,68,21,46,129,\n2,10,1,19,1,8,2,2,2,22,1,7,1,1,3,4,2,9,2,2,2,4,8,1,4,2,1,5,2,12,15,3,1,6,4,2,2,22,\n1,7,1,2,1,2,1,2,2,1,1,5,4,2,2,3,3,1,7,4,1,1,7,16,11,3,1,9,1,3,1,22,1,7,1,2,1,5,2,10,\n1,3,1,3,2,1,15,4,2,10,9,1,7,3,1,8,2,2,2,22,1,7,1,2,1,5,2,9,2,2,2,3,8,2,4,2,1,5,2,10,\n1,1,16,2,1,6,3,3,1,4,3,2,1,1,1,2,3,2,3,3,3,12,4,5,3,3,1,4,2,1,6,1,14,10,16,4,1,8,1,\n3,1,23,1,16,3,8,1,3,1,4,7,2,1,3,5,4,2,10,17,3,1,8,1,3,1,23,1,10,1,5,2,9,1,3,1,4,7,\n2,7,1,1,4,2,10,1,2,14,3,1,8,1,3,1,41,2,8,1,3,1,5,8,1,7,5,2,10,10,6,2,2,1,18,3,24,1,\n9,1,1,2,7,3,1,4,6,1,1,1,8,6,10,2,2,13,58,5,15,1,10,39,2,1,1,2,2,1,1,2,1,6,4,1,7,1,\n3,1,1,1,1,2,2,1,13,1,3,2,5,1,1,1,6,2,10,2,4,32,1,23,2,6,10,11,1,1,1,1,1,4,10,1,36,\n4,20,1,18,1,36,9,1,57,74,6,78,2,38,1,1,5,1,2,43,1,333,1,4,2,7,1,1,1,4,2,41,1,4,2,33,\n1,4,2,7,1,1,1,4,2,15,1,57,1,4,2,67,2,3,9,9,14,16,16,86,2,6,3,620,2,17,1,26,5,75,3,\n11,7,13,1,7,11,21,11,20,12,13,1,3,1,2,12,84,3,1,4,2,2,10,33,3,2,10,6,88,8,43,5,70,\n10,31,1,12,4,12,10,40,2,5,11,44,4,26,6,11,37,28,4,63,1,29,2,11,6,10,13,1,8,14,66,76,\n4,10,17,9,12,116,12,56,8,10,3,49,82,3,1,35,1,2,6,246,6,282,2,6,2,38,2,6,2,8,1,1,1,\n1,1,1,1,31,2,53,1,7,1,1,3,3,1,7,3,4,2,6,4,13,5,3,1,7,66,2,19,1,28,1,13,1,16,13,51,\n13,4,1,3,12,17,1,4,1,2,10,1,1,2,6,6,1,1,1,1,1,1,16,2,4,5,5,4,1,17,41,2679,47,1,47,\n1,133,6,9,12,38,1,1,5,1,2,56,7,1,15,24,9,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,32,517,3,\n25,15,1,5,2,5,4,86,2,7,1,90,1,4,5,41,3,94,17,27,53,16,512,6582,74,20950,42,1165,67,\n46,2,269,3,28,20,48,4,10,1,115,37,9,2,103,2,35,2,8,63,49,24,52,12,69,11,10,6,24,3,\n1,1,1,2,46,2,36,12,29,3,65,14,11,6,31,1,55,9,14,2,10,6,23,3,73,24,3,2,16,2,5,10,6,\n2,6,2,6,9,7,1,7,1,43,1,10,10,123,1,2,2,10,6,11172,12,23,4,49,8452,366,2,106,38,7,12,\n5,5,12,1,13,1,5,1,1,1,2,1,2,1,108,33,363,18,64,2,54,40,12,4,16,16,16,3,2,24,3,32,5,\n1,135,19,10,7,26,4,1,1,26,11,89,3,6,2,6,2,6,2,3,35,12,1,26,1,19,1,2,1,15,2,14,34,123,\n69,53,136,1,130,29,3,49,15,1,31,32,16,27,5,43,5,30,2,36,4,8,1,5,42,158,2,10,86,40,\n8,52,156,311,9,22,10,8,152,6,2,1,1,44,1,2,3,1,2,23,10,23,9,31,65,19,1,2,10,22,10,26,\n70,56,6,2,64,4,1,2,5,8,1,3,1,27,4,3,4,1,32,29,3,29,35,8,1,30,25,54,10,22,10,19,13,\n18,110,73,55,51,13,51,781,71,31,10,15,60,21,25,7,10,6,53,1,10,16,36,2,1,9,69,5,3,3,\n11,1,1,35,18,1,37,72,7,1,1,1,4,1,15,1,10,7,59,5,10,6,4,1,8,2,2,2,22,1,7,1,2,1,5,2,\n9,2,2,2,3,2,1,6,1,5,7,2,7,3,5,267,70,1,1,8,10,166,54,2,9,23,6,34,65,3,1,11,10,38,56,\n8,10,54,26,3,15,4,10,358,74,21,1,448,57,1287,922,102,111,17,196,2748,1071,4049,583,\n8633,569,7,31,1,10,102,30,2,5,11,55,9,4,12,10,9,21,5,19,880,69,11,47,16,17,16480,2,\n3070,107,5,13,3,9,7,10,3,2,5318,5,3,6,8,8,2,7,30,4,148,3,443,85,1,71,1,2,2,1,2,2,2,\n4,1,12,1,1,1,7,1,65,1,4,2,8,1,7,1,28,1,4,1,5,1,1,3,7,1,340,2,25,1,25,1,31,1,25,1,31,\n1,25,1,31,1,25,1,31,1,25,1,8,2,50,512,55,4,50,8,1,14,1,22,5,1,15,3408,197,11,7,1321,\n4,1,27,1,2,1,1,2,1,1,10,1,4,1,1,1,1,6,1,4,1,1,1,1,1,1,3,1,2,1,1,2,1,1,1,1,1,1,1,1,\n1,1,2,1,1,2,4,1,7,1,4,1,4,1,1,1,10,1,17,5,3,1,5,1,17,4420,42711,41,4149,11,222,2,5762,\n10590,542,722658,240 ]) ) )  ;\n\nfunction set(bits, i) {\n  bits[i>>D_INTBITLEN] |= ( 1 << ( i & M_INTBITLEN ) );\n\n}\n\nset(IDC_,0x200C);\nset(IDC_,0x200D);\n\n\n\n export {IDS_, IDC_, set};\n');
resolver.set('./src/other/int-constants.js', ' export var INTBITLEN = (function() {\n  var allOnes = ~0;\n  var i = 0;\n  while (allOnes) {\n    allOnes >>>= 1;\n    i++;\n  }\n\n  return i;\n }());\n\n\n export var D_INTBITLEN = 0, M_INTBITLEN = INTBITLEN - 1;\n while ( M_INTBITLEN >> (++D_INTBITLEN) );\n');
resolver.set('./src/other/util.js', '  import {PAREN, ETK_NL, CH_0, CH_9, CH_f, CH_a, CH_A, CH_F, STRING_TYPE, ASSERT, HAS, B, CVTZ_T, CVTZ_C, I_31} from \'./constants.js\';\n  import {INTBITLEN, D_INTBITLEN, M_INTBITLEN} from \'./int-constants.js\';\n  import {isIDHead, isIDBody} from \'./ctype.js\';\n\nfunction char2int(c) { return c.charCodeAt(0); }\nvar hexD = [ \'1\', \'2\', \'3\', \'4\', \'5\',\n             \'6\', \'7\', \'8\', \'9\', \'a\', \'b\', \'c\', \'d\', \'e\', \'f\' ];\nhexD = [\'0\'].concat(hexD);\n\nfunction hex(number) {\n  var str = \"\";\n  str = hexD[number&0xf] + str\n  str = hexD[(number>>=4)&0xf] + str ;\n  str = hexD[(number>>=4)&0xf] + str ;\n  str = hexD[(number>>=4)&0xf] + str ;\n  \n  return str;\n}\n\nfunction hex2(number) {\n  var str = \"\";\n  str = hexD[number&0xf] + str\n  str = hexD[(number>>=4)&0xf] + str ;\n  \n  return str;\n}\n\nfunction fromRunLenCodes(runLenArray, bitm) {\n  bitm = bitm || [];\n  var bit = runLenArray[0];\n  var runLenIdx = 1, bitIdx = 0;\n  var runLen = 0;\n  while (runLenIdx < runLenArray.length) {\n    runLen = runLenArray[runLenIdx];\n    while (runLen--) {\n      while ((INTBITLEN * (bitm.length)) < bitIdx) bitm.push(0);\n      if (bit) bitm[bitIdx >> D_INTBITLEN] |= (1 << (M_INTBITLEN & bitIdx));\n      bitIdx++ ;\n    }\n    runLenIdx++ ;\n    bit ^= 1;\n  }\n  return (bitm);\n}\n\nfunction asBitmap(str) {\n  var bm = [], e = 0;\n  while (e < str.length) {\n    var ch = str.charCodeAt(e);\n    var byteIndex = ch >> D_INTBITLEN;\n    while (bm.length <= byteIndex) bm.push(0);\n    bm[byteIndex] |= (1 << (ch & M_INTBITLEN));\n    e++;\n  }\n  return bm;\n}\n\nfunction makeAcceptor(str) {\n  var bm = asBitmap(str);\n  return function(ch) {\n    var byteIndex = ch >> D_INTBITLEN;\n    if (byteIndex >= bm.length)\n      return 0;\n    return bm[byteIndex] & (1 << (ch & M_INTBITLEN));\n  };\n}\n\nfunction arorev(l) {\n  switch ( l ) {\n     case \'arguments\':\n     case \'eval\':\n       return true;\n  }\n\n  return false;\n};\n\nfunction cp2sp(codePoint )  {\n  if ( codePoint <= 0xFFFF)\n    return String.fromCharCode(codePoint) ;\n\n  return String.fromCharCode(\n    ((codePoint-0x10000 )>>10)+0x0D800,\n    ((codePoint-0x10000 )&(1024-1))+0x0DC00\n  );\n}\n\nfunction core(n) { return n.type === PAREN ? n.expr : n; };\n\nfunction NL(tt) { return tt & ETK_NL; }\n\nfunction hex2num(n) {\n  return (n >= CH_0 && n <= CH_9) ? n - CH_0 :\n         (n <= CH_f && n >= CH_a) ? 10 + n - CH_a :\n         (n >= CH_A && n <= CH_F) ? 10 + n - CH_A : -1;\n}\n\nfunction createObj(baseObj) {\n  function E() {} E.prototype = baseObj;\n  return new E();\n}\n\nfunction getIDName(n) {\n  if (n.type === \'Identifier\')\n    return n.name;\n  if (n.type === \'Literal\' &&\n    typeof n.value === STRING_TYPE &&\n    isIDName(n.value))\n    return n.value;\n  return \"\";\n};\n\nfunction isIDName(str) {\n  var e = 0;\n  if (str.length === 0)\n    return false;\n  var ch = str.charCodeAt(e++), ch2 = -1;\n  if (ch >= 0x0d800 && ch <= 0x0dbff) {\n    if (e < str.length)\n      ch = surrogate(ch, str.charCodeAt(e++));\n    else\n      return false;\n  }\n  if (!isIDHead(ch))\n    return false;\n  while (e < str.length) {\n    ch = str.charCodeAt(e++);\n    if (ch >= 0x0d800 && ch <= 0x0dbff) {\n      if (e < str.length)\n        ch = surrogate(ch, str.charCodeAt(e++));\n      else\n        return false;\n    }\n    if (!isIDBody(ch))\n      return false;\n  }\n  return true;\n}\n\nfunction CB(n) {\n  ASSERT.call(this, HAS.call(n, \'#c\'), \'#c\');\n  return n[\'#c\'];\n}\n\nfunction cmn_ac(cb, name, list) {\n  if (list === null)\n    return;\n  if (!HAS.call(cb, name) || cb[name] === null)\n    cb[name] = list;\n  else\n    cb[name].mergeWith(list);\n}\n\nfunction cmn_erase(cb, name) {\n  if (HAS.call(cb, name)) {\n    var list = cb[name];\n    cb[name] = null;\n    return list;\n  }\n  return null;\n}\n\nfunction cmn(cb, name) {\n  return HAS.call(cb, name) ? cb[name] : null;\n}\n   \nfunction isAssigList(n) {\n  return n.type === \'#Untransformed\' && n.kind === \'assig-list\';\n}\n\nfunction cpReg(n) {\n  switch (n.type) {\n  case \'#Regex.Hy\':\n  case \'#Regex.SurrogateComponent\':\n  case \'#Regex.CharSeq\':\n  case \'#Regex.Ho\':\n    return n.cp;\n  default:\n    return -1;\n  }\n}\n\nfunction isCharSeq(n) { return n.type === \'#Regex.CharSeq\'; }\nfunction isTemp(n) {\n  return n.type === \'#Untransformed\' &&\n    n.kind === \'temp\';\n}\n\nfunction isInteger(n) { return (n|0) === n; }\n\nfunction belongs1to2(t1, t2) {\n  return t1.indexOf(t2+\'.\') === 0 || t1 === t2;\n}\n\nfunction isResolvedName(n) {\n  return belongs1to2(n.type, \'#-ResolvedName\');\n}\n\n// vlq(-(2 ** 31))\nfunction vlq1sh31() {\n  var str = B[(1<<5)|1], len = 32 - 4;\n  while (true) {\n    if (len >= 5) { str += B[1<<5]; len -= 5; }\n    else { str += B[1 << (len-1)]; break }\n  }\n  return str;\n}\n\nfunction tzc(resolvedName) {\n  return (resolvedName[\'#cvtz\'] & CVTZ_T) !== 0;\n}\n\nfunction cvc(resolvedName) {\n  return (resolvedName[\'#cvtz\'] & CVTZ_C) !== 0;\n}\n\nfunction tg(resolvedName) {\n  var real = resolvedName[\'#ref\'].getDecl_real();\n  ASSERT.call(this, real.ref.parentRef === null, \'relocated\' );\n  return real;\n}\n\nfunction iskw(name, v, s) {\n  switch (name.length) {\n  case 1: return false;\n  case 2:\n    switch (name) {\n    case \'do\': case \'if\': case \'in\':\n      return true;\n    }\n    return false;\n  case 3:\n    switch (name) {\n    case \'new\': case \'for\': case \'try\':\n    case \'let\': case \'var\':\n      return true;\n    case \'int\':\n      return v <= 5;\n    }\n    return false;\n\n  case 4:\n    switch (name) {\n    case \'null\': case \'void\': case \'this\':\n    case \'true\': case \'case\': case \'else\':\n    case \'with\': case \'enum\':\n      return true;\n    case \'byte\': case \'char\':\n    case \'goto\': case \'long\':\n      return v <= 5;\n    }\n    return false;\n\n  case 5:\n    switch (name) {\n    case \'super\': case \'break\':  case \'catch\':\n      return true;\n    case \'class\': case \'const\': case \'throw\':\n    case \'while\':\n      return true;\n    case \'yield\': \n      return s;\n    case \'false\':\n      return true;\n    case \'await\':\n    case \'async\':\n      return false;\n    case \'final\': case \'float\': case \'short\':\n      return v <= 5;\n    }\n    return false;\n\n  case 6:\n    switch (name) {\n    case \'static\':\n      return s || v <= 5;\n    case \'delete\': case \'typeof\': case \'export\':\n    case \'import\': case \'return\': case \'switch\':\n      return true;\n    case \'public\':\n      return s;\n    case \'double\': case \'native\': case \'throws\':\n      return v <= 5;\n    }\n    return false;\n\n  case 7:\n    switch (name) {\n    case \'default\': case \'extends\': case \'finally\':\n      return true;\n    case \'package\': case \'private\':\n      return s;\n    case \'boolean\':\n      return v <= 5;\n    }\n    return false;\n\n  case 8:\n    switch (name) {\n    case \'function\': case \'debugger\': case \'continue\':\n      return true;\n    case \'abstract\': case \'volatile\':\n      return v <= 5;\n    }\n    return false;\n\n  case 9:\n    switch (name) {\n    case \'interface\': case \'protected\':\n      return s;\n    case \'transient\':\n      return v <= 5;\n    }\n    return false;\n\n  case 10:\n    switch (name) {\n    case \'instanceof\': return true;\n    case \'implements\': return s || v <= 5;\n    }\n    return false;\n\n  case 12:\n    return v <= 5 && name === \'synchronized\' ;\n  }\n  return false;\n};\n \nfunction vlq(num) {\n  var hexet = 0;\n  var ro = 0; // right offset (0 <= ro <= lastRo)\n  var lastRo = 5;\n  var v = \"\";\n  if (num < 0) {\n    hexet = 1;\n    num = ((~(num & I_31)) & I_31);\n    if (num === I_31)\n      return vlq1sh31();\n    ++num;\n  }\n  ro = 1; // sign bit\n  while (true) {\n    var maxRead = 5 - ro;\n    var maxMask = (1<<maxRead)-1;\n    var c = 1; // continue;\n\n    var bits = num & maxMask; \n    num >>>= maxRead;\n    if (num === 0)\n      c = 0;\n    hexet |= bits << ro;\n    if (c) hexet |= 1 << lastRo;\n    v += B[hexet];\n    if (num <= 0)\n      break;\n    maxRead = 5;\n    ro = 0; hexet = 0;\n  } \n  return v;\n}\n\nfunction findElem(list, t) {\n  var e = 0;\n  while (e < list.length) {\n    var elem = list[e];\n    if (elem && elem.type === t)\n      return e;\n    e++;\n  }\n  return -1;\n}\n\nfunction needsConstCheck(n) {\n  return n.type === \'#ResolvedName\' && n.constCheck;\n}\n\nfunction octStr2num(octStr) {\n  var v = 0, e = 0;\n  while (e < octStr.length)\n    v = (v<<3)|(octStr.charCodeAt(e++)-CH_0);\n  return v;\n}\n\nfunction surrogate(ch1, ch2) {\n  return ((ch1-0x0d800)<<10)+(ch2-0x0dc00)+0x010000;\n}\n\nfunction isDirective(n) {\n  return (\n    n.type === \'Literal\' &&\n    typeof(n.value) === STRING_TYPE\n  );\n}\n\n export {char2int, hexD, hex, hex2, fromRunLenCodes, asBitmap, makeAcceptor, arorev, cp2sp, core, NL, hex2num, createObj, getIDName, isIDName, CB, cmn_ac, cmn_erase, cmn, isAssigList, cpReg, isCharSeq, isTemp, isInteger, belongs1to2, isResolvedName, vlq1sh31, tzc, cvc, tg, iskw, vlq, findElem, needsConstCheck, octStr2num, surrogate, isDirective};\n');
resolver.set('./src/other/helpers.js', ' export var HELPERS = [\n   { id: \'#arr\',\n     codeString: \'o.arr = function() { var a = [], l = 0; while (l < arguments.length) a = a.concat(arguments[l++]); return a; };\',\n     uses: []\n   },\n   { id: \'#tz\',\n     codeString: \'o.tz = function(n) { err(\\\'\"\\\'+n+\\\'\" is in the tdz -- it was used before its declaration was reached and evaluated\\\'); };\',\n     uses: [\'#err\']\n   },\n   { id: \'#c\',\n     codeString: \'o.c = function(c,a) { return c.apply(void 0, a); };\',\n     uses: []\n   },\n   { id: \'#sp\' ,\n     codeString: \'o.sp = function(v) { return [].concat(v); };\',\n     uses: []\n   },\n   { id: \'#n\',\n     codeString: \'o.n = function(ctor, a) { var l = 0, str = \"new ctor(\"; while (l < a.length) { if (l) str += \",\"; str += \"a[\"+l+\"]\"; l++; } return eval(str); };\',\n     uses: []\n   },\n   { id: \'#cm\',\n     codeString: \'o.cm = function(_this, c, a) { return c.apply(_this, a); };\',\n     uses: []\n   },\n   { id: \'#err\',\n     codeString: \'function err(str) { throw new Error(str); }\',\n     uses: []\n   },\n   { id: \'#obj\',\n     codeString: \'o.obj = function() { var obj = arguments[0], k = 1; while (k < arguments.length) { var v = k + 1; obj[arguments[k]] = arguments[v]; k += 2; } return obj; };\',\n     uses: []\n   },\n   { id: \'#ex\',\n     codeString: \'o.ex = function(base, p) { return Math.pow(base, p);};\',\n     uses: []\n   },\n   { id: \'#arrIter\',\n     codeString: \'o.arrIter = function(v) { return new arrIter0(v); };\',\n     uses: [\'#arrIter0\']\n   },\n   { id: \'#arrIter0\',\n     codeString: \'function arrIter0(v) { this.v = v; this.i = 0; }\\nvar ac = arrIter0.prototype;\\nac.get = function() { return this.v[this.i++]; };\\nac.end = function() { return this.v; };\',\n     uses: []\n   },\n   { id: \'#u\',\n     codeString: \'o.u = function(n) { return n === void 0; }; \',\n     uses: []\n   },\n   { id: \'#of\',\n     codeString: \'o.of = function(v) { return new arrIter0(v); };\',\n     uses: [\'#arrIter0\']\n   },\n   { id: \'#o\',\n     codeString: \'o.o = function() { return arguments[0]; };\',\n     uses: []\n   },\n   { id: \'#cv\',\n     codeString: \'o.cv = function(n) { err(\\\'reassigning constant name \"\\\'+n+\\\'\"\\\'); };\',\n     uses: [\'#err\']\n   }\n ];\n');
resolver.set('./src/other/wcb.js', '  import {ETK_ADD, ETK_DIV, ETK_MIN, ETK_NUM, ETK_ID, ETK_COMMENT, ETK_NL} from \'./constants.js\';\n  import {NL} from \'./util.js\';\n\n\nfunction wcb_ADD_b(rawStr, tt) {\n  if (tt & ETK_ADD) this.bs();\n  else NL(tt) || this.os();\n}\n\nfunction wcb_DIV_b(rawStr, tt) {\n  if (tt & ETK_DIV) this.bs();\n  else NL(tt) || this.os();\n}\n\nfunction wcb_MIN_b(rawStr, tt) {\n  if (tt & ETK_MIN) this.bs();\n  else NL(tt) || this.os();\n}\n\nfunction wcb_ADD_u(rawStr, tt) {\n  if (tt & ETK_MIN) this.bs();\n}\n\nfunction wcb_intDotGuard(rawStr, tt) {\n  rawStr === \'.\' && this.bs();\n}\n\nfunction wcb_MIN_u(rawStr, tt) {\n  if (tt & ETK_MIN) this.bs();\n}\n\nfunction wcb_idNumGuard(rawStr, tt) {\n  if (tt & (ETK_NUM|ETK_ID)) this.bs();\n}\n\nfunction wcb_afterStmt(rawStr, tt) {\n  if (!NL(tt) || (tt & ETK_COMMENT))\n    this.l();\n}\n\nfunction wcb_afterLineComment(rawStr, tt) {\n  if (tt === ETK_NL)\n    return;\n  this.finishCurrentLine();\n}\n\nfunction wcb_afterNew(rawStr, tt) {\n  wcb_idNumGuard.call(this, rawStr, tt);\n}\n\nfunction wcb_afterElse(rawStr, tt) {\n  wcb_idNumGuard.call(this, rawStr, tt);\n}\n\nfunction wcb_startStmtList(rawStr, tt) {}\n\nfunction wcb_afterCase(rawStr, tt) {\n  wcb_idNumGuard.call(this, rawStr, tt);\n}\n\nfunction wcb_afterVar(rawStr, tt) {\n  wcb_idNumGuard.call(this, rawStr, tt);\n}\n\nfunction wcb_afterVDT(rawStr, tt) {\n  wcb_idNumGuard.call(this, rawStr, tt);\n}\n\n// NOTE: only register it after a return that has a non-null argument\nfunction wcb_afterRet(rawStr, tt) {\n  if (NL(tt)) {\n    this.os();\n\n    // use `w because `wtcl_raw alone is not handling spaces enqueued\n    var wl = this.wrapLimit;\n    this.wrapLimit = 0;\n    this.w(\'(\');\n    this.wrapLimit = wl;\n\n    this.guardArg.hasParen = true;\n    return; \n  }\n  var lineLen = this.curLine.length;\n  if (tt & (ETK_NUM|ETK_ID)) {\n    if (this.ol(1+rawStr.length) > 0) {\n      this.writeToCurrentLine_raw(\'(\');\n      this.guardArg.hasParen = true;\n      this.l();\n    }\n    else this.hs();\n    return;\n  }\n  if (this.ol(rawStr.length) > 0) {\n    if (this.ol(rawStr.length) > 0) {\n      this.writeToCurrentLine_raw(\'(\');\n      this.guardArg.hasParen = true;\n      this.l();\n    }\n    return;\n  }\n  this.os();\n}\n\nfunction wcb_wrap(rawStr, tt) {\n  if (tt & ETK_NL) return;\n  this.insertLineBreak(true);\n}\n\nfunction guard_simpleListener(rawStr, tt) {}\n\n export {wcb_ADD_b, wcb_DIV_b, wcb_MIN_b, wcb_ADD_u, wcb_intDotGuard, wcb_MIN_u, wcb_idNumGuard, wcb_afterStmt, wcb_afterLineComment, wcb_afterNew, wcb_afterElse, wcb_startStmtList, wcb_afterCase, wcb_afterVar, wcb_afterVDT, wcb_afterRet, wcb_wrap, guard_simpleListener};\n');
resolver.set('./src/other/jz.js', '\nvar defaultJZ = \'\\\nfunction er(str) { throw new Error(err) }\\n\\\nfunction tz(str) { er(\"\\\'\"+str+\"\\\' is in its tz\") }\\n\\\nfunction cv(str) { er(\"\\\'\"+str+\"\\\' is immutable\") }\\n\\\nfunction r(v) { if (v) er(\"returned without calling super constructor\") }\\n\\\nfunction n(b,l) {\\n\\\n  var str = \"new b(\", e = 0;\\n\\\n  while (e < l.length) {\\n\\\n    if (e) str += \",\";\\n\\\n    str += \"l[\"+e+\"]\";\\n\\\n    e++\\n\\\n  }\\n\\\n  return eval(str)\\n\\\n}\\n\\\nfunction c(c,l) { return c.apply(void 0, l) }\\n\\\nfunction ex(a,b) { return Math.pow(a,b) }\\n\\\nfunction obj() {\\n\\\n  var r = arguments[0], e = 1;\\n\\\n  while (e < arguments.length) {\\n\\\n    r[arguments[e]] = r[arguments[e+1]];\\n\\\n    e += 2\\n\\\n  }\\n\\\n  return r\\n\\\n}\\n\\\nfunction u(v) { return v === void 0 }\\n\\\nfunction cm(t,m,l) { return m.apply(t, l) }\\n\\\nfunction cr(o) { var mkr = (0,function() {}); mkr.prototype = o; return new mkr }\\n\\\nvar HAS = {}.hasOwnProperty;\\n\\\nfunction has(o,n) { return HAS.call(o,n) }\\n\\\nfunction cls() {\\n\\\n  var b = arguments[0], p;\\n\\\n  if (arguments.length === 2) {\\n\\\n    var h = arguments[1];\\n\\\n    b.prototype = p = cr(h.prototype);\\n\\\n    for (var name in h)\\n\\\n      if (has(h,name)) b[name] = h[name];\\n\\\n  } else \\n\\\n    p = b.prototype;\\n\\\n  p.constructor = b;\\n\\\n  return b;\\n\\\n}\\n\\\n\\n\\\nvar arrIter = function() {\\n\\\n function arrIter0(v) { this.v = v; this.i = 0; }\\n\\\n var e = arrIter0.prototype;\\n\\\n e.get = function() { return this.v[this.i++] };\\n\\\n e.end = function() { return this.v };\\n\\\n return function(v) { return new arrIter0(v); }\\n\\\n}();\\n\\\n\\n\\\nfunction arr() {}\\n\\\nfunction sp(){ }\\n\\\nfunction h(cls) {}\\n\\\n\'\n\n export {defaultJZ};\n');
resolver.set('./src/other/traverse.js', '  import {ASSERT} from \'./constants.js\';\n\nvar D = \'.\'.charCodeAt(0);\n\nvar S = \'/\'.charCodeAt(0);\n\nfunction cd(cur, to) {\n  var coords = {s: 0, e: 0};\n\n  while (getDirLeft(to, coords))\n    cur = joinDirWithSingle(cur, to.substring(coords.s, coords.e));\n\n  return cur;\n};\n\nfunction getDirLeft(to, coords) {\n  var s = coords.e;\n  if (s >= to.length)\n    return null;\n\n  var rootSlash = false, ch = to.charCodeAt(s);\n  if (ch === S) {\n    if (s > 0) s++;\n    else rootSlash = true;\n  }\n\n  var e = to.indexOf(\'/\', rootSlash ? s+1 : s);\n  if (e === -1)\n    e = to.length;\n\n  coords.s = s;\n  coords.e = e;\n\n  return coords;\n}\n\nfunction joinDirWithSingle(cur, l) {\n  if (l.length === 0 || l === \'.\')\n    return cur;\n  if (l.charCodeAt(0) === S)\n    return l;\n  if (l !== \'..\')\n    return cur.length ? cur + (cur === \'/\' ? l : \'/\' + l) : l;\n\n  ASSERT.call(this, cur.length, \'can not go above the start\');\n\n  var slash = cur.lastIndexOf(\'/\');\n//ASSERT.call(this, slash !== -1, \'can not go above [:\'+cur+\':]\');\n  \n  if (slash === -1)\n    return \"\";\n\n  if (cur.length === 1) {\n    ASSERT.call(this, cur.charCodeAt(0) === S, \'what?\');\n    ASSERT.call(this, false, \'can not go above base\');\n  }\n\n  if (slash === 0)\n    return \'/\';\n\n  cur = cur.substring(0, slash);\n  return cur;\n}\n\nfunction pathFor(str) {\n  var e = str.lastIndexOf(\'/\');\n  return e === 0 ? \'/\' : e === -1 ? \"\" : str.substring(0, e);\n}\n\nfunction tailFor(str) {\n  var e = str.lastIndexOf(\'/\');\n  return e === -1 ? str : e+1 >= str.length ? \"\" : str.substring(e+1);\n}\n\n export {D, S, cd, getDirLeft, joinDirWithSingle, pathFor, tailFor};\n');
resolver.set('./src/other/errt.js', '  import {CTX_TOP, CTX_PARAM, CTX_PAT, CTX_HAS_A_PARAM_ERR, CTX_HAS_AN_ASSIG_ERR, CTX_HAS_A_SIMPLE_ERR, CTX_NO_SIMPLE_ERR} from \'./constants.js\';\n  import {ERR_PIN, ERR_NONE_YET, ERR_P_SYN, ERR_A_SYN, ERR_S_SYN} from \'./error-constants.js\';\n\nfunction errt_top(ctx) {\n  return (ctx & CTX_TOP) === CTX_TOP;\n}\n\nfunction errt_pin(err) {\n  return err & ERR_PIN;\n}\n\nfunction errt_noLeak(ctx) {\n  return errt_top(ctx);\n}\n\nfunction errt_perr(ctx, err) {\n  return errt_param(ctx) && err !== ERR_NONE_YET;\n}\n\nfunction errt_param(ctx) {\n  return ctx & CTX_PARAM;\n}\n\nfunction errt_aerr(ctx, err) {\n  return errt_pat(ctx) && err !== ERR_NONE_YET;\n}\n\nfunction errt_pat(ctx) {\n  return ctx & CTX_PAT;\n}\n\nfunction errt_serr(ctx, err) {\n  return errt_pat(ctx) && err !== ERR_NONE_YET;\n}\n\nfunction errt_ptrack(ctx) {\n  return errt_param(ctx) && !(ctx & CTX_HAS_A_PARAM_ERR);\n}\n\nfunction errt_atrack(ctx) {\n  return errt_pat(ctx) && !(ctx & CTX_HAS_AN_ASSIG_ERR);\n}\n\nfunction errt_strack(ctx) {\n  return errt_pat(ctx) && !(ctx & CTX_HAS_A_SIMPLE_ERR);\n}\n\nfunction errt_elem_ctx_of(ctx) {\n  return errt_pat(ctx) ?\n    ctx & (\n      CTX_HAS_A_PARAM_ERR|\n      CTX_HAS_AN_ASSIG_ERR|\n      CTX_HAS_A_SIMPLE_ERR|\n      CTX_PARAM|CTX_PAT\n    ) : CTX_PAT|CTX_NO_SIMPLE_ERR;\n}\n\nfunction errt_track(ctx) {\n  return errt_pat(ctx) || errt_param(ctx);\n}\n\nfunction errt_psyn(err) { return err & ERR_P_SYN; }\nfunction errt_asyn(err) { return err & ERR_A_SYN; }\nfunction errt_ssyn(err) { return err & ERR_S_SYN; }\n\n export {errt_top, errt_pin, errt_noLeak, errt_perr, errt_param, errt_aerr, errt_pat, errt_serr, errt_ptrack, errt_atrack, errt_strack, errt_elem_ctx_of, errt_track, errt_psyn, errt_asyn, errt_ssyn};\n');
resolver.set('./src/other/ref-cat.js', '  import {RS_ARGUMENTS, RS_SCALL, RS_THIS} from \'./scope-constants.js\';\n\nfunction ref_arguments_m(mname) {\n  return mname === RS_ARGUMENTS;\n}\n\nfunction ref_scall_m(mname) {\n  return mname === RS_SCALL;\n}\n\nfunction ref_this_m(mname) {\n  return mname === RS_THIS;\n}\n\n export {ref_arguments_m, ref_scall_m, ref_this_m};\n');
resolver.set('./src/other/renamer.js', '  import {iskw} from \'./util.js\';\n\nfunction renamer_incremental(base, i) {\n  if (i === 0) return base;\n  return base + \"\" + i;\n}\n\nvar HEAD = \'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$\', TAIL = HEAD + \'1234567890\',\n    HEADLEN = HEAD.length, TAILLEN = TAIL.length;\n\n// naive minified names -- true minified names are shortest for the most used name, and longerst for the least used name\nfunction renamer_minify(base, i) {\n  if (base.length === 1 && i === 0)\n    return base;\n  var tail = false, name = \"\";\n\n  while (true) {\n    do {\n      var m = -1;\n      if (tail) { m = i % TAILLEN; name += TAIL.charAt(m); i =  (i-m)/TAILLEN; }\n      else { m = i % HEADLEN; name += HEAD.charAt(m); i = (i-m)/HEADLEN; }\n    } while (i > 0);\n    if (iskw(name)) { name = \"\"; i++; continue; }\n    break;\n  }\n\n  return name;\n}\n\n export {renamer_incremental, HEAD, TAIL, HEADLEN, TAILLEN, renamer_minify};\n');
resolver.set('./src/other/class-extends.js', '  import Scope from \'../Scope/cls.js\';\n  import {createObj} from \'./util.js\';\n  import Actix from \'../Actix/cls.js\';\n  import ConcreteScope from \'../ConcreteScope/cls.js\';\n  import GlobalScope from \'../GlobalScope/cls.js\';\n  import Decl from \'../Decl/cls.js\';\n  import FunScope from \'../FunScope/cls.js\';\n  import ModuleScope from \'../ModuleScope/cls.js\';\n  import ClassScope from \'../ClassScope/cls.js\';\n  import CatchScope from \'../CatchScope/cls.js\';\n  import ParenScope from \'../ParenScope/cls.js\';\n  import ScopeName from \'../ScopeName/cls.js\';\n  import Liquid from \'../Liquid/cls.js\';\n  import SourceScope from \'../SourceScope/cls.js\';\n  import BundleScope from \'../BundleScope/cls.js\';\n  import VirtualResourceResolver from \'../VirtualResourceResolver/cls.js\';\n  import ResourceResolver from \'../ResourceResolver/cls.js\';\n\n//Scope.prototype = createObj(Actix.prototype);\n//ConcreteScope.prototype = createObj(Scope.prototype);\n//GlobalScope.prototype = createObj(ConcreteScope.prototype);\n//  Decl.prototype = createObj(Actix.prototype);\n  FunScope.prototype = createObj(ConcreteScope.prototype);\n//ModuleScope.prototype = createObj(ConcreteScope.prototype);\n//ClassScope.prototype = createObj(Scope.prototype);\n//CatchScope.prototype = createObj(Scope.prototype);\n//ParenScope.prototype = createObj(Scope.prototype);\n//ScopeName.prototype = createObj(Decl.prototype);\n//Liquid.prototype = createObj(Decl.prototype);\n//SourceScope.prototype = createObj(ConcreteScope.prototype);\n//BundleScope.prototype = createObj(ConcreteScope.prototype);\n//VirtualResourceResolver.prototype = createObj(ResourceResolver.prototype);\n\n');
resolver.set('./src/other/regex-util.js', '  import {ASSERT} from \'./constants.js\';\n\nfunction isSurroComp(n) {\n  return n.type === \'#Regex.SurrogateComponent\';\n}\n\nfunction isLead(n) {\n  return isSurroComp(n) && n.kind === \'lead\' ;\n}\n\nfunction isTrail(n) {\n  return isSurroComp(n) && n.kind === \'trail\';\n}\n\nfunction uAkin(a,b) {\n  ASSERT.call(this, isSurroComp(a), \'a\');\n  ASSERT.call(this, isSurroComp(b), \'b\');\n  return a.escape === b.escape;\n}\n\n export {isSurroComp, isLead, isTrail, uAkin};\n');
resolver.set('./src/other/ctype.js', '  import {CH_0, CH_9, CH_z, CH_a, CH_Z, CH_A, CH_UNDERLINE, CH_$, CH_f, CH_F} from \'./constants.js\';\n  import {D_INTBITLEN, M_INTBITLEN} from \'./int-constants.js\';\n  import {IDS_, IDC_} from \'./unicode.js\';\n\nfunction isNum(c) {\n  return (c >= CH_0 && c <= CH_9);\n}\n\nfunction isIDHead(c) {\n  return (\n    (c <= CH_z && c >= CH_a) ||\n    (c <= CH_Z && c >= CH_A) ||\n    c === CH_UNDERLINE ||\n    c === CH_$ ||\n    (IDS_[c >> D_INTBITLEN] & (1 << (c & M_INTBITLEN)))\n  );\n}\n\nfunction isIDBody (c) {\n  return (\n    (c <= CH_z && c >= CH_a) ||\n    (c <= CH_Z && c >= CH_A) ||\n    (c <= CH_9 && c >= CH_0) ||\n    c === CH_UNDERLINE ||\n    c === CH_$ ||\n    (IDC_[c >> D_INTBITLEN] & (1 << (c & M_INTBITLEN))) \n  );\n}\n\nfunction isHex(e) {\n  return (\n    (e >= CH_a && e <= CH_f) ||\n    (e >= CH_0 && e <= CH_9) ||\n    (e >= CH_A && e <= CH_F)\n  );\n}\n\n export {isNum, isIDHead, isIDBody, isHex};\n');
resolver.set('./src/Decl/core.js', '  import {ASSERT_EQ, HAS, ASSERT} from \'../other/constants.js\';\n  import {DT_NONE} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.s =\nfunction(s) {\n  ASSERT_EQ.call(this, this.site, null);\n  this.site = s;\n  return this;\n};\n\ncls.r =\nfunction(r) {\n  ASSERT_EQ.call(this, this.ref, null);\n  ASSERT_EQ.call(this, r.targetDecl_nearest, null);\n  ASSERT_EQ.call(this, r.hasTarget, false);\n  this.ref = r;\n  r.targetDecl_nearest = this;\n  r.hasTarget = true;\n  return this;\n};\n\ncls.n =\nfunction(n) {\n  ASSERT_EQ.call(this, this.name, \"\");\n  this.name = n;\n  return this;\n};\n\ncls.t =\nfunction(t) {\n  ASSERT_EQ.call(this, this.type, DT_NONE);\n  this.type = t;\n  return this;\n};\n\ncls.activateTZ =\nfunction() {\n  if (this.hasTZCheck)\n    return false;\n  this.hasTZCheck = true;\n  this.ref.scope.activateTZ();\n  return true;\n};\n\ncls.isReached =\nfunction() {\n  return this.reached && this.reached.v;\n};\n\ncls.refreshRSListWithList =\nfunction(list) {\n  var l = 0;\n  while (l < list.length)\n    this.refreshRSListWith(list[l++]);\n};\n\ncls.refreshRSListWith =\nfunction(scope) {\n  if (this.rsMap === null)\n    this.rsMap = {};\n  var id = scope.scopeID;\n  if (HAS.call(this.rsMap, id)) {\n    ASSERT.call(this, this.rsMap[id] === scope, \'scope\' );\n    return false;\n  }\n  this.rsMap[id] = scope ;\n  this.ref.rsList.push(scope);\n  return true;\n};\n\ncls.getDecl_real =\nfunction() {\n  if (this.realTarget !== null)\n    return this.realTarget;\n\n  var t = this;\n  while (t.ref.parentRef !== null)\n    t = t.ref.parentRef.getDecl_nearest();\n\n  this.realTarget = t;\n  return t;\n};\n\n\n');
resolver.set('./src/Decl/chk-needs-synth.js', '  import {ATS_DISTINCT} from \'../other/scope-constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.mustSynth =\nfunction() {\n  if (this.msynth !== -1)\n    return this.msynth;\n\n  var list = this.ref.rsList, e = 0, scope = null, msynth = 0;\n  while (e < list.length) {\n    scope = list[e++ ];\n    if (scope.isAnyFn() && scope.scopeName) {\n      var sn = scope.scopeName;\n      if (sn.getAS() !== ATS_DISTINCT)\n        sn = sn.source;\n      if (this.name === sn.name && this !== sn) {\n        msynth = 1;\n        break;\n      }\n    }\n  }\n\n  if (msynth === 0) {\n    var mname = _m(this.name);\n    e = 0;\n    while (e < list.length)\n      list[e++].insertSynth_m(mname, this);\n  }\n\n  return this.msynth = msynth;\n};\n\n\n');
resolver.set('./src/Decl/whole.js', '  import \'./core.js\';\n  import \'./chk-needs-synth.js\';\n  import \'./is.js\';\n');
resolver.set('./src/Decl/is.js', '  import {DT_LET, DT_VAR, DT_CONST, DT_GLOBAL, DT_FN, DT_FNARG, DT_CLS, DT_CATCHARG, DT_LIQUID, DT_IDEFAULT, DT_IALIASED, DT_INAMESPACE, DT_EDEFAULT, DT_EALIASED, DT_ESELF, DT_FNNAME, DT_CLSNAME, DT_INFERRED} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.isLet =\nfunction() { return this.type & DT_LET; };\n\ncls.isVar =\nfunction() { return this.type & DT_VAR; };\n\ncls.isConst =\nfunction() { return this.type & DT_CONST; };\n\ncls.isGlobal =\nfunction() { return this.type & DT_GLOBAL; };\n\ncls.isFn =\nfunction() { return this.type & DT_FN; };\n\ncls.isFnArg =\nfunction() { return this.type & DT_FNARG; };\n\ncls.isCls =\nfunction() { return this.type & DT_CLS; };\n\ncls.isCatchArg =\nfunction() { return this.type & DT_CATCHARG; };\n\ncls.isTemporal =\nfunction() {\n  if (this.isFnArg())\n    return !this.ref.scope.inBody;\n  if (this.isCatchArg())\n    return !this.ref.scope.inBody;\n  if (this.isFn())\n    return false;\n\n  return this.isCls() || this.isClassName() || this.isLexicalLike();\n};\n\ncls.isLLINOSA =\nfunction() {\n  return this.isLexicalLike() &&\n    this.ref.scope.insideLoop() &&\n    this.ref.i;\n};\n\ncls.isLiquid =\nfunction() { return this.type & DT_LIQUID; };\n\nvar _HOISTED = DT_FN|DT_VAR;\ncls.isHoisted =\nfunction() { return this.type & _HOISTED; };\n\nvar _ARG = DT_FNARG|DT_CATCHARG;\ncls.isArg =\nfunction() { return this.type & _ARG; };\n\nvar _LEXICAL = DT_CLS|DT_LET|DT_CONST;\ncls.isLexicalLike =\nfunction() {\n  if (this.isFn())\n    return this.ref.scope.isLexicalLike();\n  return this.type & _LEXICAL;\n};\n\n// TODO: CATCHARG\nvar _VARLIKE = DT_FNARG|DT_VAR;\ncls.isVarLike =\nfunction() {\n  if (this.isFn())\n    return !this.ref.scope.isLexicalLike();\n  return this.type & _VARLIKE;\n};\n\nvar _OVERRIDABLE = DT_CATCHARG|_VARLIKE;\ncls.isOverridableByVar =\nfunction() { return this.isVarLike() || (this.type & _OVERRIDABLE); };\n\ncls.isIDefault =\nfunction() { return this.type & DT_IDEFAULT; };\n\ncls.isIAliased =\nfunction() { return this.type & DT_IALIASED; };\n\ncls.isINamespace =\nfunction() { return this.type & DT_INAMESPACE; };\n\ncls.isImported =\nfunction() {\n  return this.isIDefault() || this.isIAliased() || this.isINamespace();\n};\n\ncls.isEDefault =\nfunction() { return this.type & DT_EDEFAULT; };\n\ncls.isEAliased =\nfunction() { return this.type & DT_EALIASED; };\n\ncls.isESelf =\nfunction() { return this.type & DT_ESELF; };\n\ncls.isExported =\nfunction() {\n  return this.isEDefault() || this.isEAliased() || this.isESelf();\n};\n\ncls.isFnName =\nfunction() { return this.type & DT_FNNAME; };\n\ncls.isClassName =\nfunction() { return this.type & DT_CLSNAME; };\n\ncls.isName =\nfunction() { return this.type & (DT_FNNAME|DT_CLSNAME); };\n\ncls.isInsignificant =\nfunction() { return this.type & DT_INFERRED; };\n\ncls.isImmutable =\nfunction() {\n  return this.isConst() || this.isName();\n};\n\n// renamed global\ncls.isRG =\nfunction() {\n  return this.isGlobal() && this.name !== this.synthName;\n};\n\n\n');
resolver.set('./src/Decl/cls.js', '  import Actix from \'../Actix/cls.js\';\n  import {ACT_DECL} from \'../other/constants.js\';\n  import {DT_NONE} from \'../other/scope-constants.js\';\n\nexport default function Decl() {\n  Actix.call(this, ACT_DECL );\n  this.ref = null;\n  this.idx = -1;\n  this.name = \"\";\n  this.site = null;\n  this.msynth = -1;\n  this.hasTZCheck = false;\n  this.reached = null;\n  this.type = DT_NONE;\n  this.synthName = \"\";\n  this.rsMap = null;\n  this.realTarget = null;\n}\n\n import {createObj} from \'../other/util.js\';\n export var cls = Decl.prototype = createObj(Actix.prototype);\n');
resolver.set('./src/ResourceResolver/new-core.js', '  import {HAS, ASSERT} from \'../other/constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\n// TODO: fetch nodes based on id\'s, such that, in case the uri\'s \'a/b\' and \'l/e\' both point to the same file on a disk, and we have only saved \'a/b\', this.get(\'l/e\') returns the \n// same node saved under \'a/b\' (by the way, this is more of a bundler\'s job than a resource loader\'s)\n\ncls.hasInCache =\nfunction(uri) {\n  return HAS.call(this.savedNodes, _m(uri));\n};\n\ncls.loadCached =\nfunction(uri) {\n  var mname = _m(uri);\n  return HAS.call(this.savedNodes, mname) ?\n    this.savedNodes[mname] : null;\n};\n\ncls.cache =\nfunction(uri, n) {\n  var mname = _m(uri);\n  ASSERT.call(this, !this.hasInCache(uri), \'existing\');\n  this.savedNodes[mname] = n;\n};\n\ncls.loadNew =\nfunction(uri) {\n  ASSERT.call(this, !this.hasInCache(uri), \'existing\');\n  return this.asNode(uri);\n};\n\n\n');
resolver.set('./src/ResourceResolver/whole.js', '  import \'./new-core.js\';\n');
resolver.set('./src/ResourceResolver/cls.js', '\nexport default function ResourceResolver() {\n  this.savedNodes = {}; \n  this.bundleScope = null;\n}\n\n export var cls = ResourceResolver.prototype;\n');
resolver.set('./src/GlobalScope/whole.js', '  import \'./sp.js\';\n  import \'./synth-names.js\';\n');
resolver.set('./src/GlobalScope/sp.js', '\n\n\n');
resolver.set('./src/GlobalScope/synth-names.js', '  import {cls} from \'./cls.js\';\n\n/* TODO: eliminate */ cls.synth_decl_find_homonym_m =\nfunction(mname) { return this.findSynth_m(mname); };\n\n\n');
resolver.set('./src/GlobalScope/cls.js', '  import ConcreteScope from \'../ConcreteScope/cls.js\';\n  import {ST_GLOBAL} from \'../other/scope-constants.js\';\n\nexport default function GlobalScope() {\n  ConcreteScope.call(this, null, ST_GLOBAL);  \n  this.scriptScope = null;\n}\n\n import {createObj} from \'../other/util.js\';\n export var cls = GlobalScope.prototype = createObj(ConcreteScope.prototype);\n');
resolver.set('./src/ErrorString/core.js', '  import {cls} from \'./cls.js\';\n\ncls.applyTo = function(obj) {\n  var errorMessage = \"\",\n      isString = true,\n      list = this.stringsAndTemplates,\n      e = 0;\n  while (e < list.length) {\n    errorMessage += isString ?\n      list[e] : list[e].applyTo(obj);\n    e++;\n    isString = !isString;\n  }\n  \n  return errorMessage;\n};\n\n\n\n');
resolver.set('./src/ErrorString/whole.js', '  import \'./core.js\';\n');
resolver.set('./src/ErrorString/cls.js', '  import {ASSERT, CH_RCURLY, CH_LCURLY} from \'../other/constants.js\';\n  import Template from \'../Template/cls.js\';\n\nexport default function ErrorString(stringsAndTemplates) {\n  this.stringsAndTemplates = stringsAndTemplates;\n}\n\nfunction eof_rcurly(str, i) {\n  if (i >= str.length)\n    ASSERT.call(this, false, \'reached eof before a }\');\n\n  return str.charCodeAt(i) === CH_RCURLY; \n}\n\nfunction readTemplate(str, i) {\n  if (str.charCodeAt(i) === CH_RCURLY)\n    return null;\n  return Template.from(str, i, eof_rcurly);\n}\n\nErrorString.from = function(str) {\n  var elem = \"\", i = 0, list = [];\n  while (i < str.length) {\n    if (str.charCodeAt(i) === CH_LCURLY) {\n      i++;\n      var template = readTemplate(str, i);\n      if (template === null)\n        elem += \'{\';\n      else {\n        list.push(elem);\n        list.push(template);\n        elem = \"\";\n        i += template.str.length;\n      }\n    }\n    else\n      elem += str.charAt(i);\n    \n    i++;\n  }\n  if (elem.length)\n    list.push(elem);\n\n  var error = new ErrorString(list);\n  error.str = str;\n\n  return error;\n};\n\n export var cls = ErrorString.prototype;\n');
resolver.set('./src/CatchScope/new-core.js', '  import {ASSERT} from \'../other/constants.js\';\n  import Liquid from \'../Liquid/cls.js\';\n  import SortedObj from \'../SortedObj/cls.js\';\n  import FunScope from \'../FunScope/cls.js\';\n  import ConcreteScope from \'../ConcreteScope/cls.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.synth_boot =\nfunction(r) {\n  ASSERT.call(this, !this.isBooted, \'boot\' );\n  if (this.renamer === null) this.renamer = r;\n  this.synth_boot_init();\n  if (this.argIsSignificant)\n    this.synth_rcv();\n  else\n    this.catchVar = new Liquid(\'catchname\').n(\'t\');\n  this.synth_defs_to(this.synthBase);\n};\n\ncls.synth_boot_init =\nfunction() {\n  ASSERT.call(this, !this.isBooted, \'boot\' );\n  if (this.synthNamesUntilNow === null)\n    this.synthNamesUntilNow = new SortedObj();\n  this.isBooted = true;\n};\n\ncls.synth_start =\nfunction(r) {\n  this.isBooted || this.synth_boot(r);\n\n  FunScope.prototype.synth_externals.call(this);\n};\n\ncls.synth_ref_may_escape_m =\nfunction(mname) { return true; };\n\ncls.insertSynth_m = \nfunction(mname, synth) {\n  return ConcreteScope.prototype.insertSynth_m.call(this, mname, synth);\n};\n\ncls.rename =\nfunction(base, n) { return ConcreteScope.prototype.rename.call(this, base, n); };\n\ncls.synth_ref_find_homonym_m =\nfunction(mname, r) {\n  this.isBooted || this.synth_boot(r);\n  return this.findSynth_m(mname);\n};\n\ncls.findSynth_m =\nfunction(mname) {\n  return ConcreteScope.prototype.findSynth_m.call(this, mname);\n};\n\ncls.synth_rcv =\nfunction() {\n  var c = this.defs.at(0), list = c.ref.rsList, num = 0;\n  ASSERT.call(this, c.isCatchArg(), \'catch\' );\n  var baseName = c.name, synthName = this.rename(baseName, num);\n\n  this.catchVar = c;\n\n  RENAME:\n  do {\n    var mname = _m(synthName);\n    var synth = null;\n    var l = 0;\n    while (l < list.length) {\n      var scope = list[l++];\n      if (!scope.synth_ref_may_escape_m(mname, this.renamer))\n        continue RENAME;\n      synth = scope.synth_ref_find_homonym_m(mname, this.renamer);\n      if (synth && synth !== c)\n        continue RENAME;\n    }\n    break;\n  } while (synthName = this.rename(baseName, ++num), true );\n\n  c.synthName = synthName;\n  this.insertSynth_m(mname, c);\n};\n\ncls.synth_lcv =\nfunction() {\n  var liq = this.catchVar;\n  var baseName = liq.name;\n  var num = 0;\n\n  var mname = 0, synthName = this.rename(baseName, num);\n  do {\n    mname = _m(synthName);\n    if (this.findSynth_m(mname) === null)\n      break;\n    synthName = this.rename(baseName, ++num);\n  } while (true);\n\n  liq.synthName = synthName;\n  this.insertSynth_m(mname, liq);\n};\n\n\n');
resolver.set('./src/CatchScope/whole.js', '  import \'./new-core.js\';\n');
resolver.set('./src/CatchScope/cls.js', '  import Scope from \'../Scope/cls.js\';\n  import {ST_CATCH} from \'../other/scope-constants.js\';\n  import SortedObj from \'../SortedObj/cls.js\';\n\nexport default function CatchScope(sParent) {\n  Scope.call(this, sParent, ST_CATCH);\n\n  this.args = new SortedObj();\n  this.argRefs = new SortedObj();\n  this.argIsSimple = false;\n  this.argIsSignificant = false;\n  this.inBody = false;\n  this.bodyRefs = new SortedObj();\n\n  this.refs = this.argRefs;\n\n  this.catchVar = null;\n  this.isBooted = false;\n  \n  this.synthNamesUntilNow = null;\n  this.renamer = null;\n}\n\n import {createObj} from \'../other/util.js\';\n export var cls = CatchScope.prototype = createObj(Scope.prototype);\n');
resolver.set('./src/Ref/new-core.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.absorbDirect =\nfunction(ref) { return this.absorb(ref, true); };\n\ncls.absorbIndirect =\nfunction(ref) { return this.absorb(ref, false); };\n\ncls.absorb =\nfunction(childRef, refD) {\n  ASSERT.call(this, !childRef.hasTarget,\n    \'resolved ref are not allowed to get absorbed by another ref\');\n  ASSERT.call(this, !childRef.parentRef,\n    \'a ref with a parent is not allowed to get absorbed by another ref\');\n\n  if (refD) {\n    this.d += childRef.d;\n    this.i += childRef.i;\n  } else\n    this.i += childRef.d + childRef.i\n\n  if (childRef.rsList.length)\n    this.rsList = childRef.rsList.concat(this.rsList);\n\n  if (childRef.scope.hasSignificantNames())\n    this.rsList.push(childRef.scope);\n\n  childRef.parentRef = this;\n};\n\ncls.updateStats =\nfunction(d, i) { this.d += d; this.i += i; };\n\ncls.getDecl_nearest =\nfunction() {\n  if (this.targetDecl_nearest !== null)\n    return this.targetDecl_nearest;\n  var ref = this.parentRef;\n  while (ref) {\n    if (ref.targetDecl_nearest)\n      return this.targetDecl_nearest = ref.targetDecl_nearest;\n    ref = ref.parentRef;\n  }\n\n  ASSERT.call(this, false, \'ref unresolved\');\n};\n\ncls.getDecl_real =\nfunction() {\n  return this.getDecl_nearest().getDecl_real();\n};\n\ncls.assigned =\nfunction() {\n  // TODO: assert target ref is not a relocated ref (i.e., it is a master decl)\n  var targetRef = this.getDecl_nearest().ref;\n  if (targetRef.lhs < 0)\n    targetRef.lhs = 0;\n  return targetRef.lhs++;\n};\n\n\n');
resolver.set('./src/Ref/whole.js', '  import \'./new-core.js\';\n');
resolver.set('./src/Ref/cls.js', '\nexport default function Ref(scope) {\n  this.i = 0;\n  this.rsList = [];\n  this.scope = scope || null;\n  this.d = 0;\n  this.targetDecl_nearest = null;\n  this.hasTarget = false;\n  this.parentRef = null;\n  this.lhs = 0;\n}\n\n export var cls = Ref.prototype;\n');
resolver.set('./src/ScopeName/new-core.js', '  import {_m} from \'../other/scope-util.js\';\n  import {ATS_DISTINCT, ATS_UNSURE, ATS_SAME} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.hasName_m =\nfunction(mname) {\n  return _m(this.name) === mname;\n};\n\n// attachment state:\n// src null or not an fn decl -> unattached\n// otherwise:\n//   src lexical-like -> unattached\n//   otherwise:\n//     src has no synthName -> uncertain\n//     otherwise:\n//       src has non-matching synthName -> unattached\n//       otherwise -> attached\ncls.getAS =\nfunction() {\n  var src = this.source;\n  if (src === null || src.isLexicalLike())\n    return ATS_DISTINCT;\n  if (src.synthName === \"\")\n    return ATS_UNSURE; // semi-attached\n  if (src.synthName === src.name)\n    return ATS_SAME;\n  return ATS_DISTINCT;\n};\n\n\n');
resolver.set('./src/ScopeName/whole.js', '  import \'./new-core.js\';\n');
resolver.set('./src/ScopeName/cls.js', '  import Decl from \'../Decl/cls.js\';\n\nexport default function ScopeName(name, src) {\n  Decl.call(this);\n\n  this.name = name;\n  this.source = src;\n}\n\n import {createObj} from \'../other/util.js\';\n export var cls = ScopeName.prototype = createObj(Decl.prototype);\n');
resolver.set('./src/goal.js', '  import \'./Actix/whole.js\';\n  import \'./AutoImex/whole.js\';\n  import \'./Bundler/whole.js\';\n  import \'./BundleScope/whole.js\';\n  import \'./CatchScope/whole.js\';\n  import \'./ClassScope/whole.js\';\n  import \'./Comments/whole.js\';\n  import \'./ConcreteScope/whole.js\';\n  import \'./Decl/whole.js\';\n  import \'./Emitter/whole.js\';\n  import \'./ErrorString/whole.js\';\n  import \'./FunScope/whole.js\';\n  import \'./GlobalScope/whole.js\';\n  import \'./LiquidGroup/whole.js\';\n  import \'./Liquid/whole.js\';\n  import \'./ParenScope/whole.js\';\n  import \'./Parser/whole.js\';\n  import \'./PathMan/whole.js\';\n  import \'./Ref/whole.js\';\n  import \'./ResourceResolver/whole.js\';\n  import \'./ScopeName/whole.js\';\n  import \'./Scope/whole.js\';\n  import \'./SortedObj/whole.js\';\n  import \'./SourceScope/whole.js\';\n  import \'./Template/whole.js\';\n  import \'./Transformer/whole.js\';\n  import \'./VirtualResourceResolver/whole.js\';\n\n  import Parser from \'./Parser/cls.js\';\n  import Emitter from \'./Emitter/cls.js\';\n  import Transformer from \'./Transformer/cls.js\';\n  import PathMan from \'./PathMan/cls.js\';\n  import AutoImex from \'./AutoImex/cls.js\';\n  import VirtualResourceResolver from \'./VirtualResourceResolver/cls.js\';\n  import Bundler from \'./Bundler/cls.js\';\n  import {renamer_incremental, renamer_minify} from \'./other/renamer.js\';\n  import ResourceResolver from \'./ResourceResolver/cls.js\';\n  import FileResourceResolver, {normalize} from \'./FileResourceResolver/cls.js\';\n  import JZMap from \'./JZMap/cls.js\';\n\n  import {HAS, ASSERT} from \'./other/constants.js\';\n\n(function(global, exporter) {\n  if (typeof exports === \'object\' && typeof module !== \'undefined\')\n    exporter(exports);\n  else if (typeof define === \'function\' && define.amd)\n    define([\'exports\'], exporter);\n  else\n    exporter(global.jazzle = global.jazzle || {});\n})(this, function exporter(exports) { \n\n  exports.parse = function(src, isModule ) {\n    var newp = new Parser(src, isModule);\n    return newp.parseProgram();\n  };\n\n  exports.Parser = Parser;  \n  exports.Emitter = Emitter;\n  exports.Transformer = Transformer;\n  exports.PathMan = PathMan;\n  exports.AutoImex = AutoImex;\n  exports.VirtualResourceResolver = VirtualResourceResolver;\n  exports.Bundler = Bundler;\n  exports.ResourceResolver = ResourceResolver;\n  exports.FileResourceResolver = FileResourceResolver;\n  exports.renamer_incremental = renamer_incremental;\n  exports.renamer_minify = renamer_minify;\n\n  exports.JZMap = JZMap;\n\n  exports.transform =\n  function transform(src, options) {\n    var isScript = true, v = null;\n    if (!options) options = {};\n\n    if (HAS.call(options, \'sourceType\')) {\n      switch (v = options.sourceType) {\n      case \'module\':\n        isScript = false;\n        break;\n      case \'script\':\n        isScript = true;\n        break;\n      default:\n        throw new Error(\n          \'Unknown value for \"sourceType\": (\'+v+\')\'\n        );\n      }\n    }\n\n    var minify = false;\n    if (HAS.call(options, \'minify\')) {\n      v = options.minify;\n      if (v === true || v === false)\n        minify = v;\n      else throw new Error(\n        \'Unknown value for \"minify\": (\'+v+\')\'\n      );\n    }\n\n    var bundleAll = false;\n    var rootUri = \"\", resolver = null;\n    if (HAS.call(options, \'bundle\')) {\n      v = options.bundle;\n      if (v === true || v === false)\n        bundleAll = v;\n      else throw new Error(\n        \'Unknown value for \"bundle\": (\'+v+\')\'\n      );\n    }\n\n    if (bundleAll) {\n      ASSERT.call(\n        this, \n        HAS.call(options, \'rootUri\') &&\n        options.rootUri && options.rootUri !== \"\",\n        \'bundling requested but no \"rootUri\" found in the provided options\'\n      );\n      rootUri = options.rootUri;\n\n      ASSERT.call(\n        this, \n        HAS.call(options, \'resolver\') && options.resolver,\n        \'bundling requested but no \"resolver\" found in the provided options\'\n      );\n      resolver = options.resolver;\n    }\n\n    var pathMan = null, bundler = null;\n    if (bundleAll) {\n      pathMan = new PathMan();\n      bundler = new Bundler(pathMan);\n      bundler.resolver = resolver;\n      var rootHead = pathMan.head(rootUri);\n      bundler.setURIAndDir(rootUri, rootHead);\n      resolver.bundleScope = bundler.bundleScope;\n    }\n\n    var parser = new Parser(src, {sourceType: isScript ? \'script\' : \'module\'});\n\n    if (bundler) {\n      parser.bundler = bundler;\n      parser.bundleScope = bundler.bundleScope;\n    }\n\n    var rootNode = parser.parseProgram();\n\n    var transformer = new Transformer();\n    if (minify)\n      transformer.renamer = renamer_minify;\n\n    var transformedNode = null;\n    if (bundler) {\n      bundler.rootNode = rootNode;\n      transformedNode = transformer.tr(bundler, false);\n    }\n    else\n      transformedNode = transformer.tr(rootNode, false);\n\n    var emitter = new Emitter();\n\n    if (minify) {\n      var a = emitter.allow;\n      a.space = a.nl = a.comments.l = a.comments.m = false;\n    }\n\n    emitter.allow.jzWrapper = true;\n\n    emitter.start();\n    emitter.emitStmt(transformedNode);\n    emitter.flushAll();\n\n    return {\n      code: emitter.out,\n      sourceMap: emitter.sm\n    };\n  };\n  exports.normalize = normalize ;\n});\n');
resolver.set('./src/Scope/new-var-target.js', '  import {ASSERT, HAS} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.addVarTarget_m =\nfunction(mname, newDecl) {\n  ASSERT.call(this, !HAS.call(this.varTargets, mname),\n    \'var target is not unique: <\'+mname+\'>\');\n  this.varTargets[mname] = newDecl;\n};\n\ncls.findVarTarget_m =\nfunction(mname) {\n  return this.varTargets[mname];\n};\n\n\n');
resolver.set('./src/Scope/new-core.js', '  import {SA_NONE, SA_RETURN, SA_CALLSUPER, SA_NEW_TARGET, SA_MEMSUPER, SA_YIELD, SA_AWAIT, SF_NONE, SF_STRICT, SF_LOOP, SF_UNIQUE} from \'../other/scope-constants.js\';\n  import {ASSERT, ASSERT_EQ} from \'../other/constants.js\';\n  import ScopeName from \'../ScopeName/cls.js\';\n  import Ref from \'../Ref/cls.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import Liquid from \'../Liquid/cls.js\';\n  import {cls} from \'./cls.js\';\n\ncls.determineActions =\nfunction() {\n  if (this.isParen())\n    return this.parent.actions;\n\n  var a = SA_NONE;\n  if (this.isSoft())\n    a |= this.parent.actions;\n  else if (this.isAnyFn()) {\n    a |= SA_RETURN;\n    if (this.isArrow())\n      a |= (this.parent.actions & (SA_CALLSUPER|SA_NEW_TARGET|SA_MEMSUPER));\n    else {\n      a |= SA_NEW_TARGET;\n      if (this.isCtor()) {\n        ASSERT.call(this, this.parent.isClass(),\n          \'a ctor can only descend from a class\');\n        if (this.parent.hasHeritage())\n          a |= SA_CALLSUPER;\n      }\n      if (this.isGen())\n        a |= SA_YIELD;\n      if (this.isMem())\n        a |= SA_MEMSUPER;\n    }\n    if (this.isAsync())\n      a |= SA_AWAIT;\n  }\n\n  return a;\n};\n\ncls.activateTZ =\nfunction() {\n  var scope = this.scs;\n  if (scope.hasTZCheckPoint)\n    return false;\n  return this.hasTZCheckPoint = true;\n};\n\ncls.setName =\nfunction(name, source) {\n  ASSERT.call(this, this.canHaveName(),\n    \'only cls/fn can have a name\');\n  ASSERT_EQ.call(this, this.scopeName, null);\n  this.scopeName = \n    new ScopeName(name, source).r(new Ref(this));\n\n  return this.scopeName;\n};\n\ncls.getThisBase =\nfunction() { return this.scs; };\n\ncls.pushFun =\nfunction(name, transformedFn) {\n  ASSERT.call(\n    this,\n    transformedFn.type === \'#Untransformed\' && transformedFn.kind === \'transformed-fn\', \'transformed-fn\');\n  var mname = _m(name);\n  var list = this.funLists.has(mname) ?\n    this.funLists.get(mname) :\n    this.funLists.set(mname, []);\n  list.push(transformedFn);\n};\n\ncls.owns =\nfunction(nd) {\n  return nd.ref.scope === this /* && (!nd.isImported()) */;\n};\n\ncls.determineFlags =\nfunction() {\n  if (this.isParen())\n    return this.parent.flags;\n\n  var fl = SF_NONE;\n  if (!this.parent) {\n    ASSERT.call(this, this.isGlobal() || this.isBundle(),\n      \'global scope is the only scope that \' +\n      \'can have a null parent\');\n    return fl;\n  }\n\n  if (this.isClass() || this.isModule() ||\n    this.parent.insideStrict())\n    fl |= SF_STRICT;\n\n  if (!this.isAnyFn() && this.parent.insideLoop())\n    fl |= SF_LOOP;\n\n  if (this.isAnyFn() && !this.isSimpleFn())\n    fl |= SF_UNIQUE;\n\n  return fl;\n};\n\ncls.spCreate_this =\nfunction(ref) {\n  ASSERT.call(this, this.canMakeThis(), \'this\');\n\n  if (!ref)\n    ref = new Ref(this);\n\n  ASSERT.call(this, this.spThis === null,\n    \'this scope has already got a this liquid\');\n\n  // TODO: tz check is also needed for \'this\' (in some cases)\n  var spThis = new Liquid(\'<this>\')\n    .r(ref)\n    .n(\'this_\');\n\n  return this.spThis = spThis;\n};\n\ncls.setSynthBase =\nfunction(base) {\n  ASSERT.call(this, this.synthBase === this.scs, \'synth-base is not intact\');\n  ASSERT.call(this, base.isConcrete(), \'base\' );\n  this.synthBase = base;\n};\n\ncls.getSourceLevelScope =\nfunction() {\n  var l = this.sourceScope ; // up\n  if (l === null) {\n    var u = this.parent;\n    while (u) {\n      if (u.isSourceLevel()) {\n        l = this.sourceScope = u;\n        break;\n      }\n    }\n    ASSERT.call(this, u, \'source-scope \' );\n  }\n  return l;\n};\n\n\n');
resolver.set('./src/Scope/whole.js', '  import \'./new-var-target.js\';\n  import \'./new-core.js\';\n  import \'./hand-over.js\';\n  import \'./finish.js\';\n  import \'./is.js\';\n  import \'./synth-names.js\';\n  import \'./head.js\';\n  import \'./strict.js\';\n  import \'./ref.js\';\n  import \'./has.js\';\n  import \'./enter-exit.js\';\n  import \'./can.js\';\n  import \'./new-decl.js\';\n  import \'./inside.js\';\n  import \'./global.js\';\n  import \'./spawn.js\';\n');
resolver.set('./src/Scope/hand-over.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {ref_this_m} from \'../other/ref-cat.js\';\n  import {cls} from \'./cls.js\';\n\ncls.handOverRefList =\nfunction(list) {\n  var len = list.length(), i = 0;\n  while (i<len) {\n    var ref = list.at(i), mname = list.keys[i];\n    if (ref && (ref.d || ref.i)) {\n      ASSERT.call(this, !ref.hasTarget, \'touched ref can not be bound\');\n      this.handOver_m(mname, ref);\n    }\n    i++;\n  }\n};\n\ncls.handOver_m =\nfunction(mname, ref) {\n  if (this.isBlock() || this.isBare())\n    return this.parent.refDirect_m(mname, ref);\n\n  if (this.isCatch()) {\n    ASSERT.call(this, !this.inBody,\n      \'the body has to finish() before the handover begins\');\n    return this.parent.refDirect_m(mname, ref);\n  }\n\n  if (this.isClass()) {\n    if (this.isExpr() &&\n    this.scopeName && this.scopeName.hasName_m(mname))\n      return this.scopeName.ref.absorbDirect(ref);\n\n    return this.parent.refDirect_m(mname, ref);\n  }\n\n  ASSERT.call(this, this.isSourceLevel(),\n    \'a script scope was expected\');\n\n  ASSERT.call(this, this.parent.isGlobal() || this.parent.isBundle(),\n    \'script must have a parent scope with type global\');\n\n  if (ref_this_m(mname))\n    return this.spCreate_this(ref);\n\n  return this.parent.spReportGlobal_m(mname, ref);\n};\n\n\n');
resolver.set('./src/Scope/finish.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.finish =\nfunction() {\n  if (this.isAnyFn() || this.isCatch())\n    this.finishBody();\n\n  return this.handOverRefList(this.refs);\n};\n\ncls.finishBody =\nfunction() {\n  ASSERT.call(this, this.inBody, \'finish must be in body\');\n  var list = this.refs, len = list.length();\n  var e = 0, mname = \"\", ref = null;\n\n  var isCatch = this.isCatch();\n  this.deactivateBody();\n  this.inBody = true;\n  while (e<len) {\n    ref = list.at(e);\n    mname = list.keys[e];\n    if (ref && (ref.d || ref.i)) {\n      if (isCatch)\n        this.refDirect_m(mname, ref);\n      else\n        this.refInHead(mname, ref);\n    }\n    e++;\n  }\n  this.inBody = false;\n};\n\n\n');
resolver.set('./src/Scope/is.js', '  import {ST_FN, ST_CATCH, ST_SCRIPT, ST_MODULE, ST_CLS, ST_GEN, ST_ASYNC, ST_GETTER, ST_SETTER, ST_CLSMEM, ST_STATICMEM, ST_OBJMEM, ST_ARROW, ST_BLOCK, ST_BARE, ST_CTOR, ST_DECL, ST_PAREN, ST_EXPR, ST_BUNDLE, ST_GLOBAL} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.isAnyFn = \nfunction() { return this.type & ST_FN; };\n\ncls.isCatch = \nfunction() { return this.type & ST_CATCH; };\n\ncls.isScript = \nfunction() { return this.type & ST_SCRIPT; };\n\ncls.isModule = \nfunction() { return this.type & ST_MODULE; };\n\ncls.isClass = \nfunction() { return this.type & ST_CLS; };\n\ncls.isGen = \nfunction() { return this.type & ST_GEN; };\n\ncls.isAsync = \nfunction() { return this.type & ST_ASYNC; };\n\ncls.isGetter = \nfunction() { return this.type & ST_GETTER; };\n\ncls.isSetter = \nfunction() { return this.type & ST_SETTER; };\n\ncls.isClassMem = \nfunction() { return this.type & ST_CLSMEM; };\n\ncls.isStaticMem = \nfunction() { return this.type & ST_STATICMEM; };\n\ncls.isObjMem = \nfunction() { return this.type & ST_OBJMEM; };\n\ncls.isMem =\nfunction() { return this.isClassMem() || this.isStaticMem() || this.isObjMem(); };\n\ncls.isArrow = \nfunction() { return this.type & ST_ARROW; };\n\ncls.isBlock =\nfunction() { return this.type & ST_BLOCK; };\n\ncls.isBare =\nfunction() { return this.type & ST_BARE; };\n\ncls.isCtor = \nfunction() { return this.type & ST_CTOR; };\n\ncls.isLexicalLike =\nfunction() {\n  return this.isBlock() || this.isCatch();\n};\n\ncls.isDecl = \nfunction() { return this.type & ST_DECL; };\n\ncls.isParen =\nfunction() { return this.type & ST_PAREN; };\n\ncls.isHoisted =\nfunction() { return this.isAnyFn() && this.isDecl(); };\n\ncls.isExpr = \nfunction() { return this.type & ST_EXPR; };\n\ncls.isBootable =\nfunction() {\n  return this.isScript() || this.isAnyFn() || this.isCatch() || this.isModule() || this.isBundle() || this.isGlobal();\n};\n\ncls.isSourceLevel = \nfunction() { return this.isScript() || this.isModule(); };\n\ncls.isSimpleFn =\nfunction() { return this.type & (ST_EXPR|ST_DECL); };\n\ncls.isBundle =\nfunction() { return this.type & ST_BUNDLE; };\n\ncls.isGlobal =\nfunction() { return this.type & ST_GLOBAL; };\n\ncls.isConditional = \nfunction() { return this.flags & ST_COND; };\n\ncls.isConcrete =\nfunction() { return this.isModule() || this.isAnyFn() || this.isScript() || this.isBundle(); };\n\ncls.isSoft = \nfunction() {\n  return this.isBlock() ||\n         this.isClass() ||\n         this.isCatch() ||\n         this.isParen() ||\n         this.isBare();\n};\n\n\n');
resolver.set('./src/Scope/synth-names.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.synth_defs_to =\nfunction(targetScope) {\n  var list = this.defs, e = 0, len = list.length(), insertSelf = this.isCatch() && !this.argIsSimple;\n  while (e < len) {\n    var tdclr = list.at(e++);\n    if (this.owns(tdclr) && !tdclr.isFnArg() &&\n      !(tdclr.isCatchArg() && this.argIsSimple)) {\n      if ( tdclr.isImported())\n        ASSERT.call(this, this.isSourceLevel(), \'not\' );\n      else {\n        targetScope.synthDecl(tdclr);\n        insertSelf && this.insertSynth_m(_m(tdclr.synthName), tdclr);\n      }\n    }\n  }\n};\n\n\n');
resolver.set('./src/Scope/head.js', '  import {ASSERT, ASSERT_EQ} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.activateBody =\nfunction() {\n  ASSERT.call(this, this.hasHead(),\n    \'a scope with a head was expected\');\n\n  ASSERT_EQ.call(this, this.inBody, false);\n  this.inBody = true;\n  this.refs = this.bodyRefs;\n};\n\ncls.deactivateBody =\nfunction() {\n  ASSERT.call(this, this.hasHead(),\n    \'a scope with a head was expected\');\n\n  ASSERT_EQ.call(this, this.inBody, true);\n  this.inBody = false;\n  this.refs = this.argRefs;\n};\n\n\n');
resolver.set('./src/Scope/strict.js', '  import {SF_STRICT} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.makeStrict =\nfunction() {\n  this.flags |= SF_STRICT; \n  if (this.isAnyFn())\n    this.verifyForStrictness();\n};\n\n\n');
resolver.set('./src/Scope/ref.js', '  import {ASSERT} from \'../other/constants.js\';\n  import Ref from \'../Ref/cls.js\';\n  import {cls} from \'./cls.js\';\n\ncls.refDirect_m = \nfunction(mname, childRef) {\n  var ref = this.focRefAny_m(mname);\n  if (childRef === null) {\n    ref.d++;\n    return ref;\n  }\n\n  ref.absorbDirect(childRef);\n  return ref;\n};\n\ncls.findRefU_m = cls.fRo_m =\nfunction(mname) {\n  return this.refs.has(mname) ? \n    this.refs.get(mname) : null;\n};\n\ncls.findRefAny_m = cls.fRa_m =\nfunction(mname) {\n  var ref = this.findRefU_m(mname);\n  if (ref)\n    return ref;\n\n  var tdecl = this.findDeclOwn_m(mname); // exclude inner vars\n  if (tdecl === null) {\n    if (this.isAnyFn())\n      tdecl = this.findParam_m(mname);\n    else if (this.isCatch() && this.args.has(mname))\n      tdecl = this.args.get(mname);\n  }\n\n  if (tdecl)\n    return tdecl.ref;\n\n  return null;\n};\n\ncls.removeRefU_m =\nfunction(mname) {\n  var ref = this.findRefU_m(mname);\n  if (ref)\n    this.insertRef_m(mname, null);\n  else\n    ASSERT.call(this, !this.findDeclOwn_m(mname), \'unresolved ref has a decl with the same name?!\');\n\n  return ref;\n};\n\ncls.rocRefU_m =\nfunction(mname) {\n  var ref = this.removeRefU_m(mname);\n  if (!ref)\n    ref = new Ref(this);\n\n  return ref;\n};\n\ncls.focRefAny_m = cls.focRa_m =\nfunction(mname) {\n  var ref = this.findRefAny_m(mname);\n  if (!ref) {\n    ref = new Ref(this);\n    this.insertRef_m(mname, ref);\n  }\n  return ref;\n};\n\ncls.insertRef_m =\nfunction(mname, ref) {\n  this.refs.set(mname, ref);\n};\n\ncls.refIndirect_m =\nfunction(mname, childRef) {\n  var ref = this.focRefAny_m(mname);\n  ASSERT.call(this, childRef !== null,\n    \'childRef is not allowed to be null when in refIndirect\');\n\n  ref.absorbIndirect(childRef);\n  return ref;\n};\n\n\n');
resolver.set('./src/Scope/has.js', '  import {SA_NEW_TARGET} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.hasNewTarget =\nfunction() { return this.allowed & SA_NEW_TARGET; };\n\ncls.hasHead =\nfunction() {\n  return this.isAnyFn() || this.isCatch();\n};\n\ncls.hasSignificantNames =\nfunction() {\n  if (this.isModule() ||\n    this.isScript())\n    return true;\n\n  if (this.isAnyFn())\n    return !this.inBody;\n  if (this.isCatch())\n    return !this.inBody && this.argIsSimple && this.argIsSimple;\n\n  return false;\n};\n\n\n');
resolver.set('./src/Scope/enter-exit.js', '  import {SF_FORINIT, SF_INSIDEPROLOGUE} from \'../other/scope-constants.js\';\n  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.enterForInit =\nfunction() { this.flags |= SF_FORINIT; };\n\ncls.enterPrologue =\nfunction() { this.flags |= SF_INSIDEPROLOGUE; };\n\ncls.exitForInit =\nfunction() {\n  ASSERT.call(this, this.insideForInit(),\n    \'must be in a for\');\n  this.flags &= ~SF_FORINIT;\n};\n\ncls.exitPrologue =\nfunction() {\n  this.flags &= ~SF_INSIDEPROLOGUE;\n};\n\n\n');
resolver.set('./src/Scope/can.js', '  import {SA_MEMSUPER, SA_AWAIT, SA_BREAK, SA_CALLSUPER, ST_GEN, ST_ASYNC, SA_YIELD, SA_RETURN, SA_CONTINUE, SA_NEW_TARGET} from \'../other/scope-constants.js\';\n  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.canSmem =\nfunction() { return this.actions & SA_MEMSUPER; };\n\ncls.canAwait = \nfunction() { return this.actions & SA_AWAIT; };\n\ncls.canBreak = \nfunction() { return this.actions & SA_BREAK; };\n\ncls.canDeclareLexical =\nfunction() {\n  if (this.isBlock() ||\n    this.isModule() ||\n    this.isScript())\n    return true;\n\n  if (this.isAnyFn() || this.isCatch())\n    return this.inBody;\n  \n  return this.insideForInit();\n};\n\ncls.canScall = \nfunction() { return this.actions & SA_CALLSUPER; };\n\ncls.canDeclareFn =\nfunction(st) {\n  if (this.isBlock() ||\n    this.isModule() ||\n    this.isScript())\n    return true;\n\n  if (this.isAnyFn() || this.isCatch())\n    return this.inBody;\n\n  ASSERT.call(this, this.isBare(),\n    \'a bare scope was expected but got \'+\n    this.typeString());\n\n  if (st & (ST_GEN|ST_ASYNC))\n    return false;\n\n  return this.insideIf();\n};\n\ncls.canYield = \nfunction() { return this.actions & SA_YIELD; };\n\ncls.canMakeThis =\nfunction() {\n  if (this.isAnyFn())\n    return !this.isArrow();\n  return this.isSourceLevel();\n};\n\ncls.canReturn = \nfunction() { return this.actions & SA_RETURN; };\n\ncls.canContinue = \nfunction() { return this.actions & SA_CONTINUE; };\n\ncls.canAccessNewTarget =\nfunction() { return this.actions & SA_NEW_TARGET; };\n\ncls.canHaveName =\nfunction() { return this.isAnyFn() || this.isClass(); };\n\n\n');
resolver.set('./src/Scope/cls.js', '  import Actix from \'../Actix/cls.js\';\n  import {ACT_SCOPE, ASSERT} from \'../other/constants.js\';\n  import SortedObj from \'../SortedObj/cls.js\';\n  import {createObj} from \'../other/util.js\';\n\nexport default function Scope(sParent, type) {\n  Actix.call(this, ACT_SCOPE);\n  this.parent = sParent;\n  this.parent && ASSERT.call(this, this.parent.reached, \'not reached\');\n  this.type = type;\n  this.refs = new SortedObj();\n  this.defs = new SortedObj();\n  this.hasTZCheckPoint = false;\n  this.scs =\n    this.isGlobal() ?\n      null :\n      this.isConcrete() ?\n        this :\n        this.parent.scs;\n\n  this.actions = this.determineActions();\n  this.flags = this.determineFlags();\n\n  this.scopeID_ref = this.parent ?\n    this.parent.scopeID_ref : {v: 0};\n  this.scopeID = this.scopeID_ref.v++;\n\n  this.parser = this.parent && this.parent.parser;\n\n  this.di_ref = \n    this.isGlobal() || this.isConcrete() ?\n      {v: 0} :\n      this.parent.di_ref;\n  this.di0 = this.di_ref.v++;\n\n  this.varTargets =\n    this.isGlobal() ?\n      null :\n      this.isConcrete() ?\n        {} :\n        this.isCatch() ?\n          createObj(this.parent.varTargets) :\n          this.parent.varTargets;\n\n  this.funLists = new SortedObj();\n\n  this.synthBase = \n    this.isSourceLevel() ? null : this.isConcrete() ? this.scs :\n    this.isBundle() || this.isGlobal() ? this : this.parent.synthBase;\n\n  this.sourceScope = null;\n\n  this.reached = true;\n  if (this.parent && this.parent.isParen())\n    this.parent.ch.push(this);\n}\n\n export var cls = Scope.prototype = createObj(Actix.prototype);\n');
resolver.set('./src/Scope/new-decl.js', '  import Decl from \'../Decl/cls.js\';\n  import {_u} from \'../other/scope-util.js\';\n  import {ASSERT, HAS} from \'../other/constants.js\';\n  import {DT_EXPORTED, DT_LET, DT_FN, DT_CONST, DT_VAR, DT_CLS, DT_CATCHARG, DT_FNARG} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.declareHoisted_m =\nfunction(mname, t) {\n  var tdecl = this.findDeclAny_m(mname);\n\n  if (tdecl) {\n    if (tdecl.isOverridableByVar()) {\n      tdecl.type |= t;\n      return tdecl;\n    }\n    this.err(\'var.can.not.override.existing\');\n  }\n\n  var tscope = null;\n  var isNew = false;\n\n  tdecl = this.findVarTarget_m(mname);\n  if (!tdecl) {\n    tscope = this.scs;\n    tdecl = new Decl().t(t).n(_u(mname)).r(tscope.rocRefU_m(mname));\n    ASSERT.call(this, !tscope.findDeclAny_m(mname), \'override is not allowed\');\n    isNew = true;\n\n  }\n  else { tdecl.type |= t; tscope = tdecl.ref.scope; }\n\n  this.insertDecl_m(mname, tdecl);\n\n  if (this !== tscope)\n    this.parent.hoistName_m(mname, tdecl, tscope);\n\n  isNew && tscope.addVarTarget_m(mname, tdecl);\n\n  return tdecl;\n};\n\ncls.findDeclOwn_m =\nfunction(mname) {\n  var tdecl = this.findDeclAny_m(mname);\n  if (tdecl && this.owns(tdecl))\n    return tdecl;\n\n  return null;\n};\n\ncls.findDeclAny_m = \nfunction(mname) {\n  if (this.isAnyFn() && !this.inBody )\n    return this.findParam_m(mname);\n\n//if (this.isCatch() && !this.inBody )\n//  return this.args.has(mname) ?\n//    this.args.get(mname) : null;\n\n  return this.defs.has(mname) ?\n    this.defs.get(mname) : null;\n};\n\ncls.hoistName_m =\nfunction(mname, tdecl, tscope, isNew) {\n  var cur = this;\n  while (true) {\n    var existing = cur.findDeclAny_m(mname);\n    if (existing) {\n      if (existing.isOverridableByVar())\n        return;\n      this.err(\'var.can.not.override.existing\');\n    }\n\n    cur.insertDecl_m(mname, tdecl);\n    if (cur === tscope) { break; }\n\n    cur = cur.parent;\n    ASSERT.call(this, cur !== null,\n      \'reached topmost before reaching target\');\n  }\n};\n\ncls.findParam_m =\nfunction(mname) {\n  ASSERT.call(this, this.isAnyFn() || this.isCatch(),\n    \'this scope is not an fn/catch, and has no params\');\n  return HAS.call(this.argMap, mname) ?\n    this.argMap[mname] : null;\n};\n\ncls.declareLexical_m =\nfunction(mname, t) {\n  var existing = this.findDeclAny_m(mname);\n  if (!existing) {\n    if (this.isAnyFn() || this.isCatch())\n      existing = this.findParam_m(mname);\n  }\n  if (existing)\n    this.err(\'lexical.can.not.override.existing\');\n\n  var newDecl = null;\n  newDecl = new Decl().t(t).n(_u(mname)).r(this.rocRefU_m(mname));\n  this.insertDecl_m(mname, newDecl);\n\n  return newDecl;\n};\n\ncls.decl_m = function(mname, dt) {\n  var decl = null;\n  switch (dt & ~DT_EXPORTED) {\n  case DT_LET:\n    decl = this.decl_let_m(mname, dt);\n    break;\n  case DT_FN:\n    decl = this.decl_fn_m(mname, dt);\n    break;\n  case DT_CONST:\n    decl = this.decl_const_m(mname, dt);\n    break;\n  case DT_VAR:\n    decl = this.decl_var_m(mname, dt);\n    break;\n  case DT_CLS:\n    decl = this.decl_cls_m(mname, dt);\n    break;\n  case DT_CATCHARG:\n    decl = this.decl_catchArg_m(mname, dt);\n    break;\n  case DT_FNARG:\n    decl = this.decl_fnArg_m(mname, dt);\n    break;\n  default: \n    ASSERT.call(this, false, \'unknown decltype\');\n\n  }\n\n  decl.idx = decl.ref.scope.di_ref.v++;\n\n  return decl;\n};\n\ncls.decl_let_m =\nfunction(mname, t) {\n  return this.declareLexical_m(mname, t);\n};\n\ncls.decl_fn_m =\nfunction(mname, t) {\n  return this.isLexicalLike() ?\n    this.declareLexical_m(mname, t) :\n    this.declareHoisted_m(mname, t);\n};\n\ncls.decl_const_m =\nfunction(mname, t) {\n  return this.declareLexical_m(mname, t);\n};\n\ncls.decl_var_m =\nfunction(mname, t) {\n  return this.declareHoisted_m(mname, t);\n};\n\ncls.decl_cls_m =\nfunction(mname, t) {\n  return this.declareLexical_m(mname, t);\n};\n\ncls.decl_catchArg_m =\nfunction(mname, t) {\n  ASSERT.call(this, this.isCatch() && !this.inBody,\n    \'only catch heads are allowed to declare args\');\n\n  var existing = this.findDeclAny_m(mname);\n  if (existing)\n    this.err(\'var.catch.is.duplicate\');\n\n  var newDecl = null;\n\n  newDecl = new Decl().t(t).n(_u(mname)).r(this.rocRefU_m(mname));\n\n  this.insertDecl_m(mname, newDecl);\n  this.addVarTarget_m(mname, newDecl);\n\n  return newDecl;\n};\n\ncls.decl_fnArg_m =\nfunction(mname, t) {\n  ASSERT.call(this, this.isAnyFn() && !this.inBody,\n    \'only fn heads are allowed to declare args\');\n\n  var ref = this.findRefAny_m(mname),\n      newDecl = new Decl().t(t).n(_u(mname));\n\n  var existing = HAS.call(this.argMap, mname) ?\n    this.argMap[mname] : null;\n\n  if (existing) {\n    this.canDup() || this.err(\'var.fn.is.dup.arg\');\n    if (!this.firstDup)\n      this.firstDup = existing;\n    newDecl.ref = ref; // unnecessary; also, no Decl::`r() is needed -- `ref.hasTarget` holds\n  }\n  else {\n    ref = this.rocRefU_m(mname);\n    newDecl.r(ref);\n    this.argMap[mname] = newDecl;\n    this.addVarTarget_m(mname, newDecl);\n  }\n\n  this.argList.push(newDecl);\n  return newDecl;\n};\n\ncls.insertDecl_m =\nfunction(mname, newDecl) {\n  this.defs.set(mname, newDecl);\n};\n\n\n');
resolver.set('./src/Scope/inside.js', '  import {SF_INSIDEIF, SF_LOOP, SF_STRICT, SF_INSIDEPROLOGUE, SF_FORINIT} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.insideIf =\nfunction() { return this.flags & SF_INSIDEIF; };\n\ncls.insideLoop =\nfunction() { return this.flags & SF_LOOP; };\n\ncls.insideStrict = \nfunction() { return this.flags & SF_STRICT; };\n\ncls.insidePrologue =\nfunction() { return this.flags & SF_INSIDEPROLOGUE; };\n\ncls.insideForInit =\nfunction() { return this.flags & SF_FORINIT; };\n\ncls.insideArgs =\nfunction() { return this.isAnyFn() && !this.inBody; };\n\n\n');
resolver.set('./src/Scope/global.js', '  import {ASSERT} from \'../other/constants.js\';\n  import Decl from \'../Decl/cls.js\';\n  import {DT_GLOBAL} from \'../other/scope-constants.js\';\n  import {_u} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.spReportGlobal_m =\nfunction(mname, ref) {\n  var globalBinding = this.findGlobal_m(mname);\n\n  if (globalBinding) {\n    ASSERT.call(this, this.isBundle(), \'not\');\n    globalBinding.refreshRSListWithList(ref.rsList);\n    ref.parentRef = globalBinding.ref;\n  }\n  else {\n    globalBinding = new Decl().t(DT_GLOBAL).r(ref).n(_u(mname));\n    ref.rsList.push(this);\n    this.insertGlobal_m(mname, globalBinding);\n  }\n\n  ref.scope = this;\n  return globalBinding;\n};\n\ncls.insertGlobal_m =\nfunction(mname, global) {\n  ASSERT.call(this, this.isGlobal() || this.isBundle(), \'global or bundler\' );\n  ASSERT.call(this, global.isGlobal(), \'global\');\n  ASSERT.call(this, this.defs.has(mname) === false, \'existing\');\n\n  return this.defs.set(mname, global);\n};\n\ncls.findGlobal_m =\nfunction(mname) {\n  var global = null;\n  if (this.defs.has(mname)) {\n    global = this.defs.get(mname);\n    ASSERT.call(this, global.isGlobal(), \'not\');\n  }\n  return global;\n};\n\n\n');
resolver.set('./src/Scope/spawn.js', '  import Scope from \'./cls.js\';\n  import {ST_BLOCK, ST_FN, ST_CLS, ST_BARE} from \'../other/scope-constants.js\';\n  import FunScope from \'../FunScope/cls.js\';\n  import CatchScope from \'../CatchScope/cls.js\';\n  import ParenScope from \'../ParenScope/cls.js\';\n  import ClassScope from \'../ClassScope/cls.js\';\n  import {cls} from \'./cls.js\';\n\ncls.spawnBlock =\nfunction() { return new Scope(this, ST_BLOCK); };\n\ncls.spawnFn =\nfunction(st) { return new FunScope(this, st|ST_FN); }\n\ncls.spawnCatch =\nfunction() { return new CatchScope(this); };\n\ncls.spawnParen =\nfunction() { return new ParenScope(this); };\n\ncls.spawnCls =\nfunction(st) { return new ClassScope(this, st|ST_CLS); };\n\ncls.spawnBare =\nfunction() { return new Scope(this, ST_BARE); };\n\n\n');
resolver.set('./src/BundleScope/whole.js', '  import \'./synth-names.js\';\n');
resolver.set('./src/BundleScope/synth-names.js', '  import {cls} from \'./cls.js\';\n\n/* TODO: eliminate */ cls.synth_decl_find_homonym_m =\nfunction(mname) { return this.findSynth_m(mname); };\n\n\n');
resolver.set('./src/BundleScope/cls.js', ' import ConcreteScope from \'../ConcreteScope/cls.js\';\n import {ST_BUNDLE} from \'../other/scope-constants.js\';\n\n export default function BundleScope() {\n   ConcreteScope.call(this, null, ST_BUNDLE);\n }\n\n import {createObj} from \'../other/util.js\';\n export var cls = BundleScope.prototype = createObj(ConcreteScope.prototype);\n');
resolver.set('./src/Parser/parse-cond.js', '  import {core} from \'../other/util.js\';\n  import {PREC_NONE} from \'../other/lexer-constants.js\';\n  import {CTX_TOP, CH_COLON, CTX_FOR} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseCond = function(cond, ctx) {\n  this.spc(core(cond), \'aft\');\n  this.next(); // \'?\'\n\n  var seq = this.parseNonSeq(PREC_NONE, CTX_TOP);\n  this.spc(core(seq), \'aft\');\n  if (!this.expectT(CH_COLON))\n    this.err(\'cond.colon\',{extra:[cond,seq,context]});\n\n  var alt = this.parseNonSeq(PREC_NONE, (ctx&CTX_FOR)|CTX_TOP);\n  return {\n    type: \'ConditionalExpression\',\n    test: core(cond),\n    start: cond.start,\n    end: alt.end,\n    loc: {\n      start: cond.loc.start,\n      end: alt.loc.end },\n    consequent: core(seq),\n    alternate: core(alt),\n    \'#y\': this.Y(cond,alt,seq), \'#c\': {}\n  };\n};\n\n\n');
resolver.set('./src/Parser/count-y.js', '  import {PAREN, HAS, ASSERT} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\nfunction base_Y0(n) {\n  if (!this.scope.canYield() || n === null)\n    return 0;\n  switch (n.type) {\n  case \'Identifier\':\n  case \'TemplateElement\':\n  case \'Literal\':\n  case \'DebuggerStatement\':\n  case \'Super\':\n  case \'ThisExpression\':\n    return 0; \n  }\n\n  if (n.type === PAREN)\n    return base_Y0.call(this, core(n));\n\n  if (!HAS.call(n, \'#y\')) {\n    console.error(n);\n    throw new Error(n.type+\'[#y]\');\n  }\n\n  return n[\'#y\'];\n};\n\nfunction base_Y(n) {\n  ASSERT.call(this, n !== null, \'n\');\n  return base_Y0.call(this, n);\n}\n\ncls.Y0 = function() {\n  var yc = 0, e = 0;\n  while (e < arguments.length)\n    yc += base_Y0.call(this, arguments[e++]);\n  return yc;\n};\n\ncls.Y = function() {\n  var yc = 0, e = 0;\n  while (e < arguments.length)\n    yc += base_Y.call(this, arguments[e++]);\n  return yc;\n};\n\n\n');
resolver.set('./src/Parser/read-char.js', '  import {cls} from \'./cls.js\';\n\ncls.readSingleChar =\nfunction() {\n  var ch = this.src.charAt(this.c);\n  this.lttype = ch.charCodeAt(0);\n  this.ltraw = ch;\n  this.setsimpoff(this.c+1);\n};\n\n\n');
resolver.set('./src/Parser/assig-helpers.js', '  import {cls} from \'./cls.js\';\n\ncls.ensureSpreadToRestArgument_soft = function(head) {\n  return head.type !== \'AssignmentExpression\';\n};\n\n\n');
resolver.set('./src/Parser/parse-top-level-expr.js', '  import {PREC_NONE} from \'../other/lexer-constants.js\';\n  import {CH_COMMA, CTX_FOR, CTX_TOP} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseExpr =\nfunction(ctx) {\n  var head = this.parseNonSeq(PREC_NONE, ctx);\n  var latestExpr = null;\n\n  if (this.lttype !== CH_COMMA)\n    return head;\n\n  ctx &= CTX_FOR;\n  ctx |= CTX_TOP;\n\n  var e = [latestExpr = core(head)];\n  var y = this.Y(head);\n  do {\n    latestExpr && this.spc(latestExpr, \'aft\');\n    this.next();\n    latestExpr = this.parseNonSeq(PREC_NONE, ctx);\n    y += this.Y(latestExpr);\n    e.push(core(latestExpr));\n  } while (this.lttype === CH_COMMA);\n\n  return {\n    type: \'SequenceExpression\',\n    expressions: e,\n    start: head.start,\n    end: latestExpr.end,\n    loc: {\n      start: head.loc.start,\n      end: latestExpr.loc.end\n    },\n    \'#y\': y, \'#c\': {}\n  };\n};\n\n\n');
resolver.set('./src/Parser/parse-do.js', '  import {SA_BREAK, SA_CONTINUE} from \'../other/scope-constants.js\';\n  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {CH_LPAREN, CTX_TOP, CH_RPAREN, CH_SEMI} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseDoWhile =\nfunction () {\n  this.resvchk();\n  this.testStmt() || this.err(\'not.stmt\');\n  this.fixupLabels(true);\n\n  this.enterScope(this.scope.spawnBare());\n  var scope = this.scope; \n\n  this.allow(SA_BREAK|SA_CONTINUE);\n\n  var c0 = this.c0, cb = {}, loc0 = this.loc0() ;\n\n  this.suc(cb, \'bef\');\n  this.next(); // \'do...while\'\n\n  var nbody = this.parseStatement(true) ;\n  if (this.lttype === TK_ID && this.ltval === \'while\') {\n    this.resvchk();\n    this.spc(nbody, \'aft\');\n    this.next();\n  }\n  else\n    this.err(\'do.has.no.while\',{extra:[startc,startLoc,nbody]});\n\n  this.suc(cb, \'while.aft\');\n  if (!this.expectT(CH_LPAREN))\n    this.err(\'do.has.no.opening.paren\',{extra:[startc,startLoc,nbody]});\n\n  var cond = core(this.parseExpr(CTX_TOP));\n  var c = this.c, li = this.li, col = this.col;\n\n  this.spc(cond, \'aft\');\n  if (!this.expectT(CH_RPAREN))\n    this.err(\'do.has.no.closing.paren\',{extra:[startc,startLoc,nbody,cond]});\n\n  if (this.lttype === CH_SEMI) {\n     c = this.c;\n     li = this.li ;\n     col = this.col;\n     this.suc(cb, \'cond.aft\');\n     this.next();\n  }\n\n  this.foundStatement = true;\n  this.exitScope(); \n\n  return {\n    type: \'DoWhileStatement\',\n    test: cond,\n    start: c0,\n    end: c,\n    body: nbody,\n    loc: {\n      start: loc0,\n      end: { line: li, column: col } },\n    \'#scope\': scope,\n    \'#y\': this.Y(cond)+this.Y(nbody), \'#c\': cb\n  };\n};\n\n\n');
resolver.set('./src/Parser/parse-return.js', '  import {CTX_NULLABLE, CTX_TOP} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseReturn = function () {\n  this.resvchk();\n  this.testStmt() || this.err(\'not.stmt\');\n  this.fixupLabels(false ) ;\n\n  if (!this.scope.canReturn()) \n    this.err(\'return.not.in.a.function\');\n\n  var c0 = this.c0, loc0 = this.loc0();\n  var c = this.c, li = this.li, col = this.col;\n\n  var b = {}, r = null;\n\n  this.suc(b, \'bef\' );\n  this.next(); // \'return\'\n\n  if (!this.nl)\n    r = this.parseExpr(CTX_NULLABLE|CTX_TOP);\n\n  this.semi(r ? r[\'#c\'] : b, r ? \'aft\' : \'ret.aft\') || this.err(\'no.semi\');\n  var ec = this.semiC || (r && r.end) || c;\n  var eloc = this.semiLoc ||\n    (r && r.loc.end) ||\n    { line: li, column: col };\n\n  this.foundStatement = true;\n  return { \n    type: \'ReturnStatement\',\n    argument: r && core(r),\n    start: c0,\n    end: ec,\n    loc: { start: loc0, end: eloc },\n    \'#c\': b,\n    \'#y\': this.Y0(r)\n  };\n};\n\n\n');
resolver.set('./src/Parser/skip-ws.js', '  import {CH_WHITESPACE, CH_CARRIAGE_RETURN, CH_LINE_FEED, CH_VTAB, CH_TAB, CH_FORM_FEED, CH_DIV, CH_MUL, CH_MIN, CH_GREATER_THAN, CH_LESS_THAN, CH_EXCLAMATION} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.skipWS =\nfunction() {\n  var c = this.c, s = this.src, l = s.length;\n  var nl = false, sourceStart = c === 0, ch = -1;\n\n  SKIPLOOP:\n  while (c < l)\n    switch (s.charCodeAt(c)) {\n    case CH_WHITESPACE:\n      while (\n        ++c < l &&\n        s.charCodeAt(c) === CH_WHITESPACE\n      );\n      continue;\n\n    case CH_CARRIAGE_RETURN:\n      if (\n        c+1 < l &&\n        s.charCodeAt(c+1) === CH_LINE_FEED\n      ) c++;\n    case CH_LINE_FEED:\n      if (!nl)\n        nl = true;\n      c++;\n      this.setzoff(c);\n      continue;\n\n    case CH_VTAB:\n    case CH_TAB:\n    case CH_FORM_FEED:\n      c++;\n      continue;\n\n    case CH_DIV:\n      if (c+1 >= l)\n        break SKIPLOOP;\n\n      switch (s.charCodeAt(c+1)) {\n      case CH_DIV:\n        this.setsimpoff(c+2); // \'//\'\n        this.readComment_line();\n        c = this.c;\n        continue;\n\n      case CH_MUL:\n        this.setsimpoff(c+2); // \'/*\'\n        if (this.readComment_multi() && !nl)\n          nl = true;\n        c = this.c;\n        continue;\n      }\n\n      break SKIPLOOP;\n\n    case CH_MIN:\n      if (\n        this.v>5 &&\n        (nl || sourceStart) &&\n        this.isScript &&\n        c+2<l &&\n        s.charCodeAt(c+1) === CH_MIN &&\n        s.charCodeAt(c+2) === CH_GREATER_THAN\n      ) {\n        this.setsimpoff(c+3); // \'-->\'\n        this.readComment_line();\n        c = this.c;\n        continue;\n      }\n\n      break SKIPLOOP;\n\n    case CH_LESS_THAN:\n      if (\n        this.v>5 &&\n        this.isScript &&\n        c+3<l &&\n        s.charCodeAt(c+1) === CH_EXCLAMATION &&\n        s.charCodeAt(c+2) === CH_MIN &&\n        s.charCodeAt(c+3) === CH_MIN\n      ) {\n        this.setsimpoff(c+4) ;\n        this.readComment_line();\n        c = this.c;\n        continue;\n      }\n\n      break SKIPLOOP;\n\n    case 0x0020: case 0x00A0: \n    case 0x1680: case 0x2000: \n    case 0x2001: case 0x2002: case 0x2003:\n    case 0x2004: case 0x2005: case 0x2006:\n    case 0x2007: case 0x2008: case 0x2009:\n    case 0x200A: case 0x202F: case 0x205F:\n    case 0x3000: case 0xFEFF:\n      c++;\n      continue;\n  \n    case 0x2028:\n    case 0x2029:\n      nl = true;\n      c++;\n      this.setzoff(c);\n      continue;\n\n    default: break SKIPLOOP;\n    }\n\n  this.setsimpoff(c);\n  this.nl = nl;\n};\n\n\n');
resolver.set('./src/Parser/read-num.js', '  import {CH_0, CH_SINGLEDOT, CH_E, CH_e, CH_BACK_SLASH, CH_X, CH_x, CH_B, CH_b, CH_O, CH_o, CH_1, CH_8, CH_MIN, CH_ADD} from \'../other/constants.js\';\n  import {isNum, isIDHead} from \'../other/ctype.js\';\n  import {FL_SIMPLE_FLOAT, FL_GET_E, TK_NUM, FL_HEADLESS_FLOAT} from \'../other/lexer-constants.js\';\n  import {octStr2num, hex2num} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\nvar NUM0_NONDEC = 0,\n    NUM0_DEC = 1,\n    NUM0_ZERO = 2;\n\ncls.readNum_raw = function(ch) {\n  var c = this.c+1, s = this.src, l = s.length;\n  var legacy = false, deci = false, fl = false;\n  if (ch === CH_0) {\n    var t0 = this.readNum_0();\n    deci = t0 !== NUM0_NONDEC;\n    legacy = t0 === NUM0_DEC;\n    c = this.c;\n  }\n  else {\n    deci = true;\n    while (c < l) {\n      ch = s.charCodeAt(c);\n      if (isNum(ch))\n        c++;\n      else\n        break;\n    }\n    this.setsimpoff(c);\n  }\n\n  if (deci) {\n    if (c < l && s.charCodeAt(c) === CH_SINGLEDOT) {\n      this.readNum_tail(FL_SIMPLE_FLOAT);\n      fl = true;\n      c = this.c;\n    }\n    if (c < l) {\n      ch = s.charCodeAt(c);\n      if (ch === CH_E || ch === CH_e) {\n        fl = true;\n        this.readNum_tail(FL_GET_E);\n      }\n    }\n    this.ltraw = this.c0_to_c();\n    this.ltval = (fl ? parseFloat : parseInt)(\n      legacy ? this.ltraw.substring(1) : this.ltraw);\n  }\n\n  this.lttype = TK_NUM;\n  c = this.c;\n  if (c<l) {\n    ch = s.charCodeAt(c);\n    if (isIDHead(ch))\n      this.err(\'id.head.is.num.tail\');\n    if (ch === CH_BACK_SLASH || (ch >= 0x0D800 && ch <= 0x0DBFF))\n      this.err(\'unexpected.char.is.num.tail\');\n  }\n};\n\ncls.readNum_0 =\nfunction() {\n  var ch = this.scat(this.c+1);\n  switch (ch) {\n  case CH_X: case CH_x:\n    this.readNum_0x();\n    return NUM0_NONDEC;\n\n  case CH_B: case CH_b:\n    this.readNum_0b();\n    return NUM0_NONDEC;\n\n  case CH_O: case CH_o:\n    this.readNum_0o();\n    return NUM0_NONDEC;\n\n  default:\n    if (isNum(ch))\n      return this.readNum_octLegacy(ch);\n\n    this.setsimpoff(this.c+1);\n    return NUM0_ZERO;\n  }\n};\n\ncls.readNum_0b =\nfunction() {\n  var c = this.c+2, // \'0b\'\n      s = this.src,\n      l = s.length,\n      v = 0;\n\n  if (c >= l) {\n    this.setsimpoff(c);\n    this.err(\'bin.expected.got.eof\');\n  }\n\n  var ch = s.charCodeAt(c);\n  if (ch !== CH_0 && ch !== CH_1) {\n    this.setsimpoff(c);\n    this.err(\'bin.expected.got.something.else\');\n  }\n\n  v = ch - CH_0;\n  c++;\n  while (c<l) {\n    ch = s.charCodeAt(c);\n    if (!isNum(ch))\n      break;\n    if (ch === CH_0 || ch === CH_1)\n      v = (v << 1)|(ch-CH_0);\n    else\n      this.err(\'bin.but.got.nonbin\');\n    c++;\n  }\n\n  this.setsimpoff(c);\n  this.ltval = v;\n  this.ltraw = this.c0_to_c();\n};\n\ncls.readNum_octLegacy =\nfunction(ch) {\n  if (this.scope.insideStrict())\n    this.err(\'oct.legacy.num.in.strict\');\n\n  var c = this.c+1, s = this.src, l = s.length, dec = false;\n  do {\n    if (!dec && ch >= CH_8)\n      dec = true;\n    c++;\n    if (c >= l)\n      break;\n    ch = s.charCodeAt(c);\n  } while (isNum(ch));\n\n  this.setsimpoff(c);\n  if (!dec) {\n    this.ltraw = this.c0_to_c();\n    this.ltval = octStr2num(this.ltraw);\n    return NUM0_NONDEC;\n  }\n\n  return NUM0_DEC;\n};\n\ncls.readNum_tail =\nfunction(fl) {\n  var c = this.c,\n      s = this.src,\n      l = s.length,\n      hasSign = false,\n      ch = -1;\n\n  if (fl !== FL_GET_E) {\n    c++; // \'.\'\n    if (fl === FL_HEADLESS_FLOAT) {\n      if (c >= l || !isNum(s.charCodeAt(c)))\n        this.err(\'float.tail.is.headless.must.have.digits\');\n      c++;\n    }\n    while (c<l && isNum(s.charCodeAt(c)))\n      c++;\n\n    if (c<l) {\n      ch = s.charCodeAt(c);\n      if (ch === CH_E || ch === CH_e)\n        fl = FL_GET_E;\n    }\n  }\n\n  if (fl === FL_GET_E) {\n    c++;\n    if (c >= l)\n      this.err(\'float.nothing.after.e\');\n    ch = s.charCodeAt(c);\n    if (ch === CH_MIN || ch === CH_ADD) {\n      c++;\n      if (c >= l)\n        this.err(\'float.nothing.after.sign\');\n      ch = s.charCodeAt(c);\n      hasSign = true;\n    }\n    if (!isNum(ch))\n      this.err(\'float.needs.a.mantissa\');\n    c++;\n    while (c<l && isNum(s.charCodeAt(c)))\n      c++;\n  }\n\n  this.setsimpoff(c);\n};\n\ncls.readNum_0x =\nfunction() {\n  var c = this.c+2, // \'0x\'\n      s = this.src,\n      l = s.length,\n      v = 0;\n\n  if (c>=l) {\n    this.setsimpoff(c);\n    this.err(\'hex.expected.got.eof\');\n  }\n\n  var ch = hex2num(s.charCodeAt(c));\n  if (ch === -1)\n    this.err(\'hex.expected.got.somthing.else\');\n\n  v = ch;\n  c++;\n  while (c<l) {\n    ch = hex2num(s.charCodeAt(c));\n    if (ch === -1)\n      break;\n    v = (v<<4)|ch;\n    c++;\n  }\n\n  this.setsimpoff(c);\n  this.ltraw = this.c0_to_c();\n  this.ltval = v;\n};\n\ncls.readNum_0o =\nfunction() {\n  var c = this.c+2,\n      s = this.src,\n      l = s.length,\n      v = 0;\n\n  if (c>=l) {\n    this.setsimpoff(c);\n    this.err(\'oct.expected.got.eof\');\n  }\n\n  var ch = s.charCodeAt(c);\n  if (ch < CH_0 || ch >= CH_8)\n    this.err(\'oct.expected.got.somthing.else\');\n\n  v = ch - CH_0;\n  c++;\n  while (c<l) {\n    ch = s.charCodeAt(c);\n    if (!isNum(ch))\n      break;\n    if (ch < CH_0 || ch >= CH_8)\n      this.err(\'oct.expected.got.somthing.else\');\n    v = (v<<3)|(ch-CH_0);\n    c++;\n  }\n\n  this.setsimpoff(c);\n  this.ltraw = this.c0_to_c();\n  this.ltval = v;\n};\n\n\n');
resolver.set('./src/Parser/reg-surrogate.js', '  import {surrogate} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.regMakeSurrogate =\nfunction(c1, c2) {\n  return {\n    type: \'#Regex.Ho\',\n    cp: surrogate(c1.cp, c2.cp ),\n    start: c1.start,\n    end: c2.end,\n    raw: c1.raw + c2.raw,\n    loc: { start: c1.loc.start, end: c2.loc.end },\n    c1: c1,\n    c2: c2\n  };\n};\n\ncls.regSurrogateComponent_VOKE =\nfunction(cp, offset, kind, escape) {\n  var c0 = this.c, loc0 = this.loc();\n  this.setsimpoff(offset);\n  this.regQuantifiable = true;\n  return {\n    type: \'#Regex.SurrogateComponent\',\n    kind: kind,\n    start: c0,\n    end: offset,\n    cp: cp,\n    loc: { start: loc0, end: this.loc() },\n    next: null, // if it turns out to be the lead of a surrogate pair\n    escape : escape ,\n    raw: this.src.substring(c0, offset)\n  };\n};\n\n\n');
resolver.set('./src/Parser/parse-switch-case.js', '  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {core} from \'../other/util.js\';\n  import {CTX_TOP, CH_COLON} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseSwitchCase = function () {\n  var c0 = -1, cb = {}, loc0 = null;\n\n  var nbody = null, cond = null;\n\n  if (this.lttype === TK_ID) \n  switch (this.ltval) {\n  case \'default\':\n    this.resvchk();\n    this.suc(cb, \'bef\');\n    c0 = this.c0;\n    loc0 = this.loc0();\n    this.next();\n    this.suc(cb, \'default.aft\');\n    break ;\n\n  case \'case\':\n    this.resvchk();\n    this.suc(cb, \'bef\');\n    c0 = this.c0;\n    loc0 = this.loc0();\n    this.next(); // \'case\'\n    cond = core(this.parseExpr(CTX_TOP)) ;\n    this.spc(cond, \'aft\');\n    break;\n\n  default: return null;\n  } else return null;\n\n  var c = this.c, li = this.li, col = this.col;\n  if (!this.expectT(CH_COLON))\n    this.err(\'switch.case.has.no.colon\');\n\n  nbody = this.stmtList();\n  var last = nbody.length ? nbody[nbody.length-1] : null;\n\n  var ec = -1, eloc = null;\n  if (last) {\n    ec = last.end;\n    eloc = last.loc.end;\n  } else {\n    ec = c;\n    eloc = { line: li, column: col };\n  }\n\n  this.suc(cb, \'inner\');\n  return {\n    type: \'SwitchCase\',\n    test: cond,\n    start: c0,\n    end: ec,\n    loc: { start: loc0, end: eloc },\n    consequent: nbody,\n    \'#y\': this.Y0(cond)+this.yc, \'#c\': cb\n  };\n};\n\n\n');
resolver.set('./src/Parser/new-import.js', '  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {DT_IDEFAULT, DT_IALIASED, DT_INAMESPACE} from \'../other/scope-constants.js\';\n  import {CH_COMMA, CH_LCURLY, ASSERT, CH_RCURLY} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseImport =\nfunction() {\n  this.v<=5 && this.err(\'ver.exim\');\n  this.isScript && this.err(\'import.not.in.module\');\n  this.testStmt() || this.err(\'not.stmt\');\n\n  var hasTail = true, cb = {};\n  var c0 = this.c0, loc0 = this.loc0(), list = [];\n\n  this.suc(cb, \'bef\');\n  this.next();\n\n  var lName = null, decl = null;\n\n  var beforeFrom = \"\", beforeFromNode = null;\n  if (this.lttype === TK_ID) {\n    this.validate(this.ltval);\n    lName = this.id();\n    decl = this.scope.declareImportedName(lName, DT_IDEFAULT);\n    list.push({\n      type: \'ImportDefaultSpecifier\',\n      local: lName,\n      start: lName.start,\n      end: lName.end,\n      loc: lName.loc,\n      \'#y\': 0,\n      \'#decl\': decl, \'#c\': {}\n    });\n    if (this.lttype === CH_COMMA) {\n      this.spc(lName, \'aft\');\n      this.next();\n    }\n    else {\n      beforeFromNode = lName;\n      hasTail = false;\n    }\n  }\n\n  if (hasTail) {\n    this.cb = cb;\n    if (this.peekMul())\n      list.push(beforeFromNode = this.parseImport_namespace());\n    else if (this.lttype === CH_LCURLY) {\n      beforeFrom = \'list.aft\';\n      this.parseImport_slist(list);\n    }\n    else {\n      if (list.length) {\n        ASSERT.call(this, list.length === 1,\n          \'how come has more than a single specifier been parsed before the comma \'+\n          \'was reached?!\');\n        this.err(\'import.invalid.specifier.after.comma\');\n      }\n      hasTail = false;\n    }\n  }\n\n  // test whether we need `from`\n  if (list.length || hasTail /* any tail */) {\n    this.peekID(\'from\') || this.err(\'import.from\');\n    if (beforeFromNode)\n      this.spc(beforeFromNode, \'aft\');\n    else {\n      ASSERT.call(this, beforeFrom !== \"\", \'bef\');\n      this.suc(cb, beforeFrom);\n    }\n    this.next();\n  }\n\n  this.peekStr() || this.err(\'import.source.is.not.str\');\n  var src = this.parseString(this.lttype);\n\n  this.semi(src[\'#c\'], \'aft\') || this.err(\'no.semi\');\n\n  var ec = this.semiC || src.end, eloc = this.semiLoc || src.loc.end;\n  this.foundStatement = true;\n\n  this.scope.regulateImports_sl(src, list);\n  return {\n    type: \'ImportDeclaration\',\n    start: c0,\n    loc: { start: loc0, end: eloc },\n    end: ec, \n    specifiers: list,\n    source: src,\n    \'#y\': 0, \'#c\': {}\n  };\n};\n\ncls.parseImport_slist =\nfunction(list) {\n  var cb = this.cb; this.suc(cb, \'list.bef\');\n  this.next(); // \'{\'\n  while (this.lttype === TK_ID) {\n    var eName = this.id();\n    var lName = eName;\n    if (this.lttype !== TK_ID)\n      this.validate(lName.name);\n    else {\n      this.ltval === \'as\' || this.err(\'import.specifier.no.as\');\n      this.spc(eName, \'aft\');\n      this.next();\n      this.lttype === TK_ID || this.err(\'import.specifier.local.not.id\');\n      this.validate(this.ltval);\n      lName = this.id();\n    }\n    var decl = this.scope.declareImportedName(lName, DT_IALIASED );\n    list.push({\n      type: \'ImportSpecifier\',\n      start: eName.start,\n      loc: { start: eName.loc.start, end: lName.loc.end },\n      end: lName.end,\n      imported: eName,\n      local: lName,\n      \'#y\': 0,\n      \'#decl\': decl, \'#c\': {}\n    });\n\n    this.spc(lName, \'aft\');\n    if (this.lttype === CH_COMMA)\n      this.next();\n    else\n      break;\n  }\n\n  this.suc(cb, \'inner\');\n  this.expectT(CH_RCURLY) || this.err(\'import.specifier.list.unfinished\');\n};\n      \ncls.parseImport_namespace =\nfunction() {\n  var c0 = this.c0, cb = this.cb, loc0 = this.loc0();\n\n  this.suc(cb, \'*.bef\' );\n  this.next();\n  if (!this.peekID(\'as\'))\n    this.err(\'import.namespace.specifier.no.as\');\n\n  this.suc(cb, \'aft.*\' );\n  this.next();\n  if (this.lttype !== TK_ID)\n    this.err(\'import.namespace.specifier.local.not.id\');\n\n  this.validate(this.ltval);\n  var lName = this.id();\n\n  var decl = this.scope.declareImportedName(lName, DT_INAMESPACE);\n  return {\n    type: \'ImportNamespaceSpecifier\',\n    start: c0,\n    loc: { start: loc0, end: lName.loc.end },\n    end: lName.end,\n    local: lName,\n    \'#y\': 0,\n    \'#decl\': decl,\n    \'#c\': {}\n  };\n};\n\n\n');
resolver.set('./src/Parser/new-parse-expr-head.js', '  import {TK_ID, TK_NUM, TK_UNBIN, PREC_UNARY} from \'../other/lexer-constants.js\';\n  import {CH_LSQBRACKET, CH_LPAREN, CH_LCURLY, CH_MULTI_QUOTE, CH_SINGLE_QUOTE, CH_DIV, CH_BACKTICK} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseExprHead =\nfunction(ctx) {\n  var head = this.exprHead;\n  if (head !== null) this.exprHead = null;\n  else\n  switch (this.lttype) {\n  case TK_ID:\n    if (head = this.parseIDExprHead(ctx))\n      break;\n\n    // the head is not an id-statement,\n    // but it is not an id-expr either.\n    // this is actually the case for\n    // void, typeof, yield, delete, and await\n    return null;\n\n  case CH_LSQBRACKET:\n    head = this.parseArray(ctx);\n    break;\n\n  case CH_LPAREN:\n    head = this.parseParen(ctx);\n    break;\n\n  case CH_LCURLY:\n    head = this.parseObj(ctx);\n    break;\n\n  case CH_MULTI_QUOTE:\n  case CH_SINGLE_QUOTE:\n    head = this.parseString(this.lttype);\n    break;\n\n  case TK_NUM:\n    head = this.getLit_num();\n    break;\n\n  case CH_DIV:\n    head = this.parseRegexLiteral();\n    break;\n\n  case CH_BACKTICK:\n    head = this.parseTemplate();\n    break;\n\n  case TK_UNBIN:\n    this.prec = PREC_UNARY;\n    return null;\n\n  default: return null;\n  }\n\n  return head;\n};\n\n\n');
resolver.set('./src/Parser/parse-assig.js', '  import {CTX_FOR, PAREN_NODE, CTX_PARPAT, CTX_NO_SIMPLE_ERR, CTX_PARAM, CTX_TOP} from \'../other/constants.js\';\n  import {ERR_PAREN_UNBINDABLE, ERR_NONE_YET, ERR_PIN, ERR_PIN_NOT_AN_EQ} from \'../other/error-constants.js\';\n  import {core} from \'../other/util.js\';\n  import {errt_top, errt_pin, errt_track, errt_param, errt_pat} from \'../other/errt.js\';\n  import {PREC_NONE} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseAssignment = function(head, ctx) {\n  var o = this.ltraw;\n  if (o === \'=>\')\n    return this.parseArrow(head, ctx&CTX_FOR);\n\n  if (head.type === PAREN_NODE) {\n    if (!this.ensureSAT(head.expr)) {\n      this.at = ERR_PAREN_UNBINDABLE;\n      this.ae = this.ao = head;\n      this.throwTricky(\'a\', this.at, this.ae);\n    }\n    else\n      this.dissolveParen();\n  }\n\n  this.spc(core(head), \'aft\');\n  var right = null, oploc = null;\n  if (o === \'=\') {\n    // if this assignment is a pattern\n    if (ctx & CTX_PARPAT)\n      this.st_adjust_for_toAssig();\n\n    var st = ERR_NONE_YET, se = null, so = null,\n        pt = ERR_NONE_YET, pe = null, po = null;\n\n    // S- and P-errors are not modified during toAssig; A-errors might.\n    this.toAssig(core(head), ctx);\n\n    // flush any remaining simple errors, now that there are no more assignment errors;\n    // when toAssig completes, it might have set this.st with an assig-to-arguments-or-eval;\n    // this will get thrown immediately if the assignment is non-leaking, i.e., \n    // won\'t tolerate simple errors\n    if ((ctx & CTX_NO_SIMPLE_ERR) && this.st !== ERR_NONE_YET)\n      this.throwTricky(\'s\', this.st);\n\n    var sc0 = -1, sli0 = -1, scol0 = -1,\n        pc0 = -1, pli0 = -1, pcol0 = -1;\n\n    // save all the errors on the left hand side, to restore them after right is parsed\n    if ((ctx & CTX_PARPAT) && this.st !== ERR_NONE_YET) {\n      st = this.st; se = this.se; so = this.so;\n      if (st & ERR_PIN)\n        sc0 = this.pin.s.c0, sli0 = this.pin.s.li0, scol0 = this.pin.s.col0;\n    }\n    if ((ctx & CTX_PARAM) && this.pt !== ERR_NONE_YET) {\n      pt = this.pt; pe = this.pe; po = this.po;\n      if (pt & ERR_PIN)\n        pc0 = this.pin.p.c0, pli0 = this.pin.p.li0, pcol0 = this.pin.p.col0;\n    }\n\n    // toAssig was successful -- clear\n    this.at_flush();\n    if (errt_top(ctx))\n      ctx &= ~CTX_TOP; // a top assig is not a pattern\n\n    this.next(); // \'=\'\n    right = this.parseNonSeq(PREC_NONE,\n      (ctx & CTX_FOR)|CTX_TOP);\n\n    // restore the state of errors in the left hand side, if there are any\n    if (pt !== ERR_NONE_YET) {\n      this.pt = pt; this.pe = pe; this.po = po;\n      errt_pin(pt) && this.pin_pt(pc0,pli0,pcol0);\n    }\n    if (st !== ERR_NONE_YET) {\n      this.st = st; this.se = se; this.so = so;\n      errt_pin(st) && this.pin_st(sc0,sli0,scol0);\n    }\n  }\n  else {\n    // TODO: further scrutiny, like checking for this.at, is necessary (?)\n    if (!this.ensureSAT(core(head)))\n      this.err(\'assig.not.simple\',{tn:core(head)});\n\n    if (errt_top(ctx))\n      ctx &= ~CTX_TOP;\n\n    var c0 = -1, li0 = -1, col0 = -1;\n\n    // if this is an potential assignment pattern, pin the location of the non-\'=\'\n    if (ctx & CTX_PARPAT) {\n      c0 = this.c0; li0 = this.li0; col0 = this.col0;\n    }\n\n    if (o === \'+=\') oploc = this.loc0();\n    this.next(); // <:o:>=\n    right = this.parseNonSeq(PREC_NONE, (ctx & CTX_FOR)|CTX_TOP);\n\n    // record an actual error if we have parsed a potential param or assignment pattern\n    if (errt_track(ctx)) {\n      if (errt_param(ctx)) {\n        this.pin_pt(c0,li0,col0);\n        this.pt = ERR_PIN_NOT_AN_EQ;\n      }\n      if (errt_pat(ctx)) {\n        this.pin_at(c0,li0,col0);\n        this.at = ERR_PIN_NOT_AN_EQ;\n      }\n    }\n  }\n \n  this.inferName(head, core(right), false);\n  return {\n    type: \'AssignmentExpression\',\n    operator: o,\n    start: head.start,\n    end: right.end,\n    left: head,\n    right: core(right),\n    loc: {\n      start: head.loc.start,\n      end: right.loc.end\n    }, \'#o\': oploc,\n    \'#y\': this.Y(head)+this.Y(right), \'#c\': {}\n  };\n};\n\n\n');
resolver.set('./src/Parser/new-parse-stmt.js', '  import {CH_LCURLY, CH_SEMI, CTX_PAT, CH_SINGLE_QUOTE, CH_MULTI_QUOTE, CTX_NULLABLE, CTX_TOP, CH_COLON} from \'../other/constants.js\';\n  import {TK_ID, TK_EOF} from \'../other/lexer-constants.js\';\n  import {isDirective, core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseStatement =\nfunction(allowNull) {\n  var head = null;\n  switch (this.lttype) {\n  case CH_LCURLY:\n    head = this.parseBlock();\n    break;\n  case CH_SEMI:\n    head = this.parseEmptyStatement();\n    break;\n  case TK_ID:\n    this.canBeStatement = true;\n    // TODO: CTX.PAT|CTX.NO_SIMP\n    head = this.parseIDExprHead(CTX_PAT);\n    if (!this.foundStatement) {\n      this.canBeStatement = false;\n      this.exprHead = head;\n      head = null;\n    }\n    break;\n\n  case CH_SINGLE_QUOTE:\n  case CH_MULTI_QUOTE:\n    if (this.scope.insidePrologue())\n      this.chkDirective = true;\n    this.exprHead = this.parseString(this.lttype);\n    break;\n\n  case TK_EOF:\n    if (!allowNull)\n      this.err(\'stmt.null\');\n    break;\n  }\n\n  var finishPrologue = this.scope.insidePrologue();\n  if (this.foundStatement) {\n    if (head === null)\n      allowNull || this.err(\'stmt.null\');\n    this.foundStatement = false;\n  }\n  else if (head === null) {\n    head = this.parseExpr(CTX_NULLABLE|CTX_TOP);\n    if (head === null)\n      allowNull || this.err(\'stmt.null\');\n    else if (head.type === \'Identifier\' &&\n      this.lttype === CH_COLON)\n      head = this.parseLabel(head, allowNull);\n    else {\n      this.fixupLabels(false);\n      if (finishPrologue && isDirective(head)) {\n        finishPrologue = false;\n        this.applyDirective(head);\n      }\n      this.semi(core(head)[\'#c\'], \'aft\') || this.err(\'no.semi\');\n      head = {\n        type: \'ExpressionStatement\',\n        expression: core(head),\n        start: head.start,\n        end: this.semiC || head.end,\n        loc: {\n          start: head.loc.start,\n          end: this.semiLoc || head.loc.end },\n        \'#y\': this.Y(head), \'#c\': {}\n      };\n    }\n  }\n\n  if (finishPrologue)\n    this.scope.exitPrologue();\n\n  return head;\n};\n\n\n');
resolver.set('./src/Parser/read-op-exclam.js', '  import {CH_EQUALITY_SIGN} from \'../other/constants.js\';\n  import {PREC_EQ, TK_SIMP_BINARY, TK_UNARY} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readOp_exclam =\nfunction() {\n  var c = this.c; c++; // \'!\';\n  var ch = this.scat(c);\n\n  if (ch === CH_EQUALITY_SIGN) {\n    this.prec = PREC_EQ;\n    this.lttype = TK_SIMP_BINARY;\n    c++;\n    ch = this.scat(c);\n    if (ch === CH_EQUALITY_SIGN) {\n      c++; this.ltraw = \'!==\';\n    }\n    else this.ltraw = \'!=\';\n  }\n  else {\n    this.lttype = TK_UNARY;\n    this.ltraw = \'!\';\n  }\n\n  this.setsimpoff(c);\n};\n\n\n');
resolver.set('./src/Parser/core.js', 'import {DT_NONE, DT_FN, DT_CLS, DT_INFERRED} from \'../other/scope-constants.js\';\nimport {getIDName} from \'../other/util.js\';\nimport {cls} from \'./cls.js\';\n\ncls.inferName =\nfunction(left, right, isComputed) {\n  if (isComputed && left.type === \'Identifier\')\n    return null;\n\n  var t = DT_NONE, c = false;\n  switch (right.type) {\n  case \'FunctionExpression\':\n  case \'FunctionDeclaration\': // TODO: must be a default ex\n    if (right.id) return null;\n    t = DT_FN;\n    break;\n  case \'ClassExpression\':\n    if (right.id)\n      return null;\n    t = DT_CLS;\n    c = true;\n    break; \n  case \'ArrowFunctionExpression\':\n    t = DT_FN;\n    break;\n\n  default: return null\n  }\n\n  var scope = right[\'#scope\'];\n  t |= DT_INFERRED;\n  var name = \"\";\n\n  name = getIDName(left);\n  if (name === \"\")\n    return null;\n\n  var scopeName = null;\n  if (name !== \'default\') {\n    scopeName = scope.setName(name, null).t(t);\n    scopeName.site = left;\n    scopeName.synthName = scopeName.name;\n  }\n\n  if (c && right[\'#ct\'] !== null) this.inferName(left, right[\'#ct\'].value, false);\n\n  return scopeName;\n};\n\ncls.cutEx =\nfunction() {\n  var ex = this.ex;\n  this.ex = DT_NONE;\n  return ex;\n};\n\n\n');
resolver.set('./src/Parser/read-op-and.js', '  import {CH_EQUALITY_SIGN, CH_AND} from \'../other/constants.js\';\n  import {TK_OP_ASSIG, TK_SIMP_BINARY, PREC_LOG_AND, PREC_BIT_AND} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readOp_and = \nfunction() {\n  var c = this.c; c++;\n  var ch = this.scat(c);\n\n  if (ch === CH_EQUALITY_SIGN) {\n    c++; this.lttype = TK_OP_ASSIG;\n    this.ltraw = \'&=\';\n  }\n  else {\n    this.lttype = TK_SIMP_BINARY;\n    if (ch === CH_AND) {\n      c++; this.prec = PREC_LOG_AND;\n      this.ltraw = \'&&\';\n    }\n    else {\n      this.prec = PREC_BIT_AND;\n      this.ltraw = \'&\';\n    }\n  }\n\n  this.setsimpoff(c);\n};\n\n\n');
resolver.set('./src/Parser/new-parse-continue.js', '  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseContinue =\nfunction() {\n  this.resvchk();\n  this.testStmt() || this.err(\'not.stmt\');\n  this.fixupLabels(false);\n\n  if (!this.scope.canContinue())\n    this.err(\'continue.not.in.loop\');\n\n  var c0 = this.c0, loc0 = this.loc0();\n  var c = this.c, li = this.li, col = this.col;\n\n  var cb = {};\n  this.suc(cb, \'bef\');\n  this.next(); // \'continue\'\n\n  var label = null;\n  if (!this.nl && this.lttype === TK_ID) {\n    this.validate(this.ltval);\n    label = this.id();\n    var target = this.findLabel_m(_m(label.name));\n    if (target === null)\n      this.err(\'continue.no.such.label\');\n    if (!target.loop)\n      this.err(\'continue.not.a.loop\');\n  }\n\n  label && this.spc(label, \'aft\');\n  this.semi(label ? label.cb : cb, label ? \'aft\' : \'cont.aft\') || this.err(\'no.semi\');\n  var ec = this.semiC || (label && label.end) || c;\n  var eloc = this.semiLoc ||\n    (label && label.loc.end) ||\n    { line: li, column: col };\n\n  this.foundStatement = true;\n  return {\n    type: \'ContinueStatement\',\n    label: label,\n    start: c0,\n    end: ec,\n    loc: { start: loc0, end: eloc },\n    \'#y\': 0,\n    \'#c\': cb\n  };\n};\n\n\n');
resolver.set('./src/Parser/read-id-bs.js', '  import {ERR_NONE_YET, ERR_PIN_UNICODE_IN_RESV} from \'../other/error-constants.js\';\n  import {isIDHead} from \'../other/ctype.js\';\n  import {cp2sp} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readID_bs =\nfunction() {\n  if (this.ct === ERR_NONE_YET) {\n    this.ct = ERR_PIN_UNICODE_IN_RESV;\n    this.pin_ct(this.c,this.li,this.col);\n  }\n  var bsc = this.readBS();\n  var ccode = bsc;\n  if (bsc >= 0x0D800 && bsc <= 0x0DBFF)\n    this.err(\'id.head.is.surrogate\');\n  else if (!isIDHead(bsc))\n    this.err(\'id.head.esc.not.idstart\');\n\n  var head = cp2sp(bsc);\n  return this.readID_withHead(head);\n};\n\n\n');
resolver.set('./src/Parser/reg-curly.js', '  import {ASSERT_EQ, CH_COMMA, CH_RCURLY} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.regCurlyQuantifier =\nfunction() {\n  ASSERT_EQ.call(this, this.regCurlyChar, false);\n  var c0 = this.c, c = c0, s = this.src, l = this.regLastOffset, li0 = this.li, col0 = this.col, luo0 = this.luo;\n  c++; // \'{\'\n  this.setsimpoff(c);\n  VALID: {\n    var minVal = this.regTryToParseNum();\n    if (minVal === -1)\n      break VALID;\n    var minRaw = s.substring(c, this.c);\n    c = this.c;\n    if (c >= l)\n      break VALID;\n    var maxVal = -1, maxRaw = \"\";\n    if (s.charCodeAt(c) === CH_COMMA) {\n      c++; // \',\'\n      this.setsimpoff(c);\n      maxVal = this.regTryToParseNum();\n      if (maxVal !== -1) {\n        maxRaw = s.substring(c,this.c);\n        c = this.c;\n      }\n      else\n        maxRaw = \'inf\';\n    }\n    if (c >= l)\n      break VALID;\n    if (s.charCodeAt(c) !== CH_RCURLY)\n      break VALID;\n\n    this.setsimpoff(c+1);\n\n    if (maxVal >= 0 && maxVal < minVal)\n      return this.regErr_curlyMinIsBiggerThanMax(); // TODO: max\'s location rather than }\'s location\n\n    var min = { raw: minRaw, value: minVal }, max = min;\n    if (maxRaw !== \"\")\n      max = maxVal === -1 ? null : { raw: maxRaw, value: maxVal };\n\n    return {\n      type: \'#Regex.CurlyQuantifier\',\n      min: min,\n      max: max,\n      end: this.c,\n      start: c0,\n      loc: { start: { line: li0, column: col0 }, end: this.loc() }\n    };\n  }\n\n  this.rw(c0,li0,col0,luo0);\n  this.regCurlyChar = true;\n\n  return null;\n};\n\n\n');
resolver.set('./src/Parser/loc.js', '  import {cls} from \'./cls.js\';\n\ncls.loc = function() { return { line: this.li, column: this.col }; };\ncls.loc0 = function() { return  { line: this.li0, column: this.col0 }; };\n\n\n');
resolver.set('./src/Parser/reg-quantifier.js', '  import {CH_ADD, CH_QUESTION, CH_MUL, CH_LCURLY, ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.regPrepareQ =\nfunction() {\n  var c = this.c, s = this.src, l = this.regLastOffset;\n  if (c >= l)\n    return false;\n  switch (s.charCodeAt(c)) {\n  case CH_ADD:\n  case CH_QUESTION:\n  case CH_MUL:\n    this.regPendingCQ = true; // peek charQuantifier\n    return true;\n  case CH_LCURLY:\n    this.regPendingBQ = this.regCurlyQuantifier();\n    return this.regPendingBQ !== null;\n  }\n  return false;\n};\n\ncls.regQuantify =\nfunction(elem) {\n  var c = this.c, li = this.li, col = this.col;\n  var loc = null, s = this.src;\n  var t = \'\', bq = null;\n\n  if (this.regPendingCQ) {\n    ASSERT.call(this, this.regPendingBQ === null, \'hasPBQnt\');\n    this.regPendingCQ = false;\n    t = s.charAt(c);\n    c++;\n    this.setsimpoff(c);\n    loc = this.loc();\n  } \n  else if (this.regPendingBQ) {\n    ASSERT.call(this, !this.regPendingCQ, \'hasPCQnt\');\n    t = \'{}\';\n    bq = this.regPendingBQ;\n    this.regPendingBQ = null;\n    loc = bq.loc.end;\n  }\n  else \n    ASSERT.call(this, false, \'neither PCQnt nor PBQnt\');\n\n  var greedy = true;\n  if (this.scat(this.c) === CH_QUESTION) {\n    if (bq)\n      loc = { line: loc.line, column: loc.column };\n    c++;\n    this.setsimpoff(c);\n    loc.column++;\n    greedy = false;\n  }\n\n  return {\n    type: \'#Regex.Quantified\' ,\n    rangeQuantifier: bq,\n    quantifier: t,\n    pattern: elem,\n    start: elem.start,\n    loc: { start: elem.loc.start, end: loc },\n    end: this.c,\n    greedy: greedy\n  };\n};\n\n\n\n\n');
resolver.set('./src/Parser/new-parse-meth.js', '  import {CH_LPAREN, PAREN, CTX_HASPROTOTYPE, CTX_CTOR_NOT_ALLOWED, CTX_NONE} from \'../other/constants.js\';\n  import {ST_CLSMEM, ST_STATICMEM, ST_CTOR, ST_GETTER, ST_SETTER, ST_ACCESSOR} from \'../other/scope-constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseMeth =\nfunction(memName, ctx, st) {\n  if (this.lttype !== CH_LPAREN)\n    this.err(\'meth.paren\');\n\n  var val = null, computed = memName.type === PAREN, name = \"\";\n  var cb = this.cb;\n\n  if (st & ST_CLSMEM) {\n    if (st & ST_STATICMEM) {\n      if (ctx & CTX_HASPROTOTYPE)\n        this.err(\'cls.prototype.is.static.mem\',\n          {tn:memName});\n      if (st & ST_CTOR)\n        st &= ~ST_CTOR;\n    }\n    if (st & ST_CTOR) {\n      if (st !== (ST_CTOR|ST_CLSMEM))\n        this.err(\'class.ctor.is.special.mem\',\n          {tn:memName});\n      if (ctx & CTX_CTOR_NOT_ALLOWED)\n        this.err(\'class.ctor.is.dup\',{tn:memName});\n    }\n\n    this.spc(core(memName), \'aft\');\n    val = this.parseFn(CTX_NONE, st);\n\n    (st & ST_CTOR) || this.inferName(core(memName), val, computed);\n\n    return {\n      type: \'MethodDefinition\',\n      key: core(memName),\n      start: memName.start,\n      end: val.end,\n      kind:\n        (st & ST_CTOR) ?\n          \'constructor\' :\n          (st & ST_GETTER) ?\n            \'get\' :\n            (st & ST_SETTER) ?\n              \'set\' :\n              \'method\',\n      computed: computed,\n      loc: {\n        start: memName.loc.start,\n        end: val.loc.end\n      },\n      value: val,\n      \'static\': !!(st & ST_STATICMEM),\n      \'#y\': computed ? this.Y(memName) : 0, \'#c\': cb\n    };\n  }\n\n  this.spc(core(memName), \'aft\');\n  val = this.parseFn(CTX_NONE, st);\n\n  this.inferName(core(memName), val, computed);\n  return {\n    type: \'Property\',\n    key: core(memName),\n    start: memName.start,\n    end: val.end,\n    kind:\n      !(st & ST_ACCESSOR) ?\n        \'init\' :\n        (st & ST_SETTER) ?\n          \'set\' :\n          \'get\',\n    computed: memName.type === PAREN,\n    loc: {\n      start: memName.loc.start,\n      end : val.loc.end\n    },\n    method: !(st & ST_ACCESSOR),\n    shorthand: false,\n    value: val,\n    \'#y\': computed ? this.Y(memName) : 0, \'#c\': cb\n  };\n};\n\n\n');
resolver.set('./src/Parser/reg-helpers.js', '  import {isCharSeq} from \'../other/util.js\';\n  import {isNum} from \'../other/ctype.js\';\n  import {CH_0} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.resetLastRegexElem =\nfunction() {\n  var lbe = this.regLastBareElem;\n  if (lbe !== null)\n    this.regLastBareElem = null;\n\n  return lbe;\n};\n\ncls.regLEIAC =\nfunction() {\n  return (this.regLastBareElem && isCharSeq(this.regLastBareElem)) ?\n    this.regLastBareElem : null;\n};\n\ncls.expectChar =\nfunction(ch) {\n  var c = this.c, s = this.src, l = this.regLastOffset;\n  if (c >= l)\n    return false;\n  if (s.charCodeAt(c) === ch) {\n    this.setsimpoff(c+1);\n    return true;\n  }\n  return false;\n};\n\ncls.regTryToParseNum =\nfunction() {\n  var c = this.c, s = this.src, l = this.regLastOffset;\n  if (c >= l)\n    return -1;\n  var v = 0, ch = s.charCodeAt(c);\n  if (!isNum(ch))\n    return -1;\n  do {\n    v *= 10;\n    v += (ch - CH_0);\n    c++;\n    if (c >= l)\n      break;\n    ch = s.charCodeAt(c);\n  } while (isNum(ch));\n\n  this.setsimpoff(c);\n  return v;\n};\n\n\n');
resolver.set('./src/Parser/parse-class.js', '  import {ST_NONE, ST_DECL, DT_CLS, ST_EXPR, DT_CLSNAME, ST_CLSMEM, SF_HERITAGE, RS_SCALL, RS_THIS} from \'../other/scope-constants.js\';\n  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {CTX_DEFAULT, CTX_NONE, CH_LCURLY, CH_SEMI, CTX_CTOR_NOT_ALLOWED, CH_RCURLY, CH_LPAREN, CH_SINGLEDOT, CH_LSQBRACKET} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseClass = \nfunction(ctx) {\n  if (this.v <= 5)\n    this.err(\'ver.class\');\n  if (this.unsatisfiedLabel)\n    this.err(\'class.label.not.allowed\');\n\n  var c0 = this.c0, cb = {}, loc0 = this.loc0();\n\n  this.suc(cb, \'bef\');\n\n  var isStmt = false, name = null;\n  if (this.canBeStatement) {\n    isStmt = true;\n    this.canBeStatement = false;\n  }\n\n  this.next(); // \'class\'\n\n  var sourceDecl = null;\n  var st = ST_NONE;\n  if (isStmt) {\n    st = ST_DECL;\n    if (!this.scope.canDeclareLexical())\n      this.err(\'class.decl.not.in.block\',{c0:c0,loc0:loc0});\n    if (this.lttype === TK_ID && this.ltval !== \'extends\') {\n      this.declMode = DT_CLS|this.cutEx();\n      name = this.getName_cls(st);\n      sourceDecl = this.scope.findDeclOwn_m(_m(name.name));\n    }\n    else if (!(ctx & CTX_DEFAULT))\n      this.err(\'class.decl.has.no.name\', {c0:startc,loc0:startLoc});\n  }\n  else {\n    st = ST_EXPR;\n    if (this.lttype === TK_ID && this.ltval !== \'extends\')\n      name = this.getName_cls(st);\n  }\n\n  this.enterScope(this.scope.spawnCls(st));\n  var scope = this.scope;\n\n  scope.makeStrict();\n\n  if (name)\n    scope.setName(name.name, sourceDecl).t(DT_CLSNAME);\n\n  var superClass = null;\n  if (this.lttype === TK_ID && this.ltval === \'extends\') {\n    name ? this.spc(name, \'aft\') : this.suc(cb, \'class.aft\');\n    this.next();\n    superClass = this.parseExprHead(CTX_NONE) || this.err(\'no.heritage\');\n    superClass = this.parseTail(superClass);\n  }\n\n  var mmflags = ST_CLSMEM, mmctx = CTX_NONE;\n\n  if (superClass)\n    this.scope.flags |= SF_HERITAGE;\n\n  var list = [];\n  var c0b = this.c0, loc0b  = this.loc0();\n\n  var cbb = {}; this.suc(cbb, \'bef\');\n  cbb[\'semis\'] = [];\n  if (!this.expectT(CH_LCURLY))\n    this.err(\'class.no.curly\',{c0:startc,loc0:startLoc,extra:{n:name,s:superClass,c:ctx}});\n\n  var mem = null;\n\n  var y = 0, ct = null;\n  while (true) {\n    if (this.lttype === CH_SEMI) {\n      this.commentBuf && cbb.semis.push([list.length, this.cc()]);\n      this.next();\n      continue;\n    }\n    mem = this.parseMem(mmctx, mmflags);\n    if (mem !== null) {\n      list.push(mem);\n      y += this.Y(mem);\n      if (mem.kind === \'constructor\') {\n        ct = mem;\n        mmctx |= CTX_CTOR_NOT_ALLOWED;\n      }\n    }\n    else break;\n  }\n\n  var eloc = this.loc();\n  var n = {\n    type: isStmt ? \'ClassDeclaration\' : \'ClassExpression\',\n    id: name,\n    start: c0,\n    end: this.c,\n    superClass: superClass,\n    loc: { start: loc0, end: eloc },\n    body: {\n      type: \'ClassBody\',\n      loc: { start: loc0b, end: eloc },\n      start: c0b,\n      end: this.c,\n      body: list,\n      \'#y\': y, \'#c\': cbb\n    },\n    \'#y\': (superClass ? this.Y(superClass) : 0)+y,\n    \'#scope\': scope, \'#c\': cb, \'#ct\': ct\n  };\n\n  this.suc(cbb, \'inner\');\n  if (!this.expectT(CH_RCURLY))\n    this.err(\'class.unfinished\',{tn:n, extra:{delim:\'}\'}});\n\n  if (name) {\n    if (ct) this.inferName(name, ct.value, false);\n  }\n  this.exitScope();\n\n  if (isStmt)\n    this.foundStatement = true;\n\n  return n;\n};\n\ncls.parseSuper = function() {\n  if (this.v <=5 ) this.err(\'ver.super\');\n\n  var cb = {}; this.suc(cb, \'bef\');\n  var n = {\n    type: \'Super\',\n    loc: { start: this.loc0(), end: this.loc() },\n    start: this.c0,\n    end: this.c ,\n   \'#c\': cb,\n   \'#liq\': null,\n   \'#this\': null, \'#ti\': void 0\n  };\n \n  this.next();\n  switch (this.lttype) {\n  case CH_LPAREN:\n    if (!this.scope.canScall())\n      this.err(\'class.super.call\',{tn:n});\n    this.scope.refDirect_m(RS_SCALL, null);\n    this.scope.refDirect_m(RS_THIS, null);\n    break;\n \n  case CH_SINGLEDOT:\n  case CH_LSQBRACKET:\n    if (!this.scope.canSmem())\n      this.err(\'class.super.mem\',{tn:n});\n    break ;\n  \n  default: this.err(\'class.super.lone\',{tn:n}); \n  }\n \n  return n;\n};\n\n\n');
resolver.set('./src/Parser/parse-meta.js', '  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseMeta =\nfunction(c0,loc0,c,li,col) {\n  var cb = this.cb;\n  this.v<=5 && this.err(\'ver.ntarget\');\n  this.lttype !== TK_ID && this.err(\'ntarget.id\');\n  if (this.ltval !== \'target\')\n    this.err(\'meta.new.has.unknown.prop\');\n  \n  if (!this.scope.canAccessNewTarget())\n    this.err(\'meta.new.not.in.function\',{c0:startc,loc:startLoc});\n\n  var prop = this.id();\n\n  return {\n    type: \'MetaProperty\',\n    meta: {\n      type: \'Identifier\',\n      name : \'new\',\n      start: c0,\n      end: c,\n      loc: {\n        start : loc0,\n        end: { line: li, column: col }\n      } \n    },\n    start : c0,\n    property: prop,\n    end: prop.end,\n    loc : { start: loc0, end: prop.loc.end },\n    \'#y\': 0, \'#c\': cb\n  };\n};\n\n\n');
resolver.set('./src/Parser/parse-empty.js', '  import {cls} from \'./cls.js\';\n\ncls.parseEmptyStatement =\nfunction() {\n  var n = {\n    type: \'EmptyStatement\',\n    start: this.c0,\n    loc: { start: this.loc0(), end: this.loc() },\n    end: this.c,\n    \'#y\': 0, \'#c\': {}\n  };\n  this.spc(n, \'bef\');\n  this.next();\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/new-parse-non-seq.js', '  import {TK_UNARY, TK_UNBIN, TK_AA_MM, TK_YIELD, PREC_NONE, TK_ANY_ASSIG, PREC_UNARY, PREC_EX, isRA, isLog} from \'../other/lexer-constants.js\';\n  import {CTX_NULLABLE, CH_QUESTION, CTX_FOR} from \'../other/constants.js\';\n  import {errt_pat, errt_noLeak} from \'../other/errt.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseNonSeq =\nfunction(prec, ctx) {\n  var head = this.exprHead;\n  if (head) this.exprHead = null;\n  else head = this.parseExprHead(ctx);\n\n  if (head)\n    head = this.parseTail(head);\n  else\n  switch (this.lttype) {\n  case TK_UNARY:\n  case TK_UNBIN:\n    head = this.parseUnary(ctx);\n    break;\n\n  case TK_AA_MM:\n    head = this.parseUpdate(null, ctx);\n    break;\n\n  case TK_YIELD:\n    if (prec !== PREC_NONE)\n      this.err(\'yield.as.an.id\');\n    return this.parseYield(ctx);\n\n  default:\n    if (!(ctx&CTX_NULLABLE))\n      this.err(\'nexpr.null.head\');\n    return null;\n  }\n\n  var hasOp = this.getOp(ctx);\n  if (this.lttype & TK_ANY_ASSIG) {\n    if (prec !== PREC_NONE)\n      this.err(\'assig.not.first\');\n    return this.parseAssignment(head, ctx);\n  }\n\n  if (errt_pat(ctx)) {\n    // alternatively, head.type === NPAREN\n    if (this.parenScope) {\n      this.st_flush();\n      this.dissolveParen();\n    }\n    else if (hasOp || errt_noLeak(ctx))\n      this.st_flush();\n  }\n\n  while (hasOp) {\n    if (this.lttype === TK_AA_MM) {\n      if (!this.nl) {\n        head = this.parseUpdate(head, ctx);\n        hasOp = this.getOp(ctx);\n        continue;\n      }\n      else break;\n    }\n\n    if (this.lttype === CH_QUESTION) {\n      if (prec === PREC_NONE)\n        head = this.parseCond(head, ctx);\n      break;\n    }\n\n    var curPrec = this.prec;\n    if (prec === PREC_UNARY && curPrec === PREC_EX)\n      this.err(\'unary.before.an.exponentiation\');\n    if (curPrec < prec)\n      break;\n    if (curPrec === prec && !isRA(prec))\n      break;\n\n    this.spc(core(head), \'aft\');\n    var o = this.ltraw, oploc = o === \'+\' ? this.loc0() : null;\n    this.next();\n    var r = this.parseNonSeq(curPrec, ctx & CTX_FOR);\n    head = {\n      type: isLog(curPrec) ? \'LogicalExpression\' : \'BinaryExpression\',\n      operator: o,\n      start: head.start,\n      end: r.end,\n      loc: {\n        start: head.loc.start,\n        end: r.loc.end },\n      left: core(head),\n      right: core(r), \'#o\': oploc,\n      \'#y\': this.Y(head, r), \'#c\': {}\n    };\n\n    hasOp = this.getOp(ctx);\n  }\n\n  return head;\n};\n\n\n');
resolver.set('./src/Parser/new-semi.js', '  import {CH_SEMI, CH_RCURLY} from \'../other/constants.js\';\n  import {TK_EOF} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.semi =\nfunction(cb, i) {\n  var t = this.lttype;\n  if (t === CH_SEMI) {\n    cb && this.suc(cb, i);\n    this.semiC = this.c;\n    this.semiLoc = this.loc();\n    this.next();\n    return true;\n  }\n\n  if (this.nl) {\n    this.semiC = 0;\n    this.semiLoc = null;\n    return true;\n  }\n\n  switch (t) {\n  case TK_EOF:\n    this.semiC = this.c;\n    this.semiLoc = this.loc();\n    return true;\n\n  case CH_RCURLY:\n    cb && this.suc(cb, i);\n    this.semiC = this.c0;\n    this.semiLoc = this.loc0();\n    return true;\n  }\n\n  return false;\n};\n\n\n');
resolver.set('./src/Parser/parse-pat-rest-new.js', '  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parsePat_rest =\nfunction() {\n  this.v<=5 && this.err(\'ver.spread.rest\');\n  var c0 = this.c0, cb = {}, loc0 = this.loc0();\n\n  this.suc(cb, \'bef\');\n  this.next(); // \'...\'\n\n  if (this.v<7 && this.lttype !== TK_ID)\n    this.err(\'rest.binding.arg.not.id\');\n\n  var arg = this.parsePat();\n\n  if (arg === null)\n    this.err(\'rest.has.no.arg\');\n\n  return {\n    type: \'RestElement\',\n    argument: arg,\n    start: c0,\n    end: arg.end,\n    loc: {\n      start: loc0,\n      end: arg.loc.end },\n    \'#c\': cb,\n    \'#y\': this.Y(arg)\n  };\n};\n\n\n');
resolver.set('./src/Parser/read-op-add.js', '  import {CH_ADD, CH_EQUALITY_SIGN} from \'../other/constants.js\';\n  import {TK_AA_MM, TK_OP_ASSIG, TK_UNBIN} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readOp_add =\nfunction() {\n  var c = this.c; c++ // \'+\'\n  var ch = this.scat(c);\n  if (ch === CH_ADD) {\n    c++;\n    this.lttype = TK_AA_MM;\n    this.ltraw = \'++\';\n  }\n  else if (ch === CH_EQUALITY_SIGN) {\n    c++;\n    this.lttype = TK_OP_ASSIG;\n    this.ltraw = \'+=\';\n  }\n  else {\n    this.lttype = TK_UNBIN;\n    this.ltraw = \'+\';\n  }\n\n  this.setsimpoff(c);\n};\n\n\n');
resolver.set('./src/Parser/read-op-or.js', '  import {CH_EQUALITY_SIGN, CH_OR} from \'../other/constants.js\';\n  import {TK_OP_ASSIG, TK_SIMP_BINARY, PREC_LOG_OR, PREC_BIT_OR} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readOp_or =\nfunction() {\n  var c = this.c; c++; // \'|\'\n  var ch = this.scat(c);\n\n  if (ch === CH_EQUALITY_SIGN) {\n    c++;\n    this.lttype = TK_OP_ASSIG;\n    this.ltraw = \'|=\';\n  }\n  else {\n    this.lttype = TK_SIMP_BINARY;\n    if (ch === CH_OR) {\n      c++; this.prec = PREC_LOG_OR;\n      this.ltraw = \'||\';\n    }\n    else {\n      this.prec = PREC_BIT_OR;\n      this.ltraw = \'|\';\n    }\n  }\n\n  this.setsimpoff(c);\n};\n\n\n');
resolver.set('./src/Parser/read-op-mul.js', '  import {CH_EQUALITY_SIGN, CH_MUL} from \'../other/constants.js\';\n  import {TK_OP_ASSIG, PREC_EX, TK_SIMP_BINARY, PREC_MUL} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readOp_mul =\nfunction() {\n  var c = this.c; c++; // \'*\'\n  var ch = this.scat(c);\n\n  if (ch === CH_EQUALITY_SIGN) {\n    c++;\n    this.lttype = TK_OP_ASSIG;\n    this.ltraw = \'*=\';\n  }\n  else if (ch === CH_MUL) {\n    c++; ch = this.scat(c);\n    if (ch === CH_EQUALITY_SIGN) {\n      c++;\n      this.lttype = TK_OP_ASSIG;\n      this.ltraw = \'**=\';\n    }\n    else {\n      this.prec = PREC_EX;\n      this.lttype = TK_SIMP_BINARY;\n      this.ltraw = \'**\';\n    }\n  }\n  else {\n    this.prec = PREC_MUL;\n    this.lttype = TK_SIMP_BINARY;\n    this.ltraw = \'*\';\n  }\n\n  this.setsimpoff(c);\n};\n\n\n');
resolver.set('./src/Parser/new-parse-this.js', '  import {RS_THIS} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseThis = function() {\n  this.resvchk();\n  var cb = {}; this.suc(cb, \'bef\' );\n\n  var n = {\n    type : \'ThisExpression\',\n    loc: { start: this.loc0(), end: this.loc() },\n    start: this.c0,\n    end : this.c, \'#c\': cb\n  };\n\n  this.next() ;\n  this.scope.refDirect_m(RS_THIS, null);\n  return n;\n};\n\n\n\n\n');
resolver.set('./src/Parser/new-parse-mem.js', '  import {ST_NONE, ST_CLSMEM, ST_STATICMEM, ST_ASYNC, ST_ACCESSOR, ST_GETTER, ST_SETTER, ST_GEN, ST_CTOR} from \'../other/scope-constants.js\';\n  import {TK_ID, TK_NUM, PREC_NONE, TK_SIMP_ASSIG} from \'../other/lexer-constants.js\';\n  import {CH_LSQBRACKET, CH_MULTI_QUOTE, CH_SINGLE_QUOTE, CTX_HASPROTOTYPE, CTX_HASPROTO, CH_LPAREN, CH_COLON, PAREN_NODE, PAREN, HAS} from \'../other/constants.js\';\n  import {core, CB} from \'../other/util.js\';\n  import {errt_track, errt_ptrack, errt_atrack, errt_noLeak, errt_strack} from \'../other/errt.js\';\n  import {ERR_NONE_YET, ERR_PAREN_UNBINDABLE, ERR_SHORTHAND_UNASSIGNED} from \'../other/error-constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import Comments from \'../Comments/cls.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseMem =\nfunction(ctx, st) {\n  var firstMod = null, latestMod = null, nonMod = null;\n  var mpending = ST_NONE, nina = false; // name is newline async\n\n  var c0 = -1, loc0 = null;\n\n  var lpm = \"\"; // latest pending modifier, that is.\n\n  var cb = {};\n\n  MM:\n  while (this.lttype === TK_ID) {\n    if (latestMod) {\n      cb[latestMod.name+\'.bef\'] = latestMod[\'#c\'].bef;\n      latestMod = this.id();\n    }\n    else {\n      latestMod = this.id();\n      c0 = latestMod.start, loc0 = latestMod.loc.start;\n    }\n    switch (latestMod.name) {\n    case \'static\':\n      st |= mpending;\n      if (!(st & ST_CLSMEM)) { nonMod = latestMod; break MM; }\n      if (st & ST_STATICMEM) { nonMod = latestMod; break MM; }\n      if (st & ST_ASYNC) { nonMod = latestMod; break MM; }\n      mpending = ST_STATICMEM;\n\n      break;\n\n    case \'get\':\n    case \'set\':\n      st |= mpending;\n      nonMod = latestMod;\n      if (st & ST_ACCESSOR) break MM;\n      if (st & ST_ASYNC) break MM;\n      mpending = latestMod.name === \'get\' ? ST_GETTER : ST_SETTER;\n\n      break;\n\n    case \'async\':\n      st |= mpending;\n      if (this.nl) { // an async with a newline coming after it is not a modifier\n        nina = true;\n        nonMod = latestMod;\n        break MM;\n      }\n      if (st & ST_ACCESSOR) { nonMod = latestMod; break MM }\n      if (st & ST_ASYNC) { nonMod = latestMod; break MM; }\n      mpending = ST_ASYNC;\n\n      break;\n\n    default:\n      st |= mpending;\n      nonMod = latestMod;\n      mpending = ST_NONE;\n\n      break MM;\n    }\n  }\n\n  if (this.peekMul()) {\n    this.v<=5 && this.err(\'ver.mem.gen\');\n    if (nonMod) this.err(\'gen.has.non.modifier\');\n    st |= mpending;\n    if (st & ST_ASYNC)\n      this.ga();\n    st |= ST_GEN\n    if (latestMod) {\n      cb[latestMod.name+\'.bef\'] = latestMod[\'#c\'].bef;\n      latestMod = null;\n    }\n    else { c0 = this.c0, loc0 = this.loc0(); }\n    mpending = ST_NONE;\n    cb[\'*.bef\'] = this.cc();\n    this.next();\n  }\n\n  var memName = null, nameVal = \"\";\n  if (mpending === ST_NONE && latestMod) { // if the most recent token is a \"real\" (i.e., non-get/set) non-modifier ID\n    memName = latestMod;\n    nameVal = memName.name;\n  }\n  else {\n    switch (this.lttype) {\n    case TK_ID:\n      // if the current token is an id, either the most recent token is a \'*\' (in which case latestMod is null),\n      // or the current token is the first one we have reached since entering parseMem (in which case latestMod is, once again, null).\n      // if mpending is not ST_NONE, we will not have reached the else we are in now; the test below, then, is there for mere safety, as to err is human\n      if (latestMod !== null)\n        this.err(\'pending.id\');\n\n      st |= mpending;\n      nameVal = this.ltval;\n      memName = this.mem_id();\n      break;\n\n    case CH_LSQBRACKET:\n      if (latestMod)\n        cb[latestMod.name+\'.bef\'] = latestMod[\'#c\'].bef;\n      st |= mpending;\n      memName = this.mem_expr();\n      break;\n\n    case TK_NUM:\n      if (latestMod)\n        cb[latestMod.name+\'.bef\'] = latestMod[\'#c\'].bef;\n      st |= mpending;\n      memName = this.getLit_num();\n      break;\n\n    case CH_MULTI_QUOTE:\n    case CH_SINGLE_QUOTE:\n      if (latestMod)\n        cb[latestMod.name+\'.bef\'] = latestMod[\'#c\'].bef;\n      st |= mpending;\n      memName = this.parseString(this.lttype);\n      nameVal = memName.value;\n      break;\n\n    default:\n      if (latestMod) {\n        memName = latestMod;\n        // unnecessary because it is either static, async, set, or get\n        nameVal = memName.name;\n      }\n    }\n  }\n\n  if (memName === null) {\n    if (st & ST_GEN)\n      this.err(\'mem.gen.has.no.name\');\n    return null;\n  }\n\n  if (st & ST_CLSMEM)\n    switch (nameVal) {\n    case \'prototype\':\n      ctx |= CTX_HASPROTOTYPE;\n      break;\n\n    case \'constructor\':\n      st |= ST_CTOR;\n      break;\n    }\n  else if (this.v>5 && nameVal === \'__proto__\')\n    ctx |= CTX_HASPROTO;\n\n  \n  this.cb = cb;\n  if (this.lttype === CH_LPAREN) {\n    if (this.v <= 5) this.err(\'ver.mem.meth\');\n    var mem = this.parseMeth(memName, ctx, st);\n    if (c0 !== -1 && c0 !== mem.start) {\n      mem.start = c0;\n      mem.loc.start = loc0;\n    }\n    return mem;\n  }\n\n  if (st & (ST_STATICMEM|ST_GEN|ST_CLSMEM|ST_ASYNC|ST_ACCESSOR))\n    this.err(\'meth.paren\');\n\n  return this.parseNonMethObjMem(memName, ctx);\n};\n\ncls.parseNonMethObjMem =\nfunction(memName, ctx) {\n  var hasProto = ctx & CTX_HASPROTO, firstProto = this.first__proto__;\n  var cb = this.cb, val = null;\n  ctx &= ~CTX_HASPROTO; // unnecessary (?)\n\n  switch (this.lttype) {\n  case CH_COLON:\n    if (hasProto && firstProto)\n      this.err(\'obj.proto.has.dup\',{tn:memName});\n\n    this.spc(core(memName), \'aft\');\n    this.next();\n    val = this.parseNonSeq(PREC_NONE, ctx);\n    if (errt_track(ctx) && val.type === PAREN_NODE) {\n      // if there is no error after the parseNonSeq above\n      if (errt_ptrack(ctx) && this.pt === ERR_NONE_YET) {\n        this.pt = ERR_PAREN_UNBINDABLE;\n        this.pe = val;\n      }\n      if (errt_atrack(ctx) && this.at === ERR_NONE_YET &&\n        !this.ensureSAT(val.expr)) {\n        this.at = ERR_PAREN_UNBINDABLE;\n        this.ae = val;\n      }\n    }\n\n    var computed = memName.type === PAREN ;\n    this.inferName(core(memName), core(val), computed );\n\n    val = {\n      type: \'Property\',\n      start: memName.start,\n      key: core(memName),\n      end: val.end,\n      kind: \'init\',\n      loc: { start: memName.loc.start, end: val.loc.end },\n      computed: computed,\n      method: false,\n      shorthand: false,\n      value: core(val),\n      \'#y\': computed ? this.Y(core(memName)) : 0, \'#c\': cb\n    };\n\n    if (hasProto)\n      this.first__proto__ = val;\n\n    return val;\n\n  case TK_SIMP_ASSIG:\n    if (this.v <= 5)\n      this.err(\'mem.short.assig\');\n    if (memName.type !== \'Identifier\')\n      this.err(\'obj.prop.assig.not.id\',{tn:memName});\n    if (this.ltraw !== \'=\')\n      this.err(\'obj.prop.assig.not.assig\');\n    if (errt_noLeak(ctx)) // if the owner is not leaky\n      this.err(\'obj.prop.assig.not.allowed\');\n\n    this.validate(memName.name);\n    memName[\'#ref\'] = this.scope.refDirect_m(_m(memName.name), null);\n    val = this.parseAssignment(memName, ctx);\n    if (errt_strack(ctx) && this.st === ERR_NONE_YET) {\n      this.st = ERR_SHORTHAND_UNASSIGNED;\n      this.se = val;\n    }\n\n    break;\n\n  default:\n    if (this.v <= 5)\n      this.err(\'mem.short\');\n    if (memName.type !== \'Identifier\')\n      this.err(\'obj.prop.assig.not.id\',{tn:memName});\n    this.validate(memName.name);\n    memName[\'#ref\'] = this.scope.refDirect_m(_m(memName.name), null);\n    val = memName;\n    if (!HAS.call(cb, \'bef\') || cb.bef === null)\n      cb.bef = new Comments();\n    var cbn = CB(memName);\n    if (HAS.call(cbn, \'bef\') && cbn.bef) {\n      cb.bef.mergeWith(cbn.bef);\n      cbn.bef = null;\n    }\n    break;\n  }\n\n  return {\n    type: \'Property\',\n    key: memName,\n    start: val.start,\n    end: val.end,\n    loc: val.loc,\n    kind: \'init\',\n    shorthand: true,\n    method: false,\n    value: val,\n    computed: false,\n    \'#y\': 0, \'#c\': cb\n  };\n};\n\n\n');
resolver.set('./src/Parser/whole.js', '  import \'./parse-cond.js\';\n  import \'./count-y.js\';\n  import \'./read-char.js\';\n  import \'./assig-helpers.js\';\n  import \'./parse-top-level-expr.js\';\n  import \'./parse-do.js\';\n  import \'./parse-return.js\';\n  import \'./skip-ws.js\';\n  import \'./read-num.js\';\n  import \'./reg-surrogate.js\';\n  import \'./parse-switch-case.js\';\n  import \'./new-import.js\';\n  import \'./new-parse-expr-head.js\';\n  import \'./parse-assig.js\';\n  import \'./new-parse-stmt.js\';\n  import \'./read-op-exclam.js\';\n  import \'./core.js\';\n  import \'./read-op-and.js\';\n  import \'./new-parse-continue.js\';\n  import \'./read-id-bs.js\';\n  import \'./reg-curly.js\';\n  import \'./loc.js\';\n  import \'./reg-quantifier.js\';\n  import \'./new-parse-meth.js\';\n  import \'./reg-helpers.js\';\n  import \'./parse-class.js\';\n  import \'./parse-meta.js\';\n  import \'./parse-empty.js\';\n  import \'./new-parse-non-seq.js\';\n  import \'./new-semi.js\';\n  import \'./parse-pat-rest-new.js\';\n  import \'./read-op-add.js\';\n  import \'./read-op-or.js\';\n  import \'./read-op-mul.js\';\n  import \'./new-parse-this.js\';\n  import \'./new-parse-mem.js\';\n  import \'./read-bs.js\';\n  import \'./new-get-name.js\';\n  import \'./parse-pattern.js\';\n  import \'./reg-esc-u.js\';\n  import \'./stmt-helpers.js\';\n  import \'./parse-for.js\';\n  import \'./lautils.js\';\n  import \'./new-next.js\';\n  import \'./conv-assig.js\';\n  import \'./read-op-gt.js\';\n  import \'./read-op-mod.js\';\n  import \'./new-parse-var.js\';\n  import \'./read-ellipsis.js\';\n  import \'./reg-branch.js\';\n  import \'./parse-id.js\';\n  import \'./parse-labelled-stmt.js\';\n  import \'./parse-block.js\';\n  import \'./parse-if.js\';\n  import \'./reg-err.js\';\n  import \'./parse-aamm.js\';\n  import \'./read-op-compl.js\';\n  import \'./new-parse-tail.js\';\n  import \'./parse-tryblock.js\';\n  import \'./new-parse-literal.js\';\n  import \'./new-parse-fn-body.js\';\n  import \'./err.js\';\n  import \'./parse-dependent-block.js\';\n  import \'./reg-char.js\';\n  import \'./read-id-simple.js\';\n  import \'./parse-string.js\';\n  import \'./read-quote.js\';\n  import \'./new-parse-template.js\';\n  import \'./new-parse-new.js\';\n  import \'./reg-pattern.js\';\n  import \'./parse-switch.js\';\n  import \'./parse-catch.js\';\n  import \'./parse-throw.js\';\n  import \'./conv-arrow.js\';\n  import \'./new-export.js\';\n  import \'./reg-anchor.js\';\n  import \'./directive.js\';\n  import \'./parse-arrow.js\';\n  import \'./parse-paren.js\';\n  import \'./parse-debugger.js\';\n  import \'./surrogate.js\';\n  import \'./read-id-surrogate.js\';\n  import \'./parse-pat-assig.js\';\n  import \'./errt.js\';\n  import \'./parse-while.js\';\n  import \'./read-id-raw.js\';\n  import \'./reg-esc.js\';\n  import \'./let.js\';\n  import \'./parse-regex.js\';\n  import \'./parse-pat-array.js\';\n  import \'./testers.js\';\n  import \'./parse-arglist.js\';\n  import \'./new-parse-fn.js\';\n  import \'./parse-spread.js\';\n  import \'./read-op-min.js\';\n  import \'./parse-memname.js\';\n  import \'./comment-helpers.js\';\n  import \'./parse-obj.js\';\n  import \'./parse-program.js\';\n  import \'./scope.js\';\n  import \'./new-validate.js\';\n  import \'./parse-pat-obj-new.js\';\n  import \'./new-parse-async.js\';\n  import \'./err-listener.js\';\n  import \'./reg-class.js\';\n  import \'./parse-with.js\';\n  import \'./reg-paren.js\';\n  import \'./parse-yield.js\';\n  import \'./read-op-lt.js\';\n  import \'./regex.js\';\n  import \'./peek.js\';\n  import \'./prepare-op.js\';\n  import \'./read-esc.js\';\n  import \'./read-dot.js\';\n  import \'./read-op-xor.js\';\n  import \'./read-comment.js\';\n  import \'./new-parse-break.js\';\n  import \'./parse-array.js\';\n  import \'./new-parse-id-expr-head.js\';\n  import \'./offman.js\';\n  import \'./new-parse-list-params.js\';\n  import \'./read-op-eq.js\';\n  import \'./parse-unary.js\';\n  import \'./read-div.js\';\n');
resolver.set('./src/Parser/read-bs.js', '  import {CH_LCURLY, CH_RCURLY} from \'../other/constants.js\';\n  import {hex2num} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readBS = function() {\n  var c = this.c, s = this.src, l = s.length;\n  c++; // \\\n  if (c >= l)\n    this.err(\'u.expected.got.eof\');\n\n  c++;\n  if (s.charCodeAt(c) === CH_LCURLY)\n    return this.readBS_lcurly(c);\n\n  var val = 0;\n  var c0 = c;\n  while (c-c0 < 4) {\n    if (c >= l) {\n      this.setsimpoff(c);\n      this.err(\'hex.expected.got.eof\');\n    }\n\n    var b = hex2num(s.charCodeAt(c));\n    if (b === -1) {\n      this.setsimpoff(c);\n      this.err(\'hex.expected.got.something.else\');\n    }\n\n    val = (val<<4)|b;\n    c++;\n  }\n\n  this.setsimpoff(c);\n  return val;\n};\n\ncls.readBS_lcurly =\nfunction(c) {\n  var s = this.src, l = s.length;\n  c++; // {\n  if (c >= l) {\n    this.setsimpoff(c);\n    this.err(\'hex.expected.got.eof\');\n  }\n\n  var val = 0;\n  var b = s.charCodeAt(c);\n  while (true) {\n    b = hex2num(b);\n    if (b === -1) {\n      this.setsimpoff(c);\n      this.err(\'hex.expected.got.something.else\');\n    }\n    var t = (val<<4)|b;\n    if (t <= 1114111)\n      val = t\n    else {\n      this.setsimpoff(c);\n      this.err(\'curly.big\');\n    }\n    c++;\n    if (c >= l) {\n      this.setsimpoff(c);\n      this.err(\'curly.expected.got.eof\');\n    }\n    b = s.charCodeAt(c);\n    if (b === CH_RCURLY)\n      break;\n  }\n\n  c++; // }\n  this.setsimpoff(c);\n\n  return val;\n};\n\n\n');
resolver.set('./src/Parser/new-get-name.js', '  import {SF_STRICT, ST_DECL, ST_GEN, ST_ASYNC} from \'../other/scope-constants.js\';\n  import {arorev} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.getName_cls =\nfunction(st) {\n  var fl = this.scope.flags, name = null;\n  this.scope.flags |= SF_STRICT;\n  if (st & ST_DECL)\n    name = this.parsePat();\n  else {\n    this.validate(this.ltval);\n    if (arorev(this.ltval))\n      this.arorevErr();\n    name = this.id();\n  }\n  this.scope.flags = fl;\n  return name;\n};\n\ncls.getName_fn =\nfunction(st) {\n  switch (this.ltval) {\n  case \'yield\':\n    if ((st & ST_GEN) || this.scope.insideStrict())\n      this.err(\'fnexpr.yield\');\n    return this.id();\n\n  case \'await\':\n    if ((st & ST_ASYNC) || this.scope.insideStrict())\n      this.err(\'fnexpr.await\');\n    return this.id();\n  }\n\n  this.validate(this.ltval);\n  if (this.scope.insideStrict() && arorev(this.ltval))\n    this.arorevErr();\n\n  return this.id();\n};\n\n\n');
resolver.set('./src/Parser/parse-pattern.js', '  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {arorev} from \'../other/util.js\';\n  import {CH_LSQBRACKET, CH_LCURLY} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parsePat = \nfunction() {\n  switch (this.lttype) {\n  case TK_ID:\n    if (this.vpatCheck &&  this.patErrCheck())\n      return null;\n    this.validate(this.ltval);\n    var id = this.id();\n    this.declare(id);\n    if (this.scope.insideStrict() && arorev(id.name))\n      this.err(\'bind.arguments.or.eval\');\n\n    return id;\n\n  case CH_LSQBRACKET:\n    if (this.vpatCheck && this.patErrCheck())\n      return null;\n    return this.parsePat_array();\n\n  case CH_LCURLY:\n    if (this.vpatCheck && this.patErrCheck())\n      return null;\n    return this.parsePat_obj();\n\n  default:\n     return null;\n  }\n};\n\n\n');
resolver.set('./src/Parser/reg-esc-u.js', '  import {CH_LCURLY, CH_RCURLY} from \'../other/constants.js\';\n  import {hex2num} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\n// errors pertaining to u escapes will first check for pending semi ranges at the start of their corresponding routines\ncls.regEsc_u =\nfunction(ce) {\n  if (ce && this.regSemiRange &&\n    this.regSemiRange.max.escape !== \'hex4\' && !this.regTryCompleteSemiRange())\n    return null;\n\n  var c = this.c, s = this.src, l = this.regLastOffset;\n  c += 2; // \\u\n  if (c >= l)\n    return this.rf.u ? this.regErr_insufficientNumsAfterU() : null;\n\n  var r = s.charCodeAt(c);\n  if (this.rf.u && r === CH_LCURLY)\n    return this.regEsc_uCurly(ce);\n\n  var ch = 0, n = 0;\n  while (true) {\n    r = hex2num(r);\n    if (r === -1) {\n      this.setsimpoff(c);\n      return this.rf.u ? this.regErr_insufficientNumsAfterU() : null;\n    }\n    ch = (ch<<4)|r;\n    c++; n++;\n\n    // fail early if there is a pending semi-range and this is not a surrogate trail\n    if (ce) {\n      if ((n === 1 && r !== 0x0d) ||\n        (n === 2 && r < 0x0c))\n        if (this.testSRerr())\n          return null;\n    }\n    if (n >= 4)\n      break;\n    if (c >= l)\n      return this.rf.u ? this.regErr_insufficientNumsAfterU() : null;\n    r = s.charCodeAt(c);\n  }\n\n  if (ch >= 0x0d800 && ch <= 0x0dbff)\n    return this.regSurrogateComponent_VOKE(ch, c, \'lead\', \'hex4\');\n  if (ch >= 0x0dc00 && ch <= 0x0dfff)\n    return this.regSurrogateComponent_VOKE(ch, c, \'trail\', \'hex4\');\n\n  return this.regChar_VECI(String.fromCharCode(ch), c, ch, ce);\n};\n\ncls.regEsc_uCurly =\nfunction(ce) {\n  if (ce && this.testSRerr())\n    return null;\n\n  var c = this.c, s = this.src, l = this.regLastOffset;\n  c += 3; // \\u{\n  if (c >= l)\n    return this.regErr_insufficientNumsAfterU(ce);\n  var r = s.charCodeAt(c);\n  var ch = hex2num(r);\n  if (ch === -1) {\n    this.setsimpoff(c);\n    return this.regErr_nonNumInU(ce);\n  }\n  c++;\n  while (true) {\n    if (c >= l)\n      return this.regErr_uRCurlyNotReached();\n\n    r = s.charCodeAt(c);\n    if (r === CH_RCURLY) { c++; break; }\n\n    r = hex2num(r);\n    if (r === -1) {\n      this.setsimpoff(c);\n      return this.regErr_nonNumInU();\n    }\n\n    ch = (ch<<4)|r;\n    if (ch > 1114111) {\n      this.setsimpoff(c);\n      return this.regErr_1114111U(ch, ce);\n    }\n    c++;\n  }\n\n  if (ch >= 0x0d800 && ch <= 0x0dbff)\n    return this.regSurrogateComponent_VOKE(ch, c, \'lead\', \'{}\');\n\n  if (ch >= 0x0dc00 && ch <= 0x0dfff)\n    return this.regSurrogateComponent_VOKE(ch, c, \'trail\', \'{}\');\n\n  if (ch <= 0xffff)\n    return this.regChar_VECI(String.fromCharCode(ch), c, ch, ce);\n\n  var c0 = this.c, loc0 = this.loc();\n  this.setsimpoff(c);\n  if (!ce)\n    this.regIsQuantifiable = true;\n  return {\n    type: \'#Regex.Ho\', // Higher-order, i.e., > 0xFFFF\n    cp: ch,\n    start: c0,\n    end: c,\n    raw: s.substring(c0, c),\n    loc: { start: loc0, end: this.loc() },\n    c1: null, c2: null\n  };\n};\n\n\n\n\n');
resolver.set('./src/Parser/stmt-helpers.js', '  import {HAS} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.findLabel_m = \nfunction(mname) {\n  return HAS.call(this.labels, mname) ?\n    this.labels[mname] : null;\n};\n\ncls.testStmt = \nfunction() {\n  if (this.canBeStatement) {\n    this.canBeStatement = false;\n    return true;\n  }\n  return false;\n};\n\n// NOTE: great care has to be taken to use this.unsatisfiedLabel such that it won\'t get overwritten.\n// the recommended way is to use fixupLabels at the very beginning of relevant parse routine, or at least before calling\n// any parse routine that might overwrite this.unsatisfiedLabel\ncls.fixupLabels =\nfunction(isLoop) {\n  if (this.unsatisfiedLabel) {\n    this.unsatisfiedLabel.loop = isLoop;\n    this.unsatisfiedLabel = null;\n  }\n};\n\ncls.stmtList =\nfunction () {\n  var stmt = null, y = 0, list = [];\n  var last = null;\n  while (stmt = this.parseStatement(true)) {\n    y += this.Y0(stmt);\n    list.push(stmt);\n    last = stmt;\n  }  \n  last && this.spc(last, \'aft\');\n\n  this.yc = y;\n  return list;\n};\n\n// TODO: eliminate\ncls.fixupLabel =\nfunction(label, isLoop) {\n  label.loop = isLoop;\n};\n\n\n');
resolver.set('./src/Parser/parse-for.js', '  import {CH_LPAREN, CTX_NONE, CTX_FOR, CTX_NULLABLE, CTX_PAT, CTX_TOP, CH_RPAREN, CH_SEMI} from \'../other/constants.js\';\n  import {TK_ID, PREC_NONE} from \'../other/lexer-constants.js\';\n  import {DT_LET, DT_VAR, DT_CONST, SA_CONTINUE, SA_BREAK, SF_LOOP} from \'../other/scope-constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseFor = function() {\n  this.resvchk();\n  this.testStmt() || this.err(\'not.stmt\');\n  this.fixupLabels(true) ;\n\n  var c0 = this.c0, cb = {}, loc0 = this.loc0();\n\n  this.suc(cb, \'bef\' );\n  this.next () ;\n\n  this.suc(cb, \'for.aft\');\n  if (!this.expectT(CH_LPAREN))\n    this.err(\'for.with.no.opening.paren\',{extra:[c0,loc0]});\n\n  this.enterScope(this.scope.spawnBare());\n  var scope = this.scope;\n  var head = null, headIsExpr = false, headctx = CTX_NONE;\n  this.missingInit = false;\n\n  this.scope.enterForInit();\n  if (this.lttype === TK_ID)\n  switch ( this.ltval ) {\n  case \'let\':\n    if (this.v<5)\n      break;\n    this.canBeStatement = true;\n    head = this.parseVar(DT_LET, CTX_FOR);\n    if (!this.foundStatement) { // i.e., we got a letID\n      this.canBeStatement = false; // because parseVar actually keeps it intact, even in the event of a handleLet call\n      this.exprHead = head;\n      head = null;\n    }\n    break;\n\n  case \'var\':\n    this.canBeStatement = true;\n    head = this.parseVar(DT_VAR, CTX_FOR);\n    break;\n\n  case \'const\':\n    this.canBeStatement = true;\n    head = this.parseVar(DT_CONST, CTX_FOR);\n    break;\n  }\n\n  if (this.foundStatement) // head is a decl\n    this.foundStatement = false;\n  else {\n    headIsExpr = true;\n    head = this.parseExpr(headctx = CTX_NULLABLE|CTX_PAT|CTX_FOR);\n  }\n  this.scope.exitForInit();\n\n  var nbody = null;\n  var afterHead = null;\n\n  // TODO: core(head)\n  if (head !== null && this.lttype === TK_ID) {\n    var kind = \'ForInStatement\', iterkw = this.ltval;\n    if (iterkw === \'of\') {\n      kind = \'ForOfStatement\';\n      this.ensureVarsAreNotResolvingToCatchParams();\n    }\n    else if (iterkw === \'in\')\n      this.resvchk();\n    else \n      this.err(\'for.iter.not.of.in\',{extra:[startc,startLoc,head]});\n\n    if (headIsExpr) {\n      if (head.type === \'AssignmentExpression\')\n        this.err(\'for.in.has.init.assig\',{tn:head,extra:[startc,startLoc,kind]});\n      this.st_adjust_for_toAssig();\n      this.toAssig(head, headctx);\n      this.st_flush();\n    }\n    else if (head.declarations.length !== 1)\n      this.err(\'for.decl.multi\',{tn:head,extra:[startc,startLoc,kind]});\n    else if (this.missingInit)\n      this.missingInit = false;\n    else if (head.declarations[0].init) {\n      if (this.scope.insideStrict() || kind === \'ForOfStatement\' ||\n          this.v < 7 || head.declarations[0].id.type !== \'Identifier\' || head.kind !== \'var\')\n        this.err(\'for.in.has.decl.init\',{tn:head,extra:[startc,startLoc,kind]});\n    }\n\n    this.spc(core(head), \'aft\');\n    this.next();\n    afterHead = kind === \'ForOfStatement\' ? \n      this.parseNonSeq(PREC_NONE, CTX_TOP) :\n      this.parseExpr(CTX_TOP);\n\n    this.spc(core(afterHead), \'aft\');\n    if (!this.expectT(CH_RPAREN))\n      this.err(\'for.iter.no.end.paren\',{extra:[head,startc,startLoc,afterHead,kind]});\n\n    this.scope.actions |= (SA_CONTINUE|SA_BREAK);\n    this.scope.flags |= SF_LOOP;\n    nbody = this.parseStatement(true);\n    if (!nbody)\n      this.err(\'null.stmt\');\n\n    this.foundStatement = true;\n    this.exitScope();\n\n    return {\n      type: kind,\n      loc: { start: loc0, end: nbody.loc.end },\n      start: c0,\n      end: nbody.end,\n      body: nbody, \n      left: head,\n      right: core(afterHead),\n      \'#y\': this.Y(head,afterHead,nbody),\n      \'#scope\': scope,\n      \'#c\': cb\n    };\n  }\n\n  if (headIsExpr)\n    this.st_flush();\n  else if (head && this.missingInit)\n    this.err(\'for.decl.no.init\',{extra:[startc,startLoc,head]});\n\n  head ? this.spc(core(head), \'aft\') : this.suc(cb, \'head\');\n  if (!this.expectT(CH_SEMI))\n    this.err(\'for.simple.no.init.semi\',{extra:[startc,startLoc,head]});\n\n  afterHead = this.parseExpr(CTX_NULLABLE|CTX_TOP);\n  afterHead ? this.spc(core(afterHead), \'aft\') : this.suc(cb, \'test\');\n  if (!this.expectT(CH_SEMI))\n    this.err(\'for.simple.no.test.semi\',{extra:[startc,startLoc,head,afterHead]});\n\n  var tail = this.parseExpr(CTX_NULLABLE|CTX_TOP);\n  tail ? this.spc(core(tail), \'aft\') : this.suc(cb, \'tail\');\n  if (!this.expectT(CH_RPAREN))\n    this.err(\'for.simple.no.end.paren\',{extra:[startc,startLoc,head,afterHead,tail]});\n\n  this.scope.actions |= (SA_CONTINUE|SA_BREAK);\n  this.scope.flags |= SF_LOOP;\n\n  nbody = this.parseStatement(true);\n  if (!nbody)\n    this.err(\'null.stmt\');\n  this.foundStatement = true;\n  this.exitScope();\n\n  return {\n    type: \'ForStatement\',\n    init: head && core(head), \n    start : c0,\n    end: nbody.end,\n    test: afterHead && core(afterHead),\n    loc: { start: loc0, end: nbody.loc.end },\n    body: nbody,\n    update: tail && core(tail),\n    \'#scope\': scope,\n    \'#c\': cb,\n    \'#y\': this.Y0(head,afterHead,tail)+this.Y(nbody)\n  };\n};\n\ncls.ensureVarsAreNotResolvingToCatchParams = function() {\n  return;\n};\n\n\n');
resolver.set('./src/Parser/lautils.js', '  import {cls} from \'./cls.js\';\n\ncls.expectT =\nfunction(lttype) {\n  if (this.lttype === lttype) {\n    this.next();\n    return true;\n  }\n  return false;\n};\n\ncls.rw =\nfunction(c,li,col,luo) { this.c = c; this.li = li; this.col = col; this.luo = luo; };\n\n\n');
resolver.set('./src/Parser/new-next.js', '  import {TK_EOF} from \'../other/lexer-constants.js\';\n  import {isIDHead, isNum} from \'../other/ctype.js\';\n  import {CH_MIN, CH_ADD, CH_MULTI_QUOTE, CH_SINGLE_QUOTE, CH_SINGLEDOT, CH_EQUALITY_SIGN, CH_LESS_THAN, CH_GREATER_THAN, CH_MUL, CH_MODULO, CH_EXCLAMATION, CH_COMPLEMENT, CH_OR, CH_AND, CH_XOR, CH_BACK_SLASH, CH_DIV} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.next =\nfunction() {\n\n  this.skipWS();\n  if (this.c >= this.src.length) {\n    this.lttype = TK_EOF;\n    this.ltraw = \'<<EOF>>\';\n    return;\n  }\n\n  this.c0 = this.c;\n  this.li0 = this.li;\n  this.col0 = this.col;\n\n  var ch = this.src.charCodeAt(this.c);\n  if (isIDHead(ch))\n    return this.readID_simple();\n  if (isNum(ch))\n    return this.readNum_raw(ch);\n\n  switch (ch) {\n  case CH_MIN:\n    return this.readOp_min();\n  case CH_ADD:\n    return this.readOp_add();\n  case CH_MULTI_QUOTE:\n    return this.read_multiQ();\n  case CH_SINGLE_QUOTE:\n    return this.read_singleQ();\n  case CH_SINGLEDOT:\n    return this.read_dot();\n  case CH_EQUALITY_SIGN:\n    return this.readOp_eq();\n  case CH_LESS_THAN:\n    return this.readOp_lt();\n  case CH_GREATER_THAN:\n    return this.readOp_gt();\n  case CH_MUL:\n    return this.readOp_mul();\n  case CH_MODULO:\n    return this.readOp_mod();\n  case CH_EXCLAMATION:\n    return this.readOp_exclam();\n  case CH_COMPLEMENT:\n    return this.readOp_compl();\n  case CH_OR:\n    return this.readOp_or();\n  case CH_AND:\n    return this.readOp_and();\n  case CH_XOR:\n    return this.readOp_xor();\n  case CH_BACK_SLASH:\n    return this.readID_bs();\n  case CH_DIV:\n    return this.readDiv();\n\n  default:\n    if (ch >= 0x0D800 && ch <= 0x0DBFF)\n      return this.readID_surrogate(ch);\n\n    return this.readSingleChar();\n  }\n};\n\ncls.c0_to_c =\nfunction() { return this.src.substring(this.c0,this.c); };\n\n\n');
resolver.set('./src/Parser/conv-assig.js', '  import {arorev, core} from \'../other/util.js\';\n  import {ERR_ARGUMENTS_OR_EVAL_DEFAULT, ERR_NONE_YET, ERR_ARGUMENTS_OR_EVAL_ASSIGNED} from \'../other/error-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.toAssig = function(head, context) {\n  if (head === this.ao)\n    this.throwTricky(\'a\', this.at, this.ae)\n\n  var i = 0, list = null;\n  switch (head.type) {\n  case \'Identifier\':\n    if (this.scope.insideStrict() && arorev(head.name)) {\n      if (this.st === ERR_ARGUMENTS_OR_EVAL_DEFAULT)\n        this.st = ERR_NONE_YET;\n      if (this.st === ERR_NONE_YET) {\n        this.st = ERR_ARGUMENTS_OR_EVAL_ASSIGNED;\n        this.se = head;\n      }\n//    if (context & CTX_NO_SIMPLE_ERR)\n//      this.currentExprIsSimple();\n    }\n    return;\n\n  case \'MemberExpression\':\n    return;\n\n  case \'ObjectExpression\':\n    if (this.v <= 5) this.err(\'ver.pat.obj\',{tn:head});\n    i = 0; list = head.properties;\n    while (i < list.length)\n      this.toAssig(list[i++], context);\n    head.type = \'ObjectPattern\';\n    return;\n\n  case \'ArrayExpression\':\n    if (this.v <= 5) this.err(\'ver.pat.arr\',{tn:head});\n    i = 0; list = head.elements;\n    while (i < list.length) {\n      list[i] && this.toAssig(list[i], context);\n      i++ ;\n    }\n    head.type = \'ArrayPattern\';\n    return;\n\n  case \'AssignmentExpression\':\n    // TODO: operator is the one that must be pinned,\n    // but head is pinned currently\n    if (head.operator !== \'=\')\n      this.err(\'complex.assig.not.pattern\');\n\n    // TODO: the left is not re-checked for errors\n    // because it is already an assignable pattern;\n    // this requires keeping track of the latest\n    // ea error, in order to re-record it if it is\n    // also the first error in the current pattern\n    if (this.st === ERR_ARGUMENTS_OR_EVAL_DEFAULT &&\n       head === this.so) {\n      this.st = ERR_NONE_YET;\n      this.toAssig(this.se);\n    }\n\n    head.type = \'AssignmentPattern\';\n    delete head.operator;\n    return;\n\n  case \'SpreadElement\':\n    if (head.argument.type === \'AssignmentExpression\')\n      this.err(\'rest.arg.not.valid\',{tn:head});\n    this.toAssig(head.argument, context);\n    head.type = \'RestElement\';\n    return;\n\n  case \'Property\':\n    this.toAssig(head.value, context);\n    return;\n\n  default:\n    this.err(\'not.assignable\',{tn:core(head)});\n \n  }\n};\n\n\n\n\n');
resolver.set('./src/Parser/read-op-gt.js', '  import {CH_EQUALITY_SIGN, CH_GREATER_THAN} from \'../other/constants.js\';\n  import {PREC_COMP, TK_SIMP_BINARY, TK_OP_ASSIG, PREC_SH} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readOp_gt =\nfunction() {\n  var c = this.c; c++; // \'>\';\n  var ch = this.scat(c);\n\n  if (ch === CH_EQUALITY_SIGN) {\n    c++;\n    this.prec = PREC_COMP;\n    this.lttype = TK_SIMP_BINARY;\n    this.ltraw = \'>=\';\n  }\n  else if (ch === CH_GREATER_THAN) {\n    c++;\n    ch = this.scat(c);\n    if (ch === CH_EQUALITY_SIGN) {\n      c++;\n      this.lttype = TK_OP_ASSIG;\n      this.ltraw = \'>>=\';\n    }\n    else if (ch === CH_GREATER_THAN) {\n      c++;\n      ch = this.scat(c);\n      if (ch === CH_EQUALITY_SIGN) {\n        c++;\n        this.lttype = TK_OP_ASSIG;\n        this.ltraw = \'>>>=\';\n      }\n      else {\n        this.lttype = TK_SIMP_BINARY;\n        this.prec = PREC_SH;\n        this.ltraw = \'>>>\';\n      }\n    }\n    else {\n      this.lttype = TK_SIMP_BINARY;\n      this.prec = PREC_SH;\n      this.ltraw = \'>>\';\n    }\n  }\n  else {\n    this.lttype = TK_SIMP_BINARY;\n    this.prec = PREC_COMP;\n    this.ltraw = \'>\';\n  }\n\n  this.setsimpoff(c);\n};\n\n\n');
resolver.set('./src/Parser/read-op-mod.js', '  import {CH_EQUALITY_SIGN} from \'../other/constants.js\';\n  import {TK_OP_ASSIG, TK_SIMP_BINARY, PREC_MUL} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readOp_mod =\nfunction() {\n  var c = this.c; c++;\n  var ch = this.scat(c);\n\n  if (ch === CH_EQUALITY_SIGN) {\n    this.lttype = TK_OP_ASSIG;\n    c++;\n    this.ltraw = \'%=\';\n  }\n  else {\n    this.lttype = TK_SIMP_BINARY;\n    this.prec = PREC_MUL;\n    this.ltraw = \'%\';\n  }\n\n  this.setsimpoff(c);\n};\n\n\n');
resolver.set('./src/Parser/new-parse-var.js', '  import {DT_LET, DT_VAR, DT_CONST} from \'../other/scope-constants.js\';\n  import {CTX_FOR, PE_NO_NONVAR, PE_NO_LABEL, CTX_TOP, CH_COMMA} from \'../other/constants.js\';\n  import {PREC_NONE} from \'../other/lexer-constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseVar =\nfunction(dt, ctx) {\n  if (!this.testStmt()) {\n    if (dt === DT_LET)\n      return this.handleLet(this.id());\n    this.err(\'not.stmt\');\n  }\n\n  var kind = this.ltval;\n  var letID = dt === DT_LET ? this.id() : null;\n  var c0 = letID ? letID.start : this.c0;\n  var loc0 = letID ? letID.loc.start : this.loc0();\n  var vpat = null;\n\n  var y = 0;\n\n  var cb = null;\n  if (letID) \n    cb = letID[\'#c\'];\n  else { \n    cb = {}; this.suc(cb, \'bef\');\n    this.next();\n  }\n\n  ctx &= CTX_FOR;\n\n  if (!letID || !ctx || !this.peekID(\'in\')) {\n    this.setPatCheck(dt !== DT_VAR);\n    this.declMode = dt|this.cutEx();\n    vpat = this.parsePat();\n\n    if (vpat === null)\n    switch (this.vpatErr) {\n    case PE_NO_NONVAR:\n      this.err(\'lexical.decl.not.in.block\',\n        {c0:c0,loc0:loc0,extra:kind});\n      break;\n\n    case PE_NO_LABEL:\n      this.err(\'decl.label\',{c0:c0,loc0:loc0});\n      break;\n    }\n  }\n\n  if (vpat === null) {\n    if (letID) {\n      this.canBeStatement = true; // restore it to the value it had when parseVar was initially called\n      return this.handleLet(letID);\n    }\n    this.err(\'var.has.no.declarators\');\n  }\n\n  // this.unsatisfiedLabel is intact -- there has been no parsing, only lexing actually\n  this.fixupLabels(false);\n\n  var isConst = dt === DT_CONST, mi = false;\n\n  var list = [], last = null;\n  while (true) {\n    var init = null;\n    if (this.peekEq()) {\n      this.spc(vpat, \'aft\');\n      this.next();\n      init = this.parseNonSeq(PREC_NONE, ctx|CTX_TOP);\n    }\n    else if (isConst || vpat.type !== \'Identifier\') {\n      !(ctx & CTX_FOR) && this.err(\'const.has.no.init\');\n      list.length && this.err(\'missing.init\');\n      mi = true;\n    }\n    var ioh = init || vpat;\n\n    var y0 = this.Y(vpat)+(init ? this.Y(init) : 0);\n    y += y0;\n\n    init && this.inferName(vpat, core(init), false);\n    list.push(last = {\n      type: \'VariableDeclarator\',\n      id: vpat,\n      start: vpat.start,\n      end: ioh.end,\n      loc: {\n        start: vpat.loc.start,\n        end: ioh.loc.end \n      },\n      init: init && core(init),\n      \'#y\': y0, \'#c\': {}\n    });\n\n    if (mi || this.lttype !== CH_COMMA)\n      break;\n\n    this.spc(last, \'aft\');\n    this.next();\n\n    vpat = this.parsePat();\n    vpat || this.err(\'var.has.an.empty.decltor\');\n  }\n\n  var lastItem = list[list.length-1];\n  var ec = -1, eloc = null;\n\n  if (!(ctx & CTX_FOR)) {\n    this.semi(last[\'#c\'], \'aft\') || this.err(\'no.semi\');\n    ec = this.semiC || lastItem.end;\n    eloc = this.semiLoc || lastItem.loc.end;\n  } else {\n    ec = lastItem.end;\n    eloc = lastItem.loc.end;\n  }\n\n  this.missingInit = mi;\n\n  this.foundStatement = true;\n  return {\n    type: \'VariableDeclaration\',\n    kind: kind,\n    start: c0,\n    declarations: list,\n    end: ec,\n    loc: { start: loc0, end: eloc },\n    \'#c\': cb,\n    \'#y\': y,\n  };\n};\n\n\n');
resolver.set('./src/Parser/read-ellipsis.js', '  import {CH_SINGLEDOT} from \'../other/constants.js\';\n  import {TK_ELLIPSIS} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.read_ellipsis =\nfunction() {\n  var c = this.c+2, s = this.src;\n  if (c>=s.length || s.charCodeAt(c) !== CH_SINGLEDOT) {\n    this.setsimpoff(c);\n    this.err(\'unexpected.dot\');\n  }\n\n  this.setsimpoff(c+1);\n  this.lttype = TK_ELLIPSIS;\n};\n\n\n');
resolver.set('./src/Parser/reg-branch.js', '  import {isCharSeq} from \'../other/util.js\';\n  import {isLead, isTrail, uAkin} from \'../other/regex-util.js\';\n  import {CH_LSQBRACKET, CH_LPAREN, CH_LCURLY, ASSERT, CH_RCURLY, CH_BACK_SLASH, CH_$, CH_XOR, CH_QUESTION, CH_ADD, CH_MUL, CH_OR, CH_RPAREN, CH_SINGLEDOT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.regBranch =\nfunction() {\n  this.regErr = null;\n  this.regIsQuantifiable = false;\n\n  var elem = this.regBareElem();\n  if (elem === null)\n    return null;\n\n  var elements = [];\n  do {\n    if (elem !== this.regLastBareElem) {\n      elem = this.regTryMix(elements, elem);\n      if (this.regIsQuantifiable) {\n        this.regIsQuantifiable = false;\n        if (this.regPendingBQ || this.regPendingCQ || \n          (!isCharSeq(elem) && this.regPrepareQ()))\n          elem = this.regQuantify(elem);\n      }\n      elements.push(elem);\n      this.regLastBareElem = elem; // reuse CharSeq\n    }\n\n    this.regIsQuantifiable = false;\n    elem = this.regBareElem();\n    if (this.regErr)\n      return null;\n  } while (elem);\n\n  var lastElem = elements[elements.length-1];\n  return {\n    type: \'#Regex.Branch\',\n    elements: elements,\n    start: elements[0].start,\n    end: lastElem.end,\n    loc: { start: elements[0].loc.start, end: lastElem.loc.end }\n  };\n};\n\ncls.regTryMix =\nfunction(list, elem) {\n  if (list.length === 0) \n    return elem;\n  var last = list[list.length-1];\n  if (isLead(last) && isTrail(elem)) {\n    last.next = elem;\n    if (this.regexFlags.u && uAkin(last, elem)) {\n      list.pop();\n      this.regIsQuantifiable = true;\n      return this.regMakeSurrogate(last, elem);\n    }\n  }\n  return elem;\n};\n\ncls.regBareElem =\nfunction() {\n  var c = this.c, s = this.src, l = this.regLastOffset;\n  if (c >= l)\n    return null;\n\n  var elem = null;\n  var c0 = this.c, li0 = this.li, col0 = this.col, luo0 = this.luo;\n  switch (s.charCodeAt(c)) {\n  case CH_LSQBRACKET:\n    return this.regClass();\n  case CH_LPAREN:\n    return this.regParen();\n  case CH_LCURLY:\n    if (this.rf.u)\n      return this.regErr_looseLCurly();\n    if (!this.regCurlyChar) {\n      elem = this.regCurlyQuantifier();\n      if (elem)\n        return this.regErr_looseCurlyQuantifier(elem);\n      if (this.regErr) // shouldn\'t hold\n        return null;\n    }\n    ASSERT.call(this, this.regCurlyChar, \'rcc\' );\n    this.regCurlyChar = false;\n    // regCurlyQuantifier does the rw itself\n    elem = this.regChar(false); // \'{\'\n    return elem;\n  case CH_RCURLY:\n    return this.regErr_looseRCurly();\n  case CH_BACK_SLASH:\n    return this.regEsc(false);\n  case CH_$:\n  case CH_XOR:\n    return this.regUnitAssertion();\n  case CH_QUESTION:\n  case CH_ADD:\n  case CH_MUL:\n    return this.regErr_looseQuantifier();\n  case CH_OR:\n  case CH_RPAREN:\n    return null;\n  case CH_SINGLEDOT:\n    return this.regDot();\n  default:\n    return this.regChar(false);\n  }\n};\n\n\n');
resolver.set('./src/Parser/parse-id.js', '  import {CVTZ_NONE} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.id = function() {\n  var id = {\n    type: \'Identifier\',\n    name: this.ltval,\n    start: this.c0,\n    end: this.c,\n    loc: {\n      start: this.loc0(),\n      end: this.loc() },\n    raw: this.ltraw,\n    \'#ref\': null,\n    \'#cvtz\': CVTZ_NONE,\n    \'#c\': {},\n  };\n  this.spc(id, \'bef\');\n  this.next() ;\n  return id;\n};\n\n\n');
resolver.set('./src/Parser/parse-labelled-stmt.js', '  import {_m} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseLabel = function(label, allowNull) {\n  var ref = this.scope.findRefAny_m(_m(label.name));\n  ref.d--;\n  this.spc(label, \'aft\');\n  this.next();\n  var mname = _m(label.name);\n  var ex = this.findLabel_m(mname); // existing label\n  ex && this.err(\'label.is.a.dup\',{tn:label,extra:ex});\n\n  this.labels[mname] =\n    this.unsatisfiedLabel ?\n    this.unsatisfiedLabel :\n    this.unsatisfiedLabel = { loop: false };\n\n  var stmt = this.parseStatement(allowNull);\n  this.labels[mname] = null;\n\n  return {\n    type: \'LabeledStatement\',\n    label: label,\n    start: label.start,\n    end: stmt.end,\n    loc: { start: label.loc.start, end: stmt.loc.end },\n    body: stmt,\n    \'#y\': this.Y0(stmt), \'#c\': {}\n  };\n};\n\n\n');
resolver.set('./src/Parser/parse-block.js', '  import {CH_RCURLY} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseBlock = function () {\n  this.fixupLabels(false);\n\n  this.enterScope(this.scope.spawnBlock()); \n  var scope = this.scope;\n\n  var c0 = this.c0, loc0 = this.loc0();\n\n  var cb = {}; this.suc(cb, \'bef\' );\n  this.next(); // \'{\'\n\n  var n = {\n    type: \'BlockStatement\',\n    body: this.stmtList(),\n    start: c0,\n    end: this.c,\n    loc: {\n      start: loc0, \n      end: this.loc() }, \n    \'#y\': this.yc,\n    \'#scope\': scope, \n    \'#c\': cb,\n    \'#lead\': null\n  };\n\n  this.suc(cb, \'inner\');\n  if (!this.expectT(CH_RCURLY))\n    this.err(\'block.unfinished\');\n\n  this.exitScope(); \n\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/parse-if.js', '  import {SF_INSIDEIF} from \'../other/scope-constants.js\';\n  import {CH_LPAREN, CTX_TOP, CH_RPAREN} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseIf = function () {\n  this.resvchk();\n  !this.testStmt() && this.err(\'not.stmt\');\n  this.fixupLabels(false);\n\n  this.enterScope(this.scope.spawnBare());\n  var ifScope = this.scope; \n  this.scope.flags |= SF_INSIDEIF;\n\n  var c0 = this.c0, cb = {}, loc0 = this.loc0();\n\n  this.suc(cb, \'bef\');\n  this.next(); // \'if\'\n\n  this.suc(cb, \'aft.if\');\n  if (!this.expectT(CH_LPAREN))\n    this.err(\'if.has.no.opening.paren\');\n\n  var cond = core(this.parseExpr(CTX_TOP));\n\n  this.spc(cond, \'aft\');\n  if (!this.expectT(CH_RPAREN))\n    this.err(\'if.has.no.closing.paren\');\n\n  var nbody = this.parseStatement(false);\n  this.exitScope(); \n\n  var alt = null, elseScope = null;\n  if (this.lttype === TK_ID && this.ltval === \'else\') {\n    this.resvchk();\n    this.spc(nbody, \'aft\');\n    this.next(); // \'else\'\n    this.enterScope(this.scope.spawnBare());\n    elseScope = this.scope; \n    alt = this.parseStatement(false);\n    this.exitScope();\n  }\n\n  this.foundStatement = true;\n  return {\n    type: \'IfStatement\',\n    test: cond,\n    start: c0,\n    end: (alt||nbody).end,\n    loc: {\n      start: loc0,\n      end: (alt||nbody).loc.end },\n    consequent: nbody,\n    alternate: alt,\n    \'#ifScope\': ifScope,\n    \'#y\': this.Y(cond,nbody)+this.Y0(alt),\n    \'#c\': cb,\n    \'#elseScope\': elseScope\n  };\n};\n\n\n');
resolver.set('./src/Parser/reg-err.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.regErr_nonexistentRef =\nfunction(ref) {\n  return this.regErrNew(\'nonexistent-ref\', this.loc(), { ref: ref });\n};\n\ncls.regErr_looseLCurly =\nfunction() {\n  return this.regErrNew(\'loose-lcurly\', this.loc());\n};\n\ncls.regErr_looseRCurly =\nfunction() {\n  return this.regErrNew(\'loose-rcurly\', this.loc());\n};\n\ncls.regErr_invalidUEsc =\nfunction(esc) {\n  return this.regErrNew(\'invalid-uesc\', this.loc(), { esc: esc });\n};\n\ncls.regErr_classUnfinished =\nfunction() {\n  return this.regErrNew(\'class-unfinished\', this.loc());\n};\n\ncls.regErr_looseCurlyQuantifier =\nfunction(elem) {\n  return this.regErrNew(\'loose-cq\', elem.loc.start);\n};\n\ncls.regErr_trailSlash =\nfunction() {\n  return this.regErrNew(\'trail-slash\', this.loc());\n};\n\ncls.regErr_hexEOF =\nfunction() {\n  return this.regErrNew(\'hex-eof\', this.loc());\n};\n\ncls.regErr_hexEscNotHex =\nfunction() {\n  return this.regErrNew(\'hex-not\', this.loc());\n};\n\ncls.regErr_minBiggerThanMax =\nfunction(min, max) {\n  return this.regErrNew(\'min-bigger-than-max\', this.loc(), { min: min, max: max });\n};\n\ncls.regErr_controlAZaz =\nfunction(esc) {\n  return this.regErrNew(\'control-AZaz\', this.loc(), { esc: esc });\n};\n\ncls.regErr_controlEOF =\nfunction() {\n  return this.regErrNew(\'control-eof\', this.loc());\n};\n\ncls.regErr_insufficientNumsAfterU =\nfunction(ce) {\n  if (ce && this.testSRerr()) return null;\n  return this.regErrNew(\'insufficient-nums-after-u\', this.loc());\n};\n\ncls.regErr_nonNumInU =\nfunction(ce) {\n  if (ce && this.testSRerr()) return null;\n  return this.regErrNew(\'non-num-in-u\', this.loc());\n};\n\ncls.regErr_looseQuantifier =\nfunction() {\n  return this.regErrNew(\'loose-quantifier\', this.loc());\n};\n\ncls.regErr_uRCurlyNotReached =\nfunction(ce) {\n  if (ce && this.testSRerr()) return null;\n  return this.regErrNew(\'u-rcurly\', this.loc());\n};\n\ncls.regErr_1114111U =\nfunction(ch, ce) {\n  if (ce && this.testRSerr()) return null;\n  return this.regErrNew(\'1114111-u\', this.loc(), { value: ch });\n};\n\ncls.regErr_curlyMinIsBiggerThanMax =\nfunction(min, max) {\n  return this.regErrNew(\'curly-min-is-bigger-max\', this.loc(), { min: min, max: max });\n};\n\ncls.regErr_unfinishedParen =\nfunction(n) {\n  return this.regErrNew(\'rparen-missing\', this.loc(), { element: n });\n};\n\ncls.regErr_invalidCharAfterQuestionParen =\nfunction(ch) {\n  return this.regErrNew(\'qparen\', this.loc(), { ch: ch });\n};\n\ncls.regErrNew =\nfunction() {\n  var kind = arguments[0];\n  var eloc = (arguments.length > 1 && arguments[1]) || this.loc();\n  var ctx = (arguments.length > 2 && arguments[2]) || null;\n\n  ASSERT.call(this, this.regErr === null, \'regErr\');\n  this.regErr = {\n    type: \'#Regex.Err\',\n    kind: kind,\n    context: ctx,\n    position: this.c,\n    loc: eloc\n  };\n  return null;\n};\n\n\n');
resolver.set('./src/Parser/parse-aamm.js', '  import {CTX_FOR} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseUpdate = function(arg, ctx) {\n  var c = 0, loc = null, u = this.ltraw;\n  if (arg === null) {\n    c = this.c0;\n    loc = this.loc0();\n    var uc = {}; this.suc(uc, \'bef\');\n    this.next() ;\n    arg = this.parseExprHead(ctx & CTX_FOR);\n    if (arg === null)\n      this.err(\'unexpected.lookahead\');\n\n    arg = this.parseTail(arg);\n    if (!this.ensureSAT(core(arg)))\n      this.err(\'incdec.pre.not.simple.assig\',{tn:core(arg)});\n\n    return {\n      type: \'UpdateExpression\', operator: u,\n      start: c, end: arg.end, argument: core(arg),\n      loc: { start: loc, end: arg.loc.end }, \'#c\': uc,\n      prefix: true, \'#y\': this.Y(arg)\n    };\n  }\n\n  this.spc(core(arg), \'aft\');\n  if (!this.ensureSAT(core(arg)))\n    this.err(\'incdec.post.not.simple.assig\',{tn:core(arg)});\n\n  c  = this.c;\n  loc = {\n    start: arg.loc.start,\n    end: { line: this.li, column: this.col }\n  };\n  this.next() ;\n  return {\n    type: \'UpdateExpression\', operator: u,\n    start: arg.start, end: c,\n    argument: core(arg), loc: loc, \'#c\': {},\n    prefix: false, \'#y\': this.Y(arg)\n  };\n};\n\n\n');
resolver.set('./src/Parser/read-op-compl.js', '  import {TK_UNARY} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readOp_compl =\nfunction() {\n  this.lttype = TK_UNARY;\n  this.ltraw = \'~\';\n  this.setsimpoff(this.c+1);\n};\n\n\n');
resolver.set('./src/Parser/new-parse-tail.js', '  import {_m} from \'../other/scope-util.js\';\n  import {CH_SINGLEDOT, CH_LSQBRACKET, CH_LPAREN, CH_BACKTICK, CTX_NONE, CH_RSQBRACKET, CH_RPAREN} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {TK_ID, PREC_NONE} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseTail =\nfunction(head) {\n  if (head.type === \'Identifier\')\n    head[\'#ref\'] = this.scope.refDirect_m(_m(head.name), null);\n\n  switch (this.lttype) {\n  case CH_SINGLEDOT:\n  case CH_LSQBRACKET:\n  case CH_LPAREN:\n  case CH_BACKTICK:\n    this.st_flush();\n  }\n\n  var argloc = null, cb = null;\n  var inner = core(head), elem = null;\n\n  LOOP:\n  while (true) {\n    switch (this.lttype) {\n    case CH_SINGLEDOT:\n      this.spc(inner, \'aft\');\n      argloc = this.loc0();\n      this.next();\n      if (this.lttype !== TK_ID)\n        this.err(\'mem.name.not.id\');\n      elem = this.mem_id();\n      if (elem === null)\n        this.err(\'mem.id.is.null\');\n      head = inner = {\n        type: \'MemberExpression\',\n        property: elem,\n        start: head.start,\n        end: elem.end,\n        object: inner,\n        loc: {\n          start: head.loc.start,\n          end: elem.loc.end },\n        computed: false,\n        \'#y\': this.Y(head), \'#acloc\': argloc, \'#c\': {}\n      };\n      continue;\n\n    case CH_LSQBRACKET:\n      this.spc(inner, \'aft\');\n      argloc = this.loc0();\n      this.next();\n      elem = this.parseExpr(PREC_NONE, CTX_NONE);\n      head = inner = {\n        type: \'MemberExpression\',\n        property: core(elem),\n        start: head.start,\n        end: this.c,\n        object: inner,\n        loc: {\n          start: head.loc.start,\n          end: this.loc() },\n        computed: true,\n        \'#y\': this.Y(head)+this.Y(elem), \'#acloc\': argloc, \'#c\': {}\n      };\n      this.spc(core(elem), \'aft\');\n      if (!this.expectT(CH_RSQBRACKET))\n        this.err(\'mem.unfinished\');\n      continue;\n\n    case CH_LPAREN:\n      this.spc(inner, \'aft\');\n      elem = this.parseArgList();\n      argloc = this.argploc; this.argploc = null;\n      cb = {};\n      this.suc(cb, \'inner\'); // a(/* inner */); b(e, /* inner */)\n      head = inner = {\n        type: \'CallExpression\',\n        callee: inner,\n        start: head.start,\n        end: this.c,\n        arguments: elem,\n        loc: {\n          start: head.loc.start,\n          end: this.loc() },\n        \'#y\': this.Y(head)+this.y, \'#argloc\': argloc, \'#c\': cb\n      };\n      if (!this.expectT(CH_RPAREN))\n        this.err(\'call.args.is.unfinished\');\n      continue;\n\n    case CH_BACKTICK:\n      this.spc(inner, \'aft\');\n      elem = this.parseTemplate();\n      head = inner = {\n        type: \'TaggedTemplateExpression\',\n        quasi: elem,\n        start: head.start,\n        end: elem.end,\n        loc: {\n          start: head.loc.start,\n          end: elem.loc.end },\n        tag: inner,\n        \'#c\': {}, \'#y\': this.Y(head)+this.Y(elem)\n      };\n      continue;\n\n    default: break LOOP;\n    }\n  }\n\n  return head;\n};\n\n\n');
resolver.set('./src/Parser/parse-tryblock.js', '  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseTryStatement = function () {\n  this.resvchk();\n  this.testStmt() || this.err(\'not.stmt\');\n  this.fixupLabels(false);\n\n  var c0 = this.c0, cb = {}, loc0 = this.loc0();\n\n  this.suc(cb, \'bef\');\n  this.next(); // \'try\'\n\n  this.enterScope(this.scope.spawnBlock()); \n\n  var tryBlock = this.parseDependent(\'try\');\n  tryBlock[\'#scope\'] = this.scope;\n  var tryScope = this.scope; \n\n  this.exitScope(); \n\n  var finBlock = null, catBlock  = null;\n  if (this.lttype === TK_ID && this.ltval === \'catch\')\n    catBlock = this.parseCatchClause();\n\n  var finScope = null;\n  if (this.lttype === TK_ID && this.ltval === \'finally\') {\n    this.resvchk();\n    this.suc(cb, \'finally.bef\') ;\n    this.next();\n    this.enterScope(this.scope.spawnBlock()); \n    finScope = this.scope;\n    finBlock = this.parseDependent(\'finally\');\n    finBlock[\'#scope\'] = this.scope;\n    this.exitScope(); \n  }\n\n  var finOrCat = finBlock || catBlock;\n\n  finOrCat || this.err(\'try.has.no.tail\');\n  this.foundStatement = true;\n\n  return  {\n    type: \'TryStatement\',\n    block: tryBlock,\n    start: c0,\n    end: finOrCat.end,\n    handler: catBlock,\n    finalizer: finBlock,\n    loc: {\n      start: loc0,\n      end: finOrCat.loc.end },\n    \'#y\': this.Y(tryBlock)+this.Y0(catBlock,finBlock),\n    \'#finScope\': finScope,\n    \'#c\': cb,\n    \'#tryScope\': tryScope,\n\n  };\n};\n\n\n');
resolver.set('./src/Parser/new-parse-literal.js', '  import {cls} from \'./cls.js\';\n\ncls.getLit_true = function() {\n  this.resvchk();\n  var cb = {}; this.suc(cb, \'bef\' );\n  var n = {\n    type: \'Literal\', value: true,\n    start: this.c0, end: this.c,\n    loc: { start: this.loc0(), end: this.loc() },\n    raw: this.ltraw, \'#c\': cb\n  };\n  this.next();\n  return n;\n};\n\ncls.getLit_false = function() {\n  this.resvchk();\n  var cb = {}; this.suc(cb, \'bef\');\n  var n = {\n    type: \'Literal\', value: false,\n    start: this.c0, end: this.c,\n    loc: { start: this.loc0(), end: this.loc() },\n    raw: this.ltraw, \'#c\': cb\n  };\n  this.next();\n  return n;\n};\n\ncls.getLit_null = function() {\n  this.resvchk();\n  var cb = {}; this.suc(cb, \'bef\');\n  var n = {\n    type: \'Literal\', value: null,\n    start: this.c0, end: this.c,\n    loc: { start: this.loc0(), end: this.loc() },\n    raw: this.ltraw, \'#c\': cb\n  };\n  this.next();\n  return n;\n};\n\ncls.getLit_num = function () {\n  var cb = {}; this.suc(cb, \'bef\' );\n  var n = {\n    type: \'Literal\', value: this.ltval,\n    start: this.c0, end: this.c,\n    loc: { start: this.loc0(), end: this.loc() },\n    raw: this.ltraw, \'#c\': cb\n  };\n  this.next();\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/new-parse-fn-body.js', '  import {CH_LCURLY, CH_RCURLY} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseFunBody =\nfunction() {\n  if (this.lttype !== CH_LCURLY)\n    this.err(\'fun.body.not.a.curly\');\n\n  var c0 = this.c0;\n  var loc0 = this.loc0();\n\n  var cb = {}; this.suc(cb, \'bef\' );\n  this.next(); // \'{\'\n\n  this.enterPrologue();\n  var list = this.stmtList();\n\n  this.suc(cb, \'inner\');\n  var n = {\n    type : \'BlockStatement\',\n    body: list,\n    start: c0,\n    end: this.c,\n    loc: { \n      start: loc0,\n      end: this.loc() },\n    \'#y\': this.yc, \'#c\': cb\n  };\n\n  if (!this.expectT(CH_RCURLY))\n    this.err(\'fun.body.is.unfinished\');\n\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/err.js', '  import {HAS} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.err = function(errorType, errParams) {\n  errParams = this.normalize(errParams);\n  return this.errorListener.onErr(errorType, errParams);\n};\n\ncls.normalize = function(err) {\n  // normalized err\n  var loc0 = { li: this.li0, col: this.col0 },\n      loc = { li: this.li, col: this.col };\n\n  var e = {\n    cur0: { c: this.c0, loc: loc0 },\n    cur: { c: this.c, loc: loc },\n    tn: null,\n    parser: this,\n    extra: null\n  };\n  \n  if (err) {\n    if (err.tn) {\n      var tn = err.tn;\n      e.tn = tn;\n\n      if (HAS.call(tn,\'start\')) e.cur0.c = tn.start;\n      if (HAS.call(tn,\'end\')) e.cur.c = tn.end;\n      if (tn.loc) {\n\tif (HAS.call(tn.loc, \'start\')) {\n          e.cur0.loc.li = tn.loc.start.line;\n          e.cur0.loc.col =  tn.loc.start.column;\n        }\n        if (HAS.call(tn.loc, \'start\')) {\n          e.cur.loc.li = tn.loc.end.line;\n          e.cur.loc.col = tn.loc.end.column;\n        }\n      }\n    }\n    if (err.loc0) {\n      var loc0 = err.loc0;\n      e.cur.loc.li = loc0.line;\n      e.cur.loc.col = loc0.column;\n    }\n    if (err.loc) {\n      var loc = err.loc;\n      e.cur.loc.li = loc.line;\n      e.cur.loc.col = loc.column;\n    }\n\n    if (HAS.call(err,\'c0\'))\n      e.cur0.c = err.c0;\n    \n    if (HAS.call(err,\'c\'))\n      e.cur.c = err.c;\n\n    if (HAS.call(err, \'extra\')) \n      e.extra = err.extra;\n  }\n\n  e.c0 = e.cur0.c; e.li0 = e.cur0.loc.li; e.col0 = e.cur0.loc.col;\n  e.c = e.cur.c; e.li = e.cur.loc.li; e.col = e.cur.loc.col;\n\n  e.loc0 = e.cur0.loc;\n  e.loc = e.cur.loc;\n\n  return e;\n};\n\ncls.ga = function() { this.err(\'gen.async\'); };\n\n\n');
resolver.set('./src/Parser/parse-dependent-block.js', '  import {CH_LCURLY, CH_RCURLY} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseDependent = \nfunction(name) {\n  var c0 = this.c0, cb = {}, loc0 = this.loc0();\n\n  this.suc(cb, \'bef\');\n\n  if (!this.expectT(CH_LCURLY))\n    this.err(\'block.dependent.no.opening.curly\',{extra:{name:name}});\n\n  var n = {\n    type: \'BlockStatement\',\n    body: this.stmtList(),\n    start: c0,\n    end: this.c,\n    loc: {\n      start: loc0,\n      end: this.loc() },\n    \'#y\': this.yc, \'#scope\': null, \'#c\': cb, \'#lead\': null\n  };\n\n  this.suc(cb, \'inner\');\n\n  if (!this.expectT(CH_RCURLY))\n    this.err(\'block.dependent.is.unfinished\',{tn:n, extra:{delim:\'}\'}});\n\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/reg-char.js', '  import {CH_MIN} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\n// characters do not test for early semi-ranges, because that makes things needlessly complicated -- after all, we are only a single character away\n// from telling whether the semi range is deterministically erroneous, which is not much of a calculation\ncls.regChar =\nfunction(ce) { // class elem\n  var c0 = this.c; \n  var s = this.src;\n  var ch = s.charCodeAt(c0);\n\n  if (ch >= 0x0d800 && ch <= 0x0dbff)\n    return this.regSurrogateComponent_VOKE(ch, c0 + 1, \'lead\', \'none\');\n  if (ch >= 0x0dc00 && ch <= 0x0dfff)\n    return this.regSurrogateComponent_VOKE(ch, c0 + 1, \'trail\', \'none\');\n\n  var l = this.regChar_VECI(s.charAt(c0), c0 + 1, ch, ce);\n  if (ce && ch === CH_MIN)\n    l.type = \'#Regex.Hy\'; // \'-\'\n  return l;\n};\n\ncls.regChar_VECI =\nfunction(value, offset, ch, ce) {\n  var s = this.src, c0 = this.c;\n  var loc0 = this.loc(), raw = s.substring(c0, offset);\n  this.setsimpoff(offset);\n  var li = this.li, col = this.col;\n  var parent = ce ? null : this.regLEIAC();\n  if (!ce && this.regPrepareQ()) // `parent &&` is necessary because we might be parsing a class element\n    parent = null;\n\n  if (parent) {\n    parent.raw += raw;\n    parent.charLength += 1;\n    parent.value += value;\n    parent.end += raw.length;\n    parent.loc.end.column += raw.length;\n    if (parent.cp !== -1)\n      parent.cp = -1;\n    return parent;\n  }\n\n  this.regIsQuantifiable = true;\n  return {\n    type: \'#Regex.CharSeq\',\n    raw: raw,\n    start: c0,\n    end: offset,\n    cp: ch,\n    charLength: 1,\n    loc: { start: loc0, end: { line: li, column: col } },\n    value: value,\n  };\n};\n\n\n\n\n');
resolver.set('./src/Parser/read-id-simple.js', '  import {cls} from \'./cls.js\';\n\ncls.readID_simple =\nfunction() {\n  return this.readID_withHead(\n    this.src.charAt(this.c++)\n  );\n};\n\n\n');
resolver.set('./src/Parser/parse-string.js', '  import {CH_BACK_SLASH, CH_CARRIAGE_RETURN, CH_LINE_FEED, CH_0} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseString =\nfunction(startChar) {\n  var c = this.c, s = this.src, l = s.length, v = \"\";\n  var luo = c, surrogateTail = -1, ch = -1;\n\n  var cb = {}; this.suc(cb, \'bef\');\n\n  LOOP:\n  while (c<l) {\n    ch = s.charCodeAt(c);\n    if (ch === CH_BACK_SLASH) {\n      if (luo < c)\n        v += s.substring(luo,c);\n      this.setsimpoff(c);\n      v += this.readEsc(false);\n      c = luo = this.c;\n    }\n    else\n      switch (ch) {\n      case startChar:\n        if (luo < c)\n          v += s.substring(luo,c);\n        c++;\n        break LOOP;\n\n      case CH_CARRIAGE_RETURN:\n      case CH_LINE_FEED:\n      case 0x2028: case 0x2029:\n        this.setsimpoff(c);\n        this.err(\'str.newline\');\n\n      default: c++;\n      }\n  }\n\n  this.setsimpoff(c);\n  if (ch !== startChar)\n    this.err(\'str.unfinished\');\n\n  var n = {\n    type: \'Literal\',\n    value: v,\n    start: this.c0,\n    end: c,\n    raw: this.c0_to_c(),\n    loc: {\n      start: { line: this.li0, column: this.col0 },\n      end: { line: this.li, column: this.col }\n    }, \'#c\': cb\n  };\n\n  // not the most elegant solution, but for what it does (catching legacy numbers),\n  // it is fitting; a better solution which won\'t require re-parsing the number\n  // will eventually come instead of the block below (NUM_START token, much like the way the strings are handled)\n  if (this.chkDirective) {\n    this.chkDirective = false;\n    if (c<l) {\n      this.skipWS();\n      c = this.c;\n      if (this.scat(c) === CH_0) {\n        this.applyDirective(n);\n        this.alreadyApplied = true;\n      }\n    }\n  }\n  this.next();\n\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/read-quote.js', '  import {CH_MULTI_QUOTE, CH_SINGLE_QUOTE} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.read_multiQ =\nfunction() {\n  this.lttype = CH_MULTI_QUOTE;\n  this.ltraw = \'\"\';\n  this.setsimpoff(this.c+1);\n};\n\ncls.read_singleQ =\nfunction() {\n  this.lttype = CH_SINGLE_QUOTE;\n  this.ltraw = \"\'\";\n  this.setsimpoff(this.c+1);\n};\n\n\n');
resolver.set('./src/Parser/new-parse-template.js', '  import {CH_$, CH_LCURLY, CTX_TOP, CH_RCURLY, CH_CARRIAGE_RETURN, CH_LINE_FEED, CH_BACK_SLASH, CH_BACKTICK} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseTemplate =\nfunction() {\n  this.v<=5 && this.err(\'ver.temp\');\n\n  // c is on the char after `\n  var c0 = this.c0, loc0 = this.loc0();\n  var c = this.c, li = this.li, col = this.col;\n  var str = [], ex = [];\n  var v = \"\";\n  var luo = c;\n\n  var s = this.src, l = s.length;\n\n  var c0s = c, loc0s = this.loc();\n\n  var iscr = false;\n  var y = 0;\n\n  var cb = {}; this.suc(cb, \'bef\');\n  LOOP:\n  while (c<l)\n  switch (s.charCodeAt(c)) {\n  case CH_$:\n    if (c+1<l &&\n      s.charCodeAt(c+1) === CH_LCURLY) {\n      if (luo<c)\n        v += s.substring(luo,c);\n\n      this.setsimpoff(c+2);\n      str.push({\n        type: \'TemplateElement\', \n        start: c0s,\n        loc: { \n          start: loc0s, \n          end: {\n            line: this.li, \n            column: this.col-2 \n          }\n        },        \n        end: c,\n        value: {\n          raw: s.slice(c0s, c).replace(/\\r\\n|\\r/g,\'\\n\'), \n          cooked: v\n        }, \n        tail: false,\n      });\n\n      this.next(); // prepare the next token\n      var e = this.parseExpr(CTX_TOP);\n      if (e === null)\n        this.err(\'templ.expr.is.a.null\');\n      ex.push(core(e));\n      y += this.Y(e);\n      if (this.lttype !== CH_RCURLY)\n        this.err(\'templ.expr.is.unfinished\');\n\n      this.spc(core(e), \'aft\');\n      c = luo = this.c;\n      v = \"\";\n      c0s = c;\n      loc0s = this.loc();\n    }\n    else\n      c++;\n \n    continue;\n\n  case CH_CARRIAGE_RETURN:\n    iscr = true;\n  case CH_LINE_FEED:\n  case 0x2028: case 0x02029:\n    if (luo<c)\n      v += s.substring(luo,c);\n    if (iscr) {\n      if (c+1<l && s.charCodeAt(c+1) === CH_LINE_FEED)\n        c++;\n      iscr = false;\n    }\n    v += s.charAt(c);\n    c++;\n    this.setzoff(c);\n    luo = c;\n    continue;\n\n  case CH_BACK_SLASH:\n    if (luo<c) v += s.substring(luo,c);\n\n    this.setsimpoff(c);\n    v += this.readEsc(true);\n    c = luo = this.c;\n    continue;\n\n  case CH_BACKTICK:\n    break LOOP;\n\n  default: c++;\n  }\n\n  if (c >= l || s.charCodeAt(c) !== CH_BACKTICK)\n    this.err(\'template.literal.is.unfinished\');\n\n  if (luo<c)\n    v += s.substring(luo,c);\n\n  c++;\n  this.setsimpoff(c); // \'`\'\n  str.push({\n    type: \'TemplateElement\',\n    start: c0s,\n    loc: {\n      start: loc0s,\n      end: {\n        line: this.li,\n        column: this.col-1\n      }\n    },\n    end: c-1,\n    value: {\n      raw: s.slice(c0s,c-1).replace(/\\r\\n|\\r/g,\'\\n\'), \n      cooked: v \n    },\n    tail: true\n  });\n\n  var n = {\n    type: \'TemplateLiteral\',\n    start: c0,\n    quasis: str,\n    end: c,\n    expressions: ex,\n    loc: { start: loc0, end : this.loc() },\n    \'#y\': y, \'#c\': cb\n  };\n\n  this.next();\n\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/new-parse-new.js', '  import {CH_SINGLEDOT, CTX_NONE, CH_LSQBRACKET, CH_RSQBRACKET, CH_LPAREN, CH_RPAREN, CH_BACKTICK} from \'../other/constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {core} from \'../other/util.js\';\n  import {TK_ID, PREC_NONE} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseNew =\nfunction() {\n  this.resvchk();\n  var c0 = this.c0, loc0 = this.loc0();\n  var c = this.c, li = this.li, col = this.col;\n\n  var cb = {}; this.suc(cb, \'bef\');\n  this.next(); // \'new\'\n  if (this.lttype === CH_SINGLEDOT) {\n    this.suc(cb, \'new.aft\');\n    this.cb = cb;\n    this.next();\n    return this.parseMeta(c0,loc0,c,li,col);\n  }\n\n  var head = this.parseExprHead(CTX_NONE);\n  if (head === null)\n    this.err(\'new.head.is.not.valid\');\n\n  if (head.type === \'Identifier\')\n    head[\'#ref\'] = this.scope.refDirect_m(_m(head.name), null);\n\n  var inner = core(head), elem = null;\n\n  var argloc = null;\n\n  LOOP:\n  while (true)\n  switch (this.lttype) {\n  case CH_SINGLEDOT:\n    this.spc(inner, \'aft\');\n    argloc = this.loc0();\n    this.next();\n    if (this.lttype !== TK_ID)\n      this.err(\'mem.name.not.id\');\n    elem = this.mem_id();\n    if (elem === null)\n      this.err(\'mem.id.is.null\');\n    head = inner = {\n      type: \'MemberExpression\',\n      property: elem,\n      start: head.start,\n      end: elem.end,\n      object: inner,\n      loc: {\n        start: head.loc.start,\n        end: elem.loc.end },\n      computed: false,\n      \'#y\': this.Y(head), \'#acloc\': argloc, \'#c\': {}\n    };\n    continue;\n\n  case CH_LSQBRACKET:\n    this.spc(inner, \'aft\');\n    this.next();\n    elem = this.parseExpr(PREC_NONE, CTX_NONE);\n    head = inner = {\n      type: \'MemberExpression\',\n      property: core(elem),\n      start: head.start,\n      end: this.c,\n      object: inner,\n      loc: {\n        start: head.loc.start,\n        end: this.loc() },\n      computed: true,\n      \'#y\': this.Y(head)+this.Y(elem), \'#acloc\': argloc, \'#c\': {}\n    };\n    this.spc(core(elem), \'aft\');\n    if (!this.expectT(CH_RSQBRACKET))\n      this.err(\'mem.unfinished\');\n    continue;\n\n  case CH_LPAREN:\n    this.spc(inner, \'aft\');\n    argloc = this.loc0();\n    elem = this.parseArgList();\n    this.suc(cb, \'inner\');\n    head = inner = {\n      type: \'NewExpression\',\n      callee: inner,\n      start: c0,\n      end: this.c,\n      arguments: elem,\n      loc: {\n        start: loc0,\n        end: this.loc() },\n      \'#y\': this.Y(head)+this.y, \'#argloc\': argloc, \'#c\': cb,\n    };\n    if (!this.expectT(CH_RPAREN))\n      this.err(\'new.args.is.unfinished\');\n    break LOOP;\n\n  case CH_BACKTICK:\n    this.spc(inner, \'aft\');\n    elem = this.parseTemplate();\n    head = inner = {\n      type: \'TaggedTemplateExpression\',\n      quasi: elem,\n      start: head.start,\n      end: elem.end,\n      loc: {\n        start: head.loc.start,\n        end: elem.loc.end },\n      tag: inner,\n      \'#c\': {}, \'#y\': this.Y(head)+this.Y(elem)\n    };\n    continue;\n\n  default:\n    head = {\n      type: \'NewExpression\',\n      callee: inner,\n      start: c0,\n      end: head.end,\n      loc: {\n        start: loc0,\n        end: head.loc.end },\n      arguments : [],\n      \'#y\': this.Y(head), \'#c\': cb\n    };\n    break LOOP;\n  }\n\n  return head;\n};\n\n\n');
resolver.set('./src/Parser/reg-pattern.js', '  import {CH_OR} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.regPattern =\nfunction() {\n  var c0 = this.c, li0 = this.li, col0 = this.col;\n  var l = this.resetLastRegexElem();\n  var branches = null, elem = this.regBranch();\n  if (this.regErr)\n    return null;\n\n  if (this.expectChar(CH_OR)) {\n    branches = [];\n    branches.push(elem)\n    do {\n      this.resetLastRegexElem();\n      elem = this.regBranch();\n      if (this.regErr)\n        return null;\n      branches.push(elem);\n    } while (this.expectChar(CH_OR));\n  }\n  else if (elem)\n    branches = [elem];\n  else\n    return null;\n  \n  var startLoc = branches.length && branches[0] ? branches[0].loc.start : { line: li0, column: col0 };\n  var lastElem = branches.length ? branches[branches.length-1] : null;\n  var endLoc = lastElem ? lastElem.loc.end : this.loc();\n\n  this.lastRegexElem = l;\n\n  return {\n    type: \'#Regex.Main\',\n    branches: branches,\n    start: c0,\n    end: lastElem ? lastElem.end : this.c, // equal either way, actually\n    loc: { start: startLoc, end: endLoc }\n  };\n};\n\ncls.regDot =\nfunction() {\n  var c0 = this.c, loc0 = this.loc();\n  this.setsimpoff(c0+1);\n  this.regIsQuantifiable = true;\n  return {\n    type: \'#Regex.Dot\',\n    start: c0,\n    loc: { start: loc0, end: this.loc() },\n    end: this.c\n  };\n};\n\n\n');
resolver.set('./src/Parser/parse-switch.js', '  import {CH_LPAREN, CTX_TOP, CH_RPAREN, CH_LCURLY, CH_RCURLY} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {SA_BREAK} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseSwitch = function () {\n  this.resvchk();\n  !this.testStmt() && this.err(\'not.stmt\');\n  this.fixupLabels(false) ;\n\n  var c0 = this.c0, loc0 = this.loc0(),\n      cases = [], hasDefault = false , elem = null;\n\n  var cb = {}; this.suc(cb, \'bef\');\n  this.next(); // \'switch\'\n  this.suc(cb, \'switch.aft\');\n  if (!this.expectT(CH_LPAREN))\n    this.err(\'switch.has.no.opening.paren\');\n\n  var switchExpr = core(this.parseExpr(CTX_TOP));\n  this.spc(switchExpr, \'aft\');\n\n  if (!this.expectT(CH_RPAREN))\n    this.err(\'switch.has.no.closing.paren\');\n\n  this.suc(cb, \'cases.bef\');\n  if (!this.expectT(CH_LCURLY))\n    this.err(\'switch.has.no.opening.curly\');\n\n  this.enterScope(this.scope.spawnBlock()); \n  var scope = this.scope;\n\n  this.allow(SA_BREAK);\n\n  var y = 0;\n  while (elem = this.parseSwitchCase()) {\n    if (elem.test === null) {\n       if (hasDefault ) this.err(\'switch.has.a.dup.default\');\n       hasDefault = true ;\n    }\n    cases.push(elem);\n    y += this.Y(elem);\n  }\n\n  this.foundStatement = true;\n  this.exitScope(); \n\n  var n = {\n    type: \'SwitchStatement\',\n    cases: cases,\n    start: c0,\n    discriminant: switchExpr,\n    end: this.c,\n    loc: {\n      start: loc0,\n      end: this.loc() }, \n    \'#scope\': scope,\n    \'#y\': this.Y(switchExpr)+(y), \'#c\': cb\n  };\n\n  this.suc(cb, \'inner\');\n  if (!this.expectT(CH_RCURLY))\n    this.err(\'switch.unfinished\');\n\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/parse-catch.js', '  import {CH_LPAREN, CH_RPAREN} from \'../other/constants.js\';\n  import {DT_CATCHARG, DT_NONE} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls. parseCatchClause = function () {\n   var c0 = this.c0, cb = {}, loc0 = this.loc0();\n\n   this.suc(cb, \'bef\');\n   this.next(); // \'catch\'\n   this.suc(cb, \'catch.aft\');\n\n   this.enterScope(this.scope.spawnCatch());\n   if (!this.expectT(CH_LPAREN))\n     this.err(\'catch.has.no.opening.paren\',{c0:c0,loc0:loc0});\n\n   this.declMode = DT_CATCHARG;\n   var catParam = this.parsePat();\n   if (this.peekEq())\n     this.err(\'catch.has.an.assig.param\',{c0:startc,loc0:startLoc,extra:catParam});\n\n   this.declMode = DT_NONE;\n   if (catParam === null)\n     this.err(\'catch.has.no.param\',{c0:startc,loc0:startLoc});\n\n   if (catParam.type === \'Identifier\')\n     this.scope.argIsSimple = true;\n\n   this.spc(catParam, \'aft\');\n   if (!this.expectT(CH_RPAREN))\n     this.err(\'catch.has.no.end.paren\',{c0:startc,loc0:startLoc,extra:catParam});\n\n   this.scope.activateBody();\n   var catBlock = this.parseDependent(\'catch\');\n   catBlock[\'#scope\'] = this.scope ; \n   var scope = this.exitScope();\n\n   return {\n       type: \'CatchClause\',\n       loc: { start: loc0, end: catBlock.loc.end },\n       start: c0,\n       end: catBlock.end,\n       param: catParam ,\n       body: catBlock,\n       \'#scope\': scope,\n       \'#y\': this.Y(catParam)+this.Y(catBlock)\n   };\n};\n\n\n');
resolver.set('./src/Parser/parse-throw.js', '  import {CTX_NULLABLE, CTX_TOP} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseThrow =\nfunction () {\n  this.resvchk();\n  this.testStmt() || this.err(\'not.stmt\');\n  this.fixupLabels(false ) ;\n\n  var ex = null, c0 = this.c0, loc0 = this.loc0();\n  var li = this.li, c = this.c, col = this.col;\n\n  var b = {}; this.suc(b, \'bef\');\n  this.next(); // \'throw\'\n\n  if (this.nl)\n    this.err(\'throw.has.newline\');\n\n  ex = this.parseExpr(CTX_NULLABLE|CTX_TOP);\n  if (ex === null)\n    this.err(\'throw.has.no.argument\');\n\n  this.semi(core(ex)[\'#c\'], \'aft\') || this.err(\'no.semi\');\n\n  this.foundStatement = true;\n  return {\n    type: \'ThrowStatement\',\n    argument: core(ex),\n    start: c0,\n    end: this.semiC || ex.end,\n    loc: {\n      start: loc0,\n      end: this.semiLoc || ex.loc.end\n    },\n    \'#c\': b,\n    \'#y\': this.Y(ex)\n  };\n};\n\n\n');
resolver.set('./src/Parser/conv-arrow.js', '  import {arorev} from \'../other/util.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {DT_FNARG} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.asArrowFuncArgList = function(argList) {\n  var i = 0, list = argList;\n  while (i < list.length)\n    this.asArrowFuncArg(list[i++]);\n};\n\ncls.asArrowFuncArg = function(arg) {\n  var i = 0, list = null;\n  if (arg === this.po)\n    this.throwTricky(\'p\', this.pt);\n  if (arg.type !== \'Identifier\')\n    this.scope.firstNonSimple = arg;\n\n  switch  ( arg.type ) {\n  case \'Identifier\':\n    if (this.scope.canAwait() &&\n       arg.name === \'await\')\n      this.err(\'arrow.param.is.await.in.an.async\',{tn:arg});\n     \n    // TODO: this can also get checked in the scope manager rather than below\n    if (this.scope.insideStrict() && arorev(arg.name))\n      this.err(\'binding.to.arguments.or.eval\',{tn:arg});\n\n    this.scope.findRefU_m(_m(arg.name)).d--; // one ref is a decl\n    this.scope.decl_m(_m(arg.name), DT_FNARG);\n    return;\n\n  case \'ArrayExpression\':\n    list = arg.elements;\n    while (i < list.length) {\n      if (list[i])\n        this.asArrowFuncArg(list[i]);\n      i++;\n    }\n    arg.type = \'ArrayPattern\';\n    return;\n\n  case \'AssignmentExpression\':\n//  if (arg.operator !== \'=\')\n//    this.err(\'complex.assig.not.arg\');\n\n    this.asArrowFuncArg(arg.left);\n    delete arg.operator ;\n    arg.type = \'AssignmentPattern\';\n\n    return;\n\n  case \'ObjectExpression\':\n    list = arg.properties;\n    while (i < list.length)\n      this.asArrowFuncArg(list[i++].value );\n\n    arg.type = \'ObjectPattern\';\n    return;\n\n  case \'AssignmentPattern\':\n    this.asArrowFuncArg(arg.left) ;\n    return;\n\n  case \'ArrayPattern\' :\n    list = arg.elements;\n    while ( i < list.length ) {\n      if (list[i])\n        this.asArrowFuncArg(list[i]);\n      i++ ;\n    }\n    return;\n\n  case \'SpreadElement\':\n    if (this.v < 7 && arg.argument.type !== \'Identifier\')\n      this.err(\'rest.binding.arg.not.id\', {tn:arg});\n    this.asArrowFuncArg(arg.argument);\n    arg.type = \'RestElement\';\n    return;\n\n  case \'RestElement\':\n    if (this.v < 7 && arg.argument.type !== \'Identifier\')\n      this.err(\'rest.binding.arg.not.id\',{tn:arg});\n    this.asArrowFuncArg(arg.argument);\n    return;\n\n  case \'ObjectPattern\':\n    list = arg.properties;\n    while (i < list.length)\n      this.asArrowFuncArg(list[i++].value);\n    return;\n\n  default:\n    this.err(\'not.bindable\');\n\n  }\n};\n\n\n\n');
resolver.set('./src/Parser/new-export.js', '  import {TK_ID, PREC_NONE} from \'../other/lexer-constants.js\';\n  import {DT_ESELF, DT_VAR, DT_LET, ST_DECL, DT_CONST, DT_EDEFAULT} from \'../other/scope-constants.js\';\n  import {CTX_NONE, CH_COMMA, CH_RCURLY, ASSERT, CTX_TOP, CTX_DEFAULT, CH_LCURLY} from \'../other/constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseExport_elemOther =\nfunction(c0,loc0) {\n  var elem = null, cb = this.cb, stmt = false;\n  if (this.lttype === TK_ID) {\n    this.canBeStatement = true;\n    switch (this.ltval) {\n    case \'class\':\n      this.ex = DT_ESELF;\n      elem = this.parseClass(CTX_NONE);\n      break;\n    case \'var\':\n      this.ex = DT_ESELF;\n      elem = this.parseVar(DT_VAR, CTX_NONE);\n      break;\n    case \'let\':\n      this.ex = DT_ESELF;\n      elem = this.parseVar(DT_LET, CTX_NONE);\n      break;\n    case \'async\':\n      elem = this.id();\n      this.ex = DT_ESELF;\n      if (this.peekID(\'function\')) {\n        this.nl && this.err(\'newline.async\');\n        elem = this.parseAsync_fn(elem, CTX_NONE);\n      }\n      else\n        this.err(\'async.lone\');\n      break;\n    case \'function\':\n      this.ex = DT_ESELF;\n      elem = this.parseFn(CTX_NONE, ST_DECL);\n      break;\n    case \'const\':\n      this.ex = DT_ESELF;\n      elem = this.parseVar(DT_CONST, CTX_NONE);\n      break;\n    default:\n      this.canBeStatement = false;\n      elem = this.parseNonSeq(PREC_NONE, CTX_NONE);\n      break;\n    }\n    stmt = this.foundStatement;\n  }\n  if (elem === null)\n    this.err(\'export.named.no.exports\');\n\n  if (!stmt)\n    this.semi(elem[\'#c\'], \'aft\') || this.err(\'no.semi\');\n\n  return {\n    type: \'ExportNamedDeclaration\',\n    start: c0,\n    loc: { start: loc0, end: elem.loc.end },\n    end: elem.end,\n    declaration: elem,\n    specifiers: [],\n    source: null,\n    \'#y\': 0, \'#c\': cb \n  };\n};\n\ncls.parseExport_elemList = \nfunction(c0,loc0) {\n  var cb = this.cb; this.suc(cb, \'list.bef\');\n  this.next();\n  var firstResv = null;\n  var list = [];\n  while (this.lttype === TK_ID) {\n    var lName = this.id();\n    var eName = lName;\n    if (this.lttype === TK_ID) {\n      this.ltval === \'as\' || this.err(\'export.specifier.not.as\');\n      this.spc(lName, \'aft\');\n      this.next();\n      if (this.lttype !== TK_ID)\n        this.err(\'export.specifier.after.as.id\');\n      eName = this.id();\n    }\n    if (!firstResv && this.isResv(lName.name))\n      firstResv = lName;\n\n    var entry = this.scope.registerExportedEntry_oi(eName.name, eName, lName.name);\n\n    list.push({\n      type: \'ExportSpecifier\',\n      start: lName.start,\n      loc: { start: lName.loc.start, end: eName.loc.end }, \n      end: eName.end,\n      exported: eName,\n      local: lName ,\n      \'#y\': 0,\n      \'#entry\': entry \n    });\n\n    if (this.lttype === CH_COMMA) {\n      this.spc(eName, \'aft\');\n      this.next();\n    }\n    else\n      break;\n  }\n\n  var ec = this.c, eli = this.li, ecol = this.col;\n\n  this.suc(cb, \'inner\');\n  this.expectT(CH_RCURLY) || this.err(\'export.named.list.not.finished\');\n\n  var src = null;\n  if (this.peekID(\'from\')) {\n    this.cb = cb;\n    src = this.parseExport_from();\n  }\n  else\n    firstResv && this.err(\'export.named.has.reserved\',{tn: firstResv});\n\n  this.semi(src ? src[\'#c\'] : cb, src ? \'aft\' : \'list.aft\') || this.err(\'no.semi\');\n  \n  ec = this.semiC || (src && src.end) || ec;\n  var eloc = this.semiLoc || (src && src.loc.end) || { line: li, column: col };\n\n  this.foundStatement = true;\n\n  src ?\n    this.scope.regulateForwardExportList(list, src) :\n    this.scope.regulateOwnExportList(list);\n\n  return {\n    type: \'ExportNamedDeclaration\',\n    start: c0,\n    loc: { start: loc0, end: eloc },\n    end: ec,\n    declaration: null,\n    specifiers: list,\n    source: src,\n    \'#y\': 0, \'#c\': cb \n  };\n};\n\ncls.parseExport_elemAll =\nfunction(c0,loc0) {\n  var cb = this.cb; this.suc(cb, \'*.bef\');\n  this.next();\n  var src = null;\n  src = this.parseExport_from();\n  this.semi(src[\'#c\'], \'aft\') || this.err(\'no.semi\');\n  \n  this.foundStatement = true;\n  this.scope.registerForwardedSource(src);\n  return {\n    type: \'ExportAllDeclaration\',\n    start: c0,\n    loc: { start: loc0, end: this.semiLoc || src.loc.end },\n    end: this.semiC || src.end,\n    source: src,\n    \'#y\': 0, \'#c\': cb\n  };\n};\n\ncls.createDefaultLiq =\nfunction() {\n  var lg = this.scope.gocLG(\'default\');\n  var liqDefault = lg.newL();\n  lg.seal();\n\n  liqDefault.name = \"_default\";\n  return liqDefault;\n};\n\ncls.parseExport_elemDefault =\nfunction(c0,loc0) {\n  var cb = this.cb; this.suc(cb, \'default.bef\' );\n  var defaultID = this.id();\n  var elem = null;\n\n  var entry = this.scope.registerExportedEntry_oi(\'*default*\', defaultID, \'*default*\');\n  var stmt = false; \n  ASSERT.call(this, entry.target === null, \'target\' );\n\n  entry.target = {prev: null, v: null, next: null};\n  \n  var target = null;\n\n  if (this.lttype !== TK_ID)\n    elem = this.parseNonSeq(PREC_NONE, CTX_TOP);\n  else {\n    this.canBeStatement = true;\n    switch (this.ltval) {\n    case \'async\':\n      this.ex = DT_EDEFAULT;\n      elem = this.id(); // \'async\'\n      if (this.nl) {\n        this.canBeStatement = false;\n        elem = this.parseAsync_exprHead(elem, CTX_TOP);\n      }\n      else\n        elem = this.parseAsync(elem, CTX_TOP|CTX_DEFAULT) ;\n\n      if (!this.foundStatement) {\n        this.exprHead = elem;\n        elem = this.parseNonSeq(PREC_NONE, CTX_TOP) ;\n      }\n      else { this.inferName(defaultID, elem, false); }\n      break;\n    case \'function\':\n      this.ex = DT_EDEFAULT;\n      elem = this.parseFn(CTX_DEFAULT, ST_DECL);\n      this.inferName(defaultID, elem, false );\n      break;\n    case \'class\':\n      this.ex = DT_EDEFAULT;\n      elem = this.parseClass(CTX_DEFAULT );\n      this.inferName(defaultID, elem, false);\n      break;\n    default:\n      this.canBeStatement = false;\n      elem = entry.value = this.parseNonSeq(PREC_NONE, CTX_TOP);\n      break;\n    }\n    stmt = this.foundStatement;\n  }\n\n  // for named [fns/clses], a \'var <name> = <the default elem>\' is unnecessary\n  var needsTarget = true;\n  switch (elem.type) {\n  case \'FunctionDeclaration\':\n  case \'ClassDeclaration\':\n    if (elem.id !== null) {\n      target = this.scope.findDeclOwn_m(_m(elem.id.name));\n      needsTarget = false;\n    }\n  }\n\n  entry.target.v = target || this.createDefaultLiq();\n\n  if (!stmt)\n    this.semi(core(elem)[\'#c\'], \'aft\') || this.err(\'no.semi\');\n  else {\n    this.semiLoc = null;\n    this.semiC = 0;\n  }\n\n  this.foundStatement = true;\n  return {\n    type: \'ExportDefaultDeclaration\',    \n    start: c0,\n    loc: { start: loc0, end: this.semiLoc || elem.loc.end },\n    end: this.semiC || elem.end,\n    declaration: core(elem),\n    \'#y\': 0, \'#c\': cb, \'#binding\': needsTarget ? entry.target.v : null, \'#emitted\': false\n  };\n};\n\ncls.parseExport_from =\nfunction() {\n  var cb = this.cb;\n  this.peekID(\'from\') || this.err(\'export.from\');\n  this.suc(cb, \'from.bef\');\n  this.next();\n  this.peekStr() || this.err(\'export.src\');\n\n  return this.parseString(this.lttype);\n};\n\ncls.parseExport =\nfunction() {\n  if (this.v<=5) this.err(\'ver.exim\');\n  this.testStmt() || this.err(\'not.stmt\');\n  this.isScript && this.err(\'export.not.in.module\');\n\n  var c0 = this.c0, cb = {}, loc0 = this.loc0();\n\n  this.suc(cb, \'bef\');\n  this.next();\n\n  this.cb = cb;\n  return (\n    this.peekMul() ?\n      this.parseExport_elemAll(c0,loc0) :\n    this.peekID(\'default\') ?\n      this.parseExport_elemDefault(c0,loc0) :\n    this.lttype === CH_LCURLY ?\n      this.parseExport_elemList(c0,loc0) :\n      this.parseExport_elemOther(c0,loc0)\n  );\n};\n\ncls.parseExport_elemDefault_async =\nfunction() {\n  var a = this.id(); // \'async\'\n  if (this.nl) {\n    this.canBeStatement = false;\n    this.exprHead = this.parseAsync_exprHead(a);\n    return this.parseNonSeq(PREC_NONE, CTX_TOP);\n  }\n\n  return this.parseAsync(a, CTX_TOP|CTX_DEFAULT);\n};\n\n\n');
resolver.set('./src/Parser/reg-anchor.js', '  import {cls} from \'./cls.js\';\n\ncls.regUnitAssertion =\nfunction() {\n  var c0 = this.c, loc0 = this.loc();\n  var kind = this.src.charAt(this.c);\n  this.setsimpoff(this.c+1);\n  return {\n    type: \'#Regex.Assertion\',\n    kind: kind,\n    start: c0,\n    end: this.c,\n    loc: { start: loc0, end: this.loc() }\n  };\n};\n\ncls.regBbAssertion =\nfunction() {\n  var c0 = this.c, loc0 = this.loc();\n  var kind = this.src.charAt(c0+1);\n  this.setsimpoff(c0+2);\n  return {\n    type: \'#Regex.Assertion\',\n    kind: kind,\n    start: c0,\n    end: this.c,\n    loc: { start: loc0, end: this.loc() }\n  };\n};\n\n\n');
resolver.set('./src/Parser/directive.js', '  import {cls} from \'./cls.js\';\n\ncls.enterPrologue =\nfunction() {\n  this.scope.enterPrologue();\n};\n\ncls.exitPrologue =\nfunction() {\n  this.scope.exitPrologue();\n  this.clearPendingStrictErrors();\n};\n\ncls.applyDirective =\nfunction(directiveLiteral) {\n  if (this.alreadyApplied) {\n    this.alreadyApplied = false;\n    return;\n  }\n  var raw = directiveLiteral.raw;\n  // TODO: which one should apply first?\n  if (raw.substring(1,raw.length-1) === \'use strict\') {\n    this.scope.makeStrict();\n    this.strict_esc_chk(); // for now it is the sole possible error\n  }\n};\n\n\n');
resolver.set('./src/Parser/parse-arrow.js', '  import {ERR_ASYNC_NEWLINE_BEFORE_PAREN} from \'../other/error-constants.js\';\n  import {ASSERT, PAREN_NODE, INTERMEDIATE_ASYNC, CH_LCURLY, CTX_PAT} from \'../other/constants.js\';\n  import {ST_ARROW, ST_ASYNC} from \'../other/scope-constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {cmn, core} from \'../other/util.js\';\n  import {PREC_NONE} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseArrow = function(arg, ctx)   {\n  if (this.v <= 5)\n    this.err(\'ver.arrow\');\n  var async = false;\n\n  var cb = {};\n  if (this.pt === ERR_ASYNC_NEWLINE_BEFORE_PAREN) {\n    ASSERT.call(this, arg === this.pe,\n      \'how can an error core not be equal to the erroneous argument?!\');\n    this.err(\'arrow.newline.before.paren.async\');\n  }\n\n  var sc = ST_ARROW;\n  var loc = null;\n\n  switch ( arg.type ) {\n  case \'Identifier\':\n    this.scope.findRefAny_m(_m(arg.name)).d--;\n    this.enterScope(this.scope.spawnFn(sc));\n    arg[\'#ref\'] = this.scope.refDirect_m(_m(arg.name), null);\n    this.asArrowFuncArg(arg);\n    this.spc(arg, \'aft\');\n    loc = arg.loc.start;\n    break;\n\n  case PAREN_NODE:\n    this.enterScope(this.scope.spawnFn(sc));\n    this.parenScope.makeParams(this.scope);\n    this.parenScope = null;\n    if (arg.expr) {\n      if (arg.expr.type === \'SequenceExpression\')\n        this.asArrowFuncArgList(arg.expr.expressions);\n      else\n        this.asArrowFuncArg(arg.expr);\n    }\n    cb.bef = cmn(arg[\'#c\'], \'bef\' );\n    cb.inner = cmn(arg[\'#c\'], \'inner\');\n    this.suc(cb, \'list.bef\' );\n    loc = arg.loc.start;\n    break;\n\n  case \'CallExpression\':\n    if (this.v >= 7 && arg.callee.type !== \'Identifier\' || arg.callee.name !== \'async\')\n      this.err(\'not.a.valid.arg.list\',{tn:arg});\n    if (this.parenAsync !== null && arg.callee === this.parenAsync.expr)\n      this.err(\'arrow.has.a.paren.async\');\n\n//  if (this.v < 7)\n//    this.err(\'ver.async\');\n\n    async = true;\n    sc |= ST_ASYNC;\n    this.enterScope(this.scope.spawnFn(sc));\n    this.parenScope.makeParams(this.scope);\n    this.parenScope = null;\n    this.asArrowFuncArgList(arg.arguments);\n    cb.bef = arg.callee[\'#c\'].bef;\n    cb[\'async.aft\'] = arg.callee[\'#c\'].aft;\n    cb.inner = arg[\'#c\'].inner ;\n    this.suc(cb, \'list.bef\' );\n    loc = arg[\'#argloc\' ];\n    break;\n\n  case INTERMEDIATE_ASYNC:\n    async = true;\n    sc |= ST_ASYNC;\n    this.enterScope(this.scope.spawnFn(sc));\n    arg.id[\'#ref\'] = this.scope.refDirect_m(_m(arg.id.name), null);\n    this.asArrowFuncArg(arg.id);\n    cb.bef = arg.asyncID[\'#c\'].bef;\n    this.spc(arg.id, \'aft\');\n    loc = arg.loc.start;\n    break;\n\n  default: this.err(\'not.a.valid.arg.list\');\n  }\n\n  this.pt_flush();\n\n  var scope = this.scope;\n  scope.activateBody();\n\n  if (this.nl)\n    this.err(\'arrow.newline\');\n\n  this.next();\n  var isExpr = true, nbody = null;\n\n  if (this.lttype === CH_LCURLY) {\n    var prevLabels = this.labels,\n        prevDeclMode = this.declMode;\n\n    this.labels = {};\n    isExpr = false;\n    nbody = this.parseFunBody();\n\n    this.labels = prevLabels;\n    this.declMode = prevDeclMode;\n  }\n  else\n    nbody = this.parseNonSeq(PREC_NONE, ctx|CTX_PAT) ;\n\n  this.exitScope(); // body\n\n  var params = core(arg);\n  if (params === null)\n    params = [];\n  else if (params.type === \'SequenceExpression\')\n    params = params.expressions;\n  else if (params.type === \'CallExpression\')\n    params = params.arguments;\n  else {\n    if (params.type === INTERMEDIATE_ASYNC)\n      params = params.id;\n    params = [params];\n  }\n\n  return {\n    type: \'ArrowFunctionExpression\', params: params, \n    start: arg.start, end: nbody.end,\n    loc: {\n      start: arg.loc.start,\n      end: nbody.loc.end\n    },\n    generator: false, expression: isExpr,\n    body: core(nbody), id : null,\n    async: async,\n    \'#scope\': scope, \'#y\': 0, \'#c\': cb, \'#argploc\': loc\n  }; \n};\n\n\n');
resolver.set('./src/Parser/parse-paren.js', '  import {CTX_NONE, CTX_PAT, CTX_PARAM, CTX_NULLABLE, CTX_TOP, PAREN_NODE, CTX_HAS_A_PARAM_ERR, CTX_HAS_A_SIMPLE_ERR, CH_COMMA, CH_RPAREN, CTX_PARPAT} from \'../other/constants.js\';\n  import {ERR_NONE_YET, ERR_UNEXPECTED_REST, ERR_PAREN_UNBINDABLE, ERR_YIELD_OR_SUPER, ERR_NON_TAIL_EXPR, ERR_EMPTY_LIST_MISSING_ARROW} from \'../other/error-constants.js\';\n  import {PREC_NONE, TK_ELLIPSIS} from \'../other/lexer-constants.js\';\n  import {errt_param, errt_ptrack, errt_pin, errt_psyn, errt_strack, errt_ssyn, errt_pat} from \'../other/errt.js\';\n  import {core, CB} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseParen = function(ctx) {\n  var c0 = this.c0, loc0 = this.loc0(),\n      list = null, prevys = this.suspys,\n      elctx = CTX_NONE, hasRest = false,\n      pc0 = -1, pli0 = -1, pcol0 = -1,\n      sc0 = -1, sli0 = -1, scol0 = -1,\n      st = ERR_NONE_YET, se = null, so = null,\n      pt = ERR_NONE_YET, pe = null, po = null,\n      insideParams = false,\n      parenScope = null;\n\n  if (ctx & CTX_PAT) {\n    this.pt = this.st = ERR_NONE_YET;\n    this.pe = this.po =\n    this.se = this.so = null;\n    this.suspys = null;\n    elctx = CTX_PAT|CTX_PARAM|CTX_NULLABLE;\n    this.enterScope(this.scope.spawnParen());\n    insideParams = true;\n  }\n  else\n    elctx = CTX_TOP;\n\n  var lastElem = null, hasTailElem = false;\n\n  var bef = this.cc();\n  this.next();\n\n  var elem = null, y = 0;\n  while (true) {\n    lastElem = elem;\n    elem = this.parseNonSeq(PREC_NONE, elctx);\n    if (elem === null) {\n      if (this.lttype === TK_ELLIPSIS) {\n        if (!errt_param(elctx)) {\n          this.st_teot(ERR_UNEXPECTED_REST,null,null);\n          this.st_flush();\n        }\n        elem = this.parseSpread(elctx);\n        hasRest = true;\n      }\n      else if (list) {\n        if (this.v < 7)\n          this.err(\'seq.non.tail.expr\');\n        else \n          hasTailElem = true;\n      } \n      else break;\n    }\n\n    if (elem) y += this.Y(elem);\n\n    if (errt_param(elctx)) {\n      if (errt_ptrack(elctx)) {\n        if (this.pt === ERR_NONE_YET && !hasTailElem) {\n          // TODO: function* l() { ({[yield]: (a)})=>12 }\n          if (elem.type === PAREN_NODE) {\n            this.pt = ERR_PAREN_UNBINDABLE;\n            this.pe = elem;\n          }\n          else if(this.suspys) {\n            this.pt = ERR_YIELD_OR_SUPER;\n            this.pe = this.suspys;\n          }\n        }\n        if (this.pt_override(pt)) {\n          pt = this.pt, pe = this.pe, po = core(elem);\n          if (errt_pin(pt))\n            pc0 = this.pin.p.c0, pli0 = this.pin.p.li0, pcol0 = this.pin.p.col0;\n          if (errt_psyn(pt))\n            elctx |= CTX_HAS_A_PARAM_ERR;\n        }\n      }\n\n      if (errt_strack(elctx)) {\n        if (this.st === ERR_NONE_YET) {\n          if (hasRest) {\n            this.st = ERR_UNEXPECTED_REST;\n            this.se = elem;\n          }\n          else if (hasTailElem) {\n            this.st = ERR_NON_TAIL_EXPR;\n            this.se = lastElem;\n          }\n        }\n        if (this.st_override(st)) {\n          st = this.st, se = this.se, so = elem && core(elem);\n          if (errt_pin(st))\n            sc0 = this.pin.s.c0, sli0 = this.pin.s.li0, scol0 = this.pin.s.col0;\n          if (errt_ssyn(st))\n            elctx |= CTX_HAS_A_SIMPLE_ERR;\n        }\n      }\n    }\n\n    if (hasTailElem)\n      break;\n\n    if (list) list.push(core(elem));\n    if (this.lttype === CH_COMMA) {\n      if (hasRest)\n        this.err(\'rest.arg.has.trailing.comma\');\n      if (list === null)\n        list = [core(elem)];\n      this.spc(core(elem), \'aft\');\n      this.next();\n    }\n    else break;\n  }\n\n  var n = {\n      type: PAREN_NODE,\n      expr: list ? {\n        type: \'SequenceExpression\',\n        expressions: list,\n        start: list[0].start,\n        end: list[list.length-1].end,\n        loc: {\n          start: list[0].loc.start,\n          end: list[list.length-1].loc.end\n        },\n        \'#y\': y, \'#c\': {} \n      } : elem && core(elem),\n      start: c0,\n      end: this.c,\n      loc: { start: loc0, end: this.loc() }, \'#c\': {}\n  };\n\n  if (bef) {\n    if (n.expr) {\n      var cbe = CB(n.expr);\n      if (cbe.bef) cbe.bef.c = bef.c.concat(cbe.bef.c);\n      else cbe.bef = bef;\n    } else\n      CB(n).bef = bef;\n  }\n\n  n.expr && this.spc(core(n.expr), \'aft\');\n  this.suc(CB(n), \'inner\');\n  if (!this.expectT(CH_RPAREN))\n    this.err(\'unfinished.paren\',{tn:n});\n\n  if (elem === null && list === null) {\n    if (ctx & CTX_PARPAT) {\n      st = ERR_EMPTY_LIST_MISSING_ARROW;\n      se = so = n;\n    }\n    else {\n      this.st_teot(ERR_EMPTY_LIST_MISSING_ARROW,n,n);\n      this.st_flush();\n    }\n  }\n\n  if (errt_pat(ctx)) {\n    if (pt !== ERR_NONE_YET) {\n      this.pt_teot(pt,pe,po);\n      errt_pin(pt) && this.pin_pt(pc0,pli0,pcol0);\n    }\n    if (st !== ERR_NONE_YET) {\n      this.st_teot(st,se,so);\n      errt_pin(st) && this.pin_st(sc0,sli0,scol0);\n    }\n    if (list === null && elem !== null &&\n       elem.type === \'Identifier\' && elem.name === \'async\')\n      this.parenAsync = n;\n  }\n\n  if (prevys !== null)\n    this.suspys = prevys;\n\n  if (insideParams)\n    parenScope = this.exitScope();\n\n  this.parenScope = parenScope;\n\n  return n;\n};\n\ncls.dissolveParen = function() {\n  if (this.parenScope) {\n    this.parenScope.makeSimple();\n    this.parenScope = null;\n  }\n};\n\n\n');
resolver.set('./src/Parser/parse-debugger.js', '  import {cls} from \'./cls.js\';\n\ncls.parseDbg = \nfunction() {\n  this.resvchk();\n  this.testStmt() || this.err(\'not.stmt\');\n  this.fixupLabels(false);\n\n  var c0 = this.c0,\n      loc0 = this.loc0(),\n      c = this.c,\n      li = this.li,\n      bl = {},\n      col = this.col;\n\n  this.suc(bl, \'bef\');\n  this.next() ;\n\n  this.semi(bl, \'aft\') || this.err(\'no.semi\');\n\n  this.foundStatement = true;\n  return {\n    type: \'DebuggerStatement\',\n    loc: { start: loc0, end: this.semiLoc || { line: li, column: col } } ,\n    start: c0,\n    end: this.semiC || c,\n    \'#c\': bl\n  };\n};\n\n\n');
resolver.set('./src/Parser/surrogate.js', '  import {CH_BACK_SLASH} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readSurrogateTail =\nfunction() {\n  var c = this.c, s = this.src, l = s.length, mustSetOff = false;\n  c >= l && this.err(\'unexpected.eof.while.surrogate.tail\');\n  var surrogateTail = s.charCodeAt(c);\n  if (surrogateTail === CH_BACK_SLASH)\n    surrogateTail = this.readBS();\n  else\n    mustSetOff = true;\n\n  mustSetOff && this.setsimpoff(c+1);\n\n  return surrogateTail;\n};\n\n\n');
resolver.set('./src/Parser/read-id-surrogate.js', '  import {surrogate} from \'../other/util.js\';\n  import {isIDHead} from \'../other/ctype.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readID_surrogate =\nfunction(sc) {\n  if (this.c+1 >= this.src.length)\n    this.err(\'id.head.got.eof.surrogate\');\n\n  var surrogateTail = this.src.charCodeAt(this.c+1);\n  var ccode = surrogate(sc, surrogateTail);\n  if (!isIDHead(ccode))\n    this.err(\'surrogate.not.id.head\');\n\n  this.c += 2;\n  return this.readID_withHead(\n    String.fromCharCode(sc) +\n    String.fromCharCode(surrogateTail)\n  );\n};\n\n\n');
resolver.set('./src/Parser/parse-pat-assig.js', '  import {PREC_NONE} from \'../other/lexer-constants.js\';\n  import {CTX_TOP} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parsePat_assig = \nfunction (head) {\n  if (this.v <= 5)\n    this.err(\'ver.assig\');\n  this.spc(head, \'aft\');\n  this.next() ;\n  var e = this.parseNonSeq(PREC_NONE, CTX_TOP);\n  this.inferName(head, core(e), false);\n  return {\n    type: \'AssignmentPattern\',\n    start: head.start,\n    left: head,\n    end: e.end,\n    right: core(e),\n    loc: {\n      start: head.loc.start,\n      end: e.loc.end },\n    \'#y\': this.Y(head,e), \'#c\': {}\n  };\n};\n\n\n');
resolver.set('./src/Parser/errt.js', '  import {ERR_NONE_YET, agtb, ERR_PAREN_UNBINDABLE, ERR_SHORTHAND_UNASSIGNED, ERR_NON_TAIL_REST, ERR_ARGUMENTS_OR_EVAL_ASSIGNED, ERR_YIELD_OR_SUPER, ERR_UNEXPECTED_REST, ERR_EMPTY_LIST_MISSING_ARROW, ERR_NON_TAIL_EXPR, ERR_INTERMEDIATE_ASYNC, ERR_ASYNC_NEWLINE_BEFORE_PAREN, ERR_PIN_NOT_AN_EQ, ERR_ARGUMENTS_OR_EVAL_DEFAULT, ERR_PIN_OCTAL_IN_STRICT} from \'../other/error-constants.js\';\n  import {ASSERT, HAS} from \'../other/constants.js\';\n  import {errt_pin} from \'../other/errt.js\';\n  import {cls} from \'./cls.js\';\n\ncls.pt_override =\nfunction(pt) {\n  return this.pt !== ERR_NONE_YET &&\n    (pt === ERR_NONE_YET || agtb(this.pt, pt));\n};\n\ncls.at_override =\nfunction(at) {\n  return this.at !== ERR_NONE_YET &&\n    (at === ERR_NONE_YET || agtb(this.at, at));\n};\n\ncls.st_override =\nfunction(st) {\n  return this.st !== ERR_NONE_YET &&\n    (st === ERR_NONE_YET || agtb(this.st, st));\n};\n\ncls.pt_reset =\nfunction() { this.pt = ERR_NONE_YET; };\n\ncls.at_reset =\nfunction() { this.at = ERR_NONE_YET; };\n\ncls.st_reset =\nfunction() { this.st = ERR_NONE_YET; };\n\n// tricky map\nvar tm = {};\n\ntm[ERR_PAREN_UNBINDABLE] = \'paren.unbindable\';\ntm[ERR_SHORTHAND_UNASSIGNED] = \'shorthand.unassigned\';\ntm[ERR_NON_TAIL_REST] = \'non.tail.rest\';\ntm[ERR_ARGUMENTS_OR_EVAL_ASSIGNED] = \'assig.to.arguments.or.eval\';\ntm[ERR_YIELD_OR_SUPER] = \'param.has.yield.or.super\';\ntm[ERR_UNEXPECTED_REST] = \'unexpected.rest\';\ntm[ERR_EMPTY_LIST_MISSING_ARROW] = \'arrow.missing.after.empty.list\';\ntm[ERR_NON_TAIL_EXPR] = \'seq.non.tail.expr\';\ntm[ERR_INTERMEDIATE_ASYNC] = \'intermediate.async\';\ntm[ERR_ASYNC_NEWLINE_BEFORE_PAREN] = \'async.newline.before.paren\';\ntm[ERR_PIN_NOT_AN_EQ] = \'complex.assig.not.pattern\';\n\ncls.pt_flush =\nfunction() {\n  ASSERT.call(this, this.pt === ERR_NONE_YET,\n    \'pending errors in pt\');\n  this.st = this.at = ERR_NONE_YET;\n};\n\ncls.at_flush =\nfunction() {\n//ASSERT.call(this, this.at === ERR_NONE_YET,\n//  \'pending errors in at\');\n  // [a-=b,l=e]\n  this.at = ERR_NONE_YET;\n  this.st = this.pt = ERR_NONE_YET;\n};\n\ncls.st_flush =\nfunction() {\n  this.at = this.pt = ERR_NONE_YET;\n  if (this.st === ERR_NONE_YET)\n    return;\n  ASSERT.call(this, HAS.call(tm, this.st),\n    \'Unknown error value: \' + this.st);\n  var st = this.st, se = this.se, so = this.so;\n  this.st_reset();\n\n  var ep = {};\n  ep.tn = se;\n  if (errt_pin(st)) {\n    var pin = this.pin.s;\n    ep.c0 = pin.c0; ep.li0 = pin.li0; ep.col0 = pin.col0;\n  }\n\n  return this.err(tm[st], ep) ;\n};\n\ncls.pt_teot =\nfunction(t,e,o) { this.pt = t; this.pe = e; this.po = o; };\n\ncls.at_teot =\nfunction(t,e,o) { this.at = t; this.ae = e; this.ao = o; };\n\ncls.st_teot =\nfunction(t,e,o) { this.st = t; this.se = e; this.so = o; };\n\ncls.st_adjust_for_toAssig =\nfunction() {\n  if (this.st === ERR_ARGUMENTS_OR_EVAL_ASSIGNED)\n    this.st = ERR_ARGUMENTS_OR_EVAL_DEFAULT;\n  else\n    this.st = ERR_NONE_YET;\n};\n\ncls.pin_at =\nfunction(c0,li0,col0) { return this.pinErr(this.pin.a,c0,li0,col0); };\n\ncls.pin_ct =\nfunction(c0,li0,col0) { return this.pinErr(this.pin.c,c0,li0,col0); };\n\ncls.pin_st =\nfunction(c0,li0,col0) { return this.pinErr(this.pin.s,c0,li0,col0); };\n\ncls.pin_pt =\nfunction(c0,li0,col0) { return this.pinErr(this.pin.p,c0,li0,col0); };\n\ncls.pinErr =\nfunction(pin,c0,li0,col0) { pin.c0=c0; pin.li0=li0; pin.col0=col0; };\n\ncls.strict_esc_chk =\nfunction() {\n  if (this.ct === ERR_NONE_YET)\n    return;\n\n  ASSERT.call(this, this.ct === ERR_PIN_OCTAL_IN_STRICT,\n    \'currently the only error for strict_esc_chk is ERR_PIN_OCTAL_IN_STRICT\');\n\n  this.err(\'strict.octal\');\n};\n\n\n');
resolver.set('./src/Parser/parse-while.js', '  import {SA_BREAK, SA_CONTINUE, SF_LOOP} from \'../other/scope-constants.js\';\n  import {CH_LPAREN, CTX_TOP, CH_RPAREN} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseWhile = \nfunction () {\n  this.resvchk();\n  this.testStmt() || this.err(\'not.stmt\');\n  this.fixupLabels(true);\n\n  this.enterScope(this.scope.spawnBare());\n  var scope = this.scope; \n  this.allow(SA_BREAK|SA_CONTINUE);\n  this.scope.flags |= SF_LOOP;\n\n  var c0 = this.c0, cb = {}, loc0 = this.loc0();\n\n  this.suc(cb, \'bef\');\n  this.next(); // \'while\'\n\n  this.suc(cb, \'while.aft\');\n  if (!this.expectT(CH_LPAREN))\n    this.err(\'while.has.no.opening.paren\');\n \n  var cond = core(this.parseExpr(CTX_TOP));\n\n  this.spc(cond, \'aft\');\n  if (!this.expectT(CH_RPAREN))\n    this.err(\'while.has.no.closing.paren\');\n\n  var nbody = this.parseStatement(false);\n  this.foundStatement = true;\n\n  var scope = this.exitScope();\n  return {\n    type: \'WhileStatement\',\n    test: cond,\n    start: c0,\n    end: nbody.end,\n    loc: {\n      start: loc0,\n      end: nbody.loc.end },\n    body:nbody,\n    \'#scope\': scope, \n    \'#y\': this.Y(cond, nbody), \'#c\': cb\n  };\n};\n\n\n');
resolver.set('./src/Parser/read-id-raw.js', '  import {isIDBody} from \'../other/ctype.js\';\n  import {CH_BACK_SLASH} from \'../other/constants.js\';\n  import {ERR_NONE_YET, ERR_PIN_UNICODE_IN_RESV} from \'../other/error-constants.js\';\n  import {cp2sp, surrogate} from \'../other/util.js\';\n  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readID_withHead = \nfunction(v) {\n  var c = this.c,\n      s = this.src,\n      l = s.length,\n      surrogateTail = -1,\n      luo = c, ccode = -1;\n\n  while (c < l) {\n    var ch = s.charCodeAt(c);\n    if (isIDBody(ch)) c++;\n    else if (ch === CH_BACK_SLASH) {\n      if (luo < c)\n        v += s.substring(luo,c);\n      this.setsimpoff(c);\n      if (this.ct === ERR_NONE_YET) {\n        this.ct = ERR_PIN_UNICODE_IN_RESV;\n        this.pin_ct(this.c,this.li,this.col);\n      }\n      ch = this.readBS();\n      if (!isIDBody(ch))\n        this.err(\'id.body.esc.not.idbody\');\n      v += cp2sp(ch);\n      c = luo = this.c;\n    }\n    else if (ch >= 0x0D800 && ch <= 0x0DBFF) {\n      c++;\n      if (c>=l)\n        this.err(\'id.body.got.eof.surrogate\');\n      surrogateTail = s.charCodeAt(c);\n      if (surrogateTail < 0x0dc00 || surrogateTail > 0x0dfff)\n        this.err(\'id.body.surrogate.not.in.range\');\n      ch = surrogate(ch, surrogateTail);\n      if (!isIDBody(ch))\n        this.err(\'id.body.surrogate.not.idbody\');\n      c++;\n    }\n    else\n      break;\n  }\n\n  if (luo < c)\n    v += s.substring(luo,c);\n\n  this.setsimpoff(c);\n\n  this.ltval = v;\n  this.ltraw = this.c0_to_c();\n  this.lttype = TK_ID;\n};\n\n\n');
resolver.set('./src/Parser/reg-esc.js', '  import {CH_u, CH_v, CH_b, CH_f, CH_t, CH_r, CH_n, CH_x, CH_c, CH_D, CH_W, CH_S, CH_d, CH_w, CH_s, CH_B, CH_0, CH_9, CH_Z, CH_A, CH_a, CH_z, CH_UNDERLINE, CH_MIN, ASSERT, CH_8, CH_4, CH_7} from \'../other/constants.js\';\n  import {hex2num, makeAcceptor} from \'../other/util.js\';\n  import {isNum} from \'../other/ctype.js\';\n  import {cls} from \'./cls.js\';\n\ncls.regEsc =\nfunction(ce) {\n  var c = this.c, s = this.src, l = this.regLastOffset;\n  if (c+1 >= l)\n    return this.regErr_trailSlash();\n\n  var elem = null;\n  var c0 = this.c, li0 = this.li, col0 = this.col, luo0 = this.luo;\n  // fail early for pending SRs\n  var w = s.charCodeAt(c+1);\n  if (w !== CH_u) {\n    if (ce && this.testSRerr())\n      return null;\n  }\n  else {\n    elem = this.regEsc_u(ce);\n    if (elem || this.regErr) return elem;\n    this.rw(c0,li0,col0,luo0);\n    return this.regEsc_itself(CH_u, ce);\n  }\n\n  switch (w) {\n  case CH_v:\n    return this.regEsc_simple(\'\\v\', ce);\n  case CH_b:\n    return ce ? this.regEsc_simple(\'\\b\', ce) : this.regBbAssertion();\n  case CH_f:\n    return this.regEsc_simple(\'\\f\', ce);\n  case CH_t:\n    return this.regEsc_simple(\'\\t\', ce);\n  case CH_r:\n    return this.regEsc_simple(\'\\r\', ce);\n  case CH_n:\n    return this.regEsc_simple(\'\\n\', ce);\n  case CH_x:\n    elem = this.regEsc_hex(ce);\n    if (elem || this.regErr) return elem;\n    this.rw(c0,li0,col0,luo0);\n    return this.regEsc_itself(ce);\n  case CH_c:\n    elem = this.regEsc_control(ce);\n    if (elem || this.regErr) return elem;\n    this.rw(c0,li0,col0,luo0);\n    return this.regChar(ce); // ... but not c\n  case CH_D: case CH_W: case CH_S:\n  case CH_d: case CH_w: case CH_s:\n    return this.regClassifier();\n  case CH_B:\n    return ce ? this.regEsc_itself(w, ce) : this.regBbAssertion();\n  default:\n    if (w >= CH_0 && w <= CH_9) {\n      elem = this.regEsc_num(w, ce);\n      if (elem || this.regErr) return elem;\n      this.rw(c0,li0,col0,luo0);\n    }\n    return this.regEsc_itself(w, ce);\n  }\n};\n\ncls.regClassifier =\nfunction() {\n  var c0 = this.c, loc0 = this.loc(), t = this.src.charAt(c0+1);\n  this.setsimpoff(c0+2);\n  this.regIsQuantifiable = true;\n  return {\n    type: \'#Regex.Classifier\',\n    start: c0,\n    loc: { start: loc0, end: this.loc() },\n    end: this.c,\n    kind: t\n  };\n};\n\ncls.regEsc_hex =\nfunction(ce) { \n  var s = this.src, l = this.regLastOffset, c = this.c;\n  c += 2; // \\x\n  if (c>=l)\n    return this.rf.u ? this.regErr_hexEOF() : null;\n\n  var ch1 = hex2num(s.charCodeAt(c));\n  if (ch1 === -1) {\n    this.setsimpoff(c);\n    return this.rf.u ? this.regErr_hexEscNotHex() : null;\n  }\n  c++;\n  if (c>=l)\n    return this.rf.u ? this.regErr_hexEOF() : null;\n  var ch2 = hex2num(s.charCodeAt(c));\n  if (ch2 === -1) {\n    this.setsimpoff(c);\n    return this.rf.u ? this.regErr_hexEscNotHex() : null;\n  }\n\n  c++;\n  var ch = (ch1<<4)|ch2;\n  // Last Elem If A CharSeq\n  return this.regChar_VECI(String.fromCharCode(ch), c, ch, ce);\n};\n\ncls.regEsc_simple =\nfunction(v, ce) {\n  return this.regChar_VECI(v, this.c+2, v.charCodeAt(0), ce);\n};\n\ncls.regEsc_control =\nfunction(ce) {\n  var c0 = this.c, c = c0;\n  var s = this.src, l = this.regLastOffset;\n  c += 2; // \\c\n  if (c>=l) {\n    this.setsimpoff(c);\n    return this.rf.u ? this.regErr_controlEOF() : null;\n  }\n  var ch = s.charCodeAt(c);\n\n  INV:\n  if ((ch > CH_Z || ch < CH_A) && (ch < CH_a || ch > CH_z)) {\n    if (!this.rf.u && ce && ((ch >= CH_0 && ch <= CH_9) || ch === CH_UNDERLINE))\n      break INV;\n    this.setsimpoff(c); // TODO: unnecessary if there is no \'u\' flag\n    return this.rf.u ? this.regErr_controlAZaz(ch) : null;\n  }\n\n  c++;\n  ch &= 31;\n\n  return this.regChar_VECI(String.fromCharCode(ch), c, ch, ce);\n};\n\nvar isUIEsc = makeAcceptor(\'^$\\\\.*+?()[]{}|/\');\ncls.regEsc_itself =\nfunction(ch, ce) {\n  var c = this.c, s = this.src;\n  c++; // \\\n  if (this.rf.u) {\n    if (!isUIEsc(ch) && (!ce || ch !== CH_MIN)) {\n      this.setsimpoff(c);\n      return this.regErr_invalidUEsc(ch);\n    }\n  } else \n    ASSERT.call(this, ch !== CH_c, \'c\' );\n\n  c++;\n  return this.regChar_VECI(String.fromCharCode(ch), c, ch, ce);\n};\n\ncls.regEsc_num =\nfunction(ch, ce) {\n  var c = this.c, s = this.src, l = this.regLastOffset;\n  if (ch === CH_0)\n    return this.regEsc_num0(ce);\n  var r0 = ch;\n  var num = ch - CH_0;\n  c += 2; // \\[:num:]\n  while (c < l) {\n    ch = s.charCodeAt(c);\n    if (!isNum(ch)) break;\n    num *= 10;\n    num += ch - CH_0;\n    c++;\n  }\n  if (num <= this.regNC) {\n    var c0 = this.c, loc0 = this.loc();\n    this.setsimpoff(c);\n    return {\n      type: \'#Regex.Ref\',\n      value: num,\n      start: c0,\n      end: this.c,\n      raw: s.substring(c0, this.c),\n      loc: { start: loc0, end: this.loc() }\n    };\n  }\n  if (this.rf.u) {\n    this.setsimpoff(c);\n    return this.regErr_nonexistentRef(num);\n  }\n  if (r0 >= CH_8)\n    return null;\n  return this.regEsc_legacyNum(r0, ce);\n};\n\n// TODO: strict-chk\ncls.regEsc_legacyNum =\nfunction(ch, ce) {\n  var c = this.c, s = this.src, l = this.regLastOffset;\n  var max = ch >= CH_4 ? 1 : 2, num = ch - CH_0;\n  c += 2; // \\[:num:]\n  while (c < l) {\n    ch = s.charCodeAt(c);\n    if (ch < CH_0 || ch > CH_7) break;\n    num = (num<<3)|(ch-CH_0);\n    c++;\n    if (--max === 0) break;\n  }\n  return this.regChar_VECI(String.fromCharCode(num), c, num, ce);\n};\n\ncls.regEsc_num0 =\nfunction(ce) {\n  var c = this.c, s = this.src, l = this.regLastOffset;\n  c += 2; // \\0\n  if (c < l) {\n    var r = s.charCodeAt(c);\n    if (r >= CH_0 && r <= CH_7)\n      return this.regEsc_legacyNum(CH_0, ce);\n  }\n  return this.regEsc_simple(\'\\0\', ce);\n};\n\n\n');
resolver.set('./src/Parser/let.js', '  import {cls} from \'./cls.js\';\n\ncls.handleLet =\nfunction(letID) {\n  if (this.v<=5 || !this.scope.insideStrict())\n    return letID;\n  this.err(\'let.strict\');\n};\n\n\n');
resolver.set('./src/Parser/parse-regex.js', '  import {CH_LSQBRACKET, CH_BACK_SLASH, CH_RSQBRACKET, CH_DIV, CH_LPAREN, CH_QUESTION, CH_CARRIAGE_RETURN, CH_LINE_FEED} from \'../other/constants.js\';\n  import {isIDBody} from \'../other/ctype.js\';\n  import {cls} from \'./cls.js\';\n\n// /\\1200(*followed by 1200 ()\'s)/ becomes /(*backref=\\1200)(*1200 ()\'s)/; but, /\\1200(*followed by 1199 ()\'s)/ becomes /(*legacyEsc=\\120)(*ch=\'0\')(*1199 ()\'s);\n// this means any captureP had better get tracked below, rather than in `parseRegex`\n\ncls.parseRegexLiteral =\nfunction() {\n  this.v < 2 && this.err(\'ver.regex\');\n  var c = this.c, b = {}, s = this.src, nump = 0, l = s.length;\n  var c0 = this.c0, inClass = false, loc0 = this.loc0();\n  this.suc(b, \'bef\');\n\n  var esc = false;\n\n  REGEX:\n  while (c < l) {\n    switch (s.charCodeAt(c)) {\n    case CH_LSQBRACKET:\n      if (esc) { esc = false; break }\n      if (!inClass) inClass = true;\n      break;\n    case CH_BACK_SLASH:\n      if (esc) { esc = false; break; }\n      esc = true;\n      break;\n    case CH_RSQBRACKET:\n      if (esc) { esc = false; break; }\n      if (inClass) inClass = false;\n      break;\n    case CH_DIV:\n      if (esc) { esc = false; break; }\n      if (inClass) break;\n      break REGEX;\n    case CH_LPAREN:\n      if (esc || inClass || c+1 >= l) break;\n      if (s.charCodeAt(c+1) !== CH_QUESTION)  nump++;\n      break;\n    case CH_CARRIAGE_RETURN:\n      c+1 < l && s.charCodeAt(c+1) === CH_LINE_FEED && c++;\n    case CH_LINE_FEED:\n    case 0x2028:\n    case 0x2029:\n      this.err(esc ? \'regex.esc.newline\' : \'regex.newline\', {c0:c});\n    default:\n      if (esc) { esc = false; }\n    }\n    c++;\n  }\n\n  if (c >= l || s.charCodeAt(c) !== CH_DIV)\n    this.err(\'regex.unfinished\');\n\n  var pattern = s.substring(this.c, c);\n  c++; // \'/\'\n\n  var patternStart = this.c;\n  this.setsimpoff(c);\n\n  var flags = \"\", flagsStart = c;\n  while (c < l && isIDBody(s.charCodeAt(c))) c++;\n  flags = s.substring(flagsStart, c);\n\n  var n = this.parseRegex(patternStart, loc0.line, loc0.column+1, c, nump, flags, this.c, this.li, this.col);\n  this.setsimpoff(c);\n  var regex = {\n    type: \'Literal\',\n    regex: {\n      pattern: pattern,\n      flags: flags \n    },\n    start: c0,\n    end: c,\n    value: null,\n    loc: { start: loc0, end: this.loc() }, \n    raw: this.src.substring(c0, c),\n    \'#c\': b, \'#n\': n\n   };\n\n   this.next () ;\n   return regex ;\n};\n\n\n');
resolver.set('./src/Parser/parse-pat-array.js', '  import {TK_ELLIPSIS} from \'../other/lexer-constants.js\';\n  import {CH_COMMA, CH_RSQBRACKET} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parsePat_array = \nfunction() {\n  if (this.v <= 5)\n    this.err(\'ver.patarr\');\n\n  var c0 = this.c0, loc0 = this.loc0(),\n      elem = null, list = [];\n\n  if (this.scope.insideArgs())\n    this.scope.enterUniqueArgs();\n\n  var y = 0, cb = {};\n\n  this.suc(cb, \'bef\');\n  this.next();\n\n  cb.holes = [];\n  while (true) {\n    elem = this.parsePat();\n    if (elem && this.peekEq())\n      elem = this.parsePat_assig(elem);\n    else if (this.lttype === TK_ELLIPSIS) {\n      list.push(elem = this.parsePat_rest());\n      this.spc(elem, \'aft\');\n      break ;\n    }  \n\n    if (elem) {\n      y += this.Y(elem);\n      this.spc(elem, \'aft\');\n    } else \n      this.commentBuf && cb.holes.push([list.length, this.cc()]);\n\n    if (this.lttype === CH_COMMA) {\n      list.push(elem);\n      this.next();\n    } else  {\n      elem && list.push(elem);\n      break ;\n    }\n  }\n\n  var n = {\n    type: \'ArrayPattern\',\n    loc: { start: loc0, end: this.loc() },\n    start: c0,\n    end: this.c,\n    elements: list,\n    \'#y\': y, \'#c\': cb\n  };\n\n  this.suc(cb, \'inner\');\n  if (!this.expectT(CH_RSQBRACKET))\n    this.err(\'pat.array.is.unfinished\');\n\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/testers.js', '  import {arorev} from \'../other/util.js\';\n  import {ASSERT, PE_NO_NONVAR, PE_NO_LABEL, PE_NONE} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.ensureSAT =\nfunction(left) {\n\n  switch (left.type) {\n  case \'Identifier\':\n    if (this.scope.insideStrict() &&\n      arorev(left.name))\n      this.err(\'assig.to.arguments.or.eval\');\n  case \'MemberExpression\':\n    return true;\n  }\n\n  return false;\n};\n\ncls.patErrCheck =\nfunction() {\n  ASSERT.call(this, this.vpatCheck,\n    \'PEC msut have vpatCheck hold\');\n  this.vpatCheck = false;\n  if (!this.scope.canDeclareLexical())\n    this.vpatErr = PE_NO_NONVAR;\n  else if (this.unsatisfiedLabel)\n    this.vpatErr = PE_NO_LABEL;\n  else return false;\n\n  return true;\n};\n\ncls.setPatCheck =\nfunction(shouldCheck) {\n  if (shouldCheck) {\n    this.vpatCheck = true;\n    this.vpatErr = PE_NONE;\n  }\n};\n\n\n');
resolver.set('./src/Parser/parse-arglist.js', '  import {PREC_NONE, TK_ELLIPSIS} from \'../other/lexer-constants.js\';\n  import {CTX_NULLABLE, CTX_TOP, CTX_NONE, CH_COMMA} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseArgList = function () {\n  var c0 = -1, li0 = -1, col0 = -1, parenAsync = this.parenAsync,\n      elem = null, list = [];\n\n  var y = 0;\n\n  var argloc = this.loc0();\n  do { \n    this.next();\n    elem = this.parseNonSeq(PREC_NONE, CTX_NULLABLE|CTX_TOP); \n    if (elem)\n      list.push(core(elem));\n    else if (this.lttype === TK_ELLIPSIS)\n      list.push(elem = this.parseSpread(CTX_NONE));\n    else {\n      if (list.length !== 0) {\n        if (this.v < 7)\n          this.err(\'arg.non.tail\',\n            {c0:c0, li0:li0, col0:col0,\n            extra: {list: list, async: parenAsync}});\n      }\n      break;\n    }\n\n    y += this.Y(elem);\n    this.spc(core(elem), \'aft\');\n\n    if (this.lttype === CH_COMMA) {\n      c0 = this.c0;\n      li0 = this.li0;\n      col0 = this.col0;\n    }\n    else break;\n  } while (true);\n\n  if (parenAsync !== null)\n    this.parenAsync = parenAsync;\n\n  this.yc= y;\n  this.argploc = argloc;\n\n  return list ;\n};\n\n\n');
resolver.set('./src/Parser/new-parse-fn.js', '  import {ST_CLSMEM, ST_OBJMEM, ST_ASYNC, ST_GEN, ST_DECL, DT_FN, ST_EXPR, DT_FNNAME, ST_ACCESSOR, ST_GETTER, DT_FNARG} from \'../other/scope-constants.js\';\n  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {CTX_DEFAULT, ARGLEN_ANY, ARGLEN_GET, ARGLEN_SET} from \'../other/constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseFn =\nfunction(ctx, st) {\n  var labels_ = this.labels;\n  var declMode_ = this.declMode;\n  var isStmt = false;\n  if (this.canBeStatement) {\n    isStmt = true;\n    this.canBeStatement = false;\n  }\n\n  var isMeth = st & (ST_CLSMEM|ST_OBJMEM);\n  var isAsync = st & ST_ASYNC;\n\n  var fnName = null;\n  var declScope = null;\n\n  var c0 = this.c0, cb = {}, loc0 = this.loc0();\n  this.suc(cb, \'bef\');\n\n  var argploc = null;\n  if (!isMeth) {\n    if (isStmt && isAsync) {\n      this.unsatisfiedLabel &&\n      this.err(\'async.label.not.allowed\');\n\n      this.scope.isBare() &&\n      this.err(\'async.decl.not.allowed\');\n    }\n    this.next(); // \'function\'\n    if (this.peekMul()) {\n      this.v<=5 && this.err(\'ver.gen\');\n      if (isAsync)\n        this.err(\'async.gen.not.supported.yet\');\n      if (isStmt) {\n        this.unsatisfiedLabel &&\n        this.err(\'gen.label.not.allowed\');\n\n        this.scope.isBare() &&\n        this.err(\'gen.decl.not.allowed\');\n      }\n\n      this.suc(cb, \'fun.aft\');\n      this.next(); // \'*\'\n      st |= ST_GEN;\n    }\n    if (isStmt) {\n      if (this.scope.isBare()) {\n        if (!this.scope.insideIf() ||\n          this.scope.insideStrict())\n          this.err(\'fun.decl.not.allowed\');\n        if (this.unsatisfiedLabel)\n          this.fixupLabels(false);\n      }\n      else if (this.unsatisfiedLabel)\n        this.scope.insideStrict() &&\n        this.err(\'func.label.not.allowed\');\n\n      st |= ST_DECL;\n      if (this.lttype === TK_ID) {\n        this.declMode = DT_FN|this.cutEx();\n        declScope = this.scope; \n        fnName = this.parsePat();\n      }\n      else if (!(ctx & CTX_DEFAULT))\n        this.err(\'fun.decl.has.got.no.actual.name\');\n    }\n    else {\n      st |= ST_EXPR ;\n      if (this.lttype === TK_ID)\n        fnName = this.getName_fn(st);\n    }\n  }\n\n  this.enterScope(this.scope.spawnFn(st));\n  if (fnName) {\n    if (isStmt)\n      this.scope.setName(\n        fnName.name,\n        declScope.findDeclOwn_m(_m(fnName.name))\n      ).t(DT_FNNAME).s(fnName);\n    else\n      this.scope.setName(fnName.name, null).t(DT_FNNAME).s(fnName);\n  }\n\n  var argLen =\n    !isMeth || !(st & ST_ACCESSOR) ?\n      ARGLEN_ANY :\n      (st & ST_GETTER) ?\n        ARGLEN_GET :\n        ARGLEN_SET;\n\n  this.declMode = DT_FNARG;\n\n  this.suc(cb, \'list.bef\' );\n  var argList = this.parseParams(argLen);\n  argploc = this.argploc; this.argploc = null;\n  cb.inner = this.cb;\n\n  this.scope.activateBody();\n\n  this.labels = {};\n\n  var nbody = this.parseFunBody();\n  var scope = this.exitScope();\n\n  var n = {\n    type: isStmt ? \'FunctionDeclaration\' : \'FunctionExpression\',\n    id: fnName,\n    start: c0,\n    end: nbody.end,\n    generator: (st & ST_GEN) !== 0,\n    body: nbody,\n    loc: { start: loc0, end: nbody.loc.end },\n    params: argList,\n    expression: false,\n    async: (st & ST_ASYNC) !== 0,\n    \'#scope\': scope, \'#y\': 0, \'#c\': cb , \n    \'#argploc\': argploc\n  };\n\n  this.declMode = declMode_;\n  this.labels = labels_;\n\n  if (isStmt)\n    this.foundStatement = true;\n\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/parse-spread.js', '  import {PREC_NONE} from \'../other/lexer-constants.js\';\n  import {PAREN_NODE} from \'../other/constants.js\';\n  import {errt_ptrack, errt_atrack} from \'../other/errt.js\';\n  import {ERR_PAREN_UNBINDABLE} from \'../other/error-constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseSpread = \nfunction(ctx) {\n  this.v <= 5 && this.err(\'ver.spread.rest\');\n\n  var c0 = this.c0, cb = {}, loc0 = this.loc0();\n\n  this.suc(cb, \'bef\' );\n  this.next();\n\n  var arg = this.parseNonSeq(PREC_NONE, ctx);\n  if (arg === null)\n    this.err(\'spread.arg.is.null\');\n\n  if (arg.type === PAREN_NODE) {\n    if (errt_ptrack(ctx)) { \n      this.pt = ERR_PAREN_UNBINDABLE;\n      this.pe = arg;\n    }\n    if (errt_atrack(ctx) && !this.ensureSAT(arg.expr)) {\n      this.at = ERR_PAREN_UNBINDABLE;\n      this.ae = arg;\n    }\n  }\n    \n  return {\n    type: \'SpreadElement\',\n    loc: { start: loc0, end: arg.loc.end },\n    start: c0,\n    end: arg.end,\n    argument: core(arg),\n    \'#c\': cb,\n    \'#y\': this.Y(arg)\n  };\n};\n\n\n');
resolver.set('./src/Parser/read-op-min.js', '  import {CH_MIN, CH_EQUALITY_SIGN} from \'../other/constants.js\';\n  import {TK_AA_MM, TK_OP_ASSIG, TK_UNBIN} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readOp_min =\nfunction() {\n  var c = this.c; c++; // \'-\'\n  var ch = this.scat(c);\n  if (ch === CH_MIN) {\n    c++;\n    this.lttype = TK_AA_MM;\n    this.ltraw = \'--\';\n  }\n  else if (ch === CH_EQUALITY_SIGN) {\n    c++;\n    this.lttype = TK_OP_ASSIG;\n    this.ltraw = \'-=\';\n  }\n  else {\n    this.lttype = TK_UNBIN;\n    this.ltraw = \'-\';\n  }\n\n  this.setsimpoff(c);\n};\n\n\n');
resolver.set('./src/Parser/parse-memname.js', '  import {PREC_NONE} from \'../other/lexer-constants.js\';\n  import {CTX_NULLABLE, CTX_TOP, PAREN, CH_RSQBRACKET} from \'../other/constants.js\';\n  import {CB, core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.mem_id = \nfunction() {\n  if (this.v>5)\n    return this.id();\n\n  this.validate(this.ltval);\n  return this.id();\n};\n\ncls.mem_expr = \nfunction() {\n  if (this.v <= 5)\n    this.err(\'ver.mem.comp\');\n\n  var c0 = this.c0, b = this.cc(), loc0 = this.loc0();\n  this.next() ;\n  \n  // none of the modifications memberExpr may make to this.pt, this.at, and this.st\n  // overwrite some other unrecorded this.pt, this.at, or this.st -- an unrecorded value of <pt:at:st>\n  // means a whole elem was just parsed, and <pt:at:st> is immediately recorded after that whole\n  // potpat element is parsed, so if a memberExpr overwrites <pt:at:st>, that <pt:at:st> is not an\n  // unrecorded one.\n  \n  // TODO: it is not necessary to reset <pt:at>\n  this.pt = this.at = this.st = 0;\n\n  // TODO: should be CTX_NULLABLE, or else the next line is in vain  \n  var e = this.parseNonSeq(PREC_NONE, CTX_NULLABLE|CTX_TOP);\n  e || this.err(\'prop.dyna.no.expr\');\n\n  var cb = CB(e);\n  if (cb.bef) cb.bef.c = b.c.concat(cb.bef.c);\n  else cb.bef = b;\n\n  var n = {\n    type: PAREN,\n    expr: core(e), \n    start: c0,\n    end: this.c,\n    loc: { start: loc0, end: this.loc() }\n  };\n\n  this.spc(core(e), \'aft\');\n  if (!this.expectT(CH_RSQBRACKET))\n    this.err(\'prop.dyna.is.unfinished\');\n\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/cls.js', '  import {VDT_NONE} from \'../other/lexer-constants.js\';\n  import {DT_NONE} from \'../other/scope-constants.js\';\n  import {ERR_NONE_YET} from \'../other/error-constants.js\';\n\nexport default function Parser(src, o) {\n\n  this.src = src;\n  this.unsatisfiedLabel = null;\n  this.nl = false;\n\n  this.ltval = null;\n  this.lttype= \"\";\n  this.ltraw = \"\" ;\n  this.prec = 0 ;\n  this.vdt = VDT_NONE;\n\n  this.labels = {};\n\n  this.li0 = 0;\n  this.col0 = 0;\n  this.c0 = 0;\n\n  this.li = 1;\n  this.col = 0;\n  this.c = 0;\n\n  this.luo = 0; // latest used offset\n \n  this.canBeStatement = false;\n  this.foundStatement = false;\n\n  this.isScript = !o || o.sourceType === \'script\';\n  this.v = 7;\n\n  this.first__proto__ = false;\n\n  this.scope = null;\n  this.declMode = DT_NONE;\n \n  this.exprHead = null;\n\n  // ERROR TYPE           CORE ERROR NODE    OWNER NODE\n  this.pt = ERR_NONE_YET; this.pe = null; this.po = null; // paramErr info\n  this.at = ERR_NONE_YET; this.ae = null; this.ao = null; // assigErr info\n  this.st = ERR_NONE_YET; this.se = null; this.so = null; // simpleErr info\n\n  this.suspys = null;\n  this.missingInit = false;\n\n  this.yc= -1; // occasionally used to put yield counts in\n  this.ex = DT_NONE;\n\n  this.bundleScope = null;\n\n  this.bundler = null;\n  this.chkDirective = false;\n  this.alreadyApplied = false;\n  // \"pin\" location; for errors that might not have been precisely caused by a syntax node, like:\n  // function l() { \'\\12\'; \'use strict\' }\n  //                 ^\n  // \n  // for (a i\\u0074 e) break;\n  //         ^\n  //\n  // var e = [a -= 12] = 5\n  //            ^\n  this.ct = ERR_NONE_YET;\n  this.pin = {\n    c: { c:-1, li:-1, col:-1 },\n    a: { c:-1, li:-1, col:-1 },\n    s: { c:-1, li:-1, col:-1 },\n    p: { c:-1, li:-1, col:-1 }\n  };\n\n  this.cb = null;\n  this.parenAsync = null; // so that things like (async)(a,b)=>12 will not get to parse.\n  this.commentBuf = null;\n  this.errorListener = this; // any object with an `onErr(errType \"string\", errParams {*})` will do\n  this.parenScope = null;  \n\n  this.regPendingBQ = null;\n  this.regPendingCQ = false;\n  this.regLastBareElem = null;\n  this.regErr = null;\n  this.regIsQuantifiable = false;\n  this.regSemiRange = null;\n  this.regCurlyChar = false;\n  this.regLastOffset = -1;\n  this.regNC = -1;\n\n  this.regexFlags = this.rf = {};\n\n  this.commentCallback = null;\n\n  this.argploc = null;\n\n  this.pure = false; // pure-ness\n};\n\n export var cls = Parser.prototype;\n');
resolver.set('./src/Parser/comment-helpers.js', '  import {CB, cmn_ac} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.cc =\nfunction() { // cuts comments\n  var commentBuf = this.commentBuf;\n  this.commentBuf = null;\n  return commentBuf;\n};\n\ncls.augmentCB =\nfunction(n, i, c) {\n  if (c === null)\n    return;\n  var cb = n[\'#c\'];\n  if (!cb[i])\n    cb[i] = c;\n  else\n    cb[i].mergeWith(c);\n}\ncls.suc =\nfunction(cb, i) {\n  cb[i] = this.cc();\n};\n\ncls.spc =\nfunction(n, i) {\n  var cb = CB(n);\n  cmn_ac(cb, i, this.cc());\n};\n\n\n');
resolver.set('./src/Parser/parse-obj.js', '  import {CTX_NONE, CTX_PAT, CTX_PARPAT, CTX_PARPAT_ERR, CTX_TOP, CTX_HAS_A_PARAM_ERR, CTX_HAS_AN_ASSIG_ERR, CTX_HAS_A_SIMPLE_ERR, CH_COMMA, CH_RCURLY} from \'../other/constants.js\';\n  import {ERR_NONE_YET} from \'../other/error-constants.js\';\n  import {errt_track, errt_ptrack, errt_atrack, errt_strack, errt_pin, errt_psyn, errt_asyn, errt_ssyn, errt_perr, errt_aerr, errt_serr} from \'../other/errt.js\';\n  import {ST_OBJMEM} from \'../other/scope-constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseObj = function(ctx) {\n  var c0 = this.c0, loc0 = this.loc0(),\n      elem = null, list = [], first__proto__ = null,\n      elctx = CTX_NONE,\n      pt = ERR_NONE_YET, pe = null, po = null,\n      at = ERR_NONE_YET, ae = null, ao = null,\n      st = ERR_NONE_YET, se = null, so = null,\n      n = null;\n\n  var cb = {};\n  this.suc(cb , \'bef\');\n  if (ctx & CTX_PAT) {\n    elctx |= ctx & CTX_PARPAT;\n    elctx |= ctx & CTX_PARPAT_ERR;\n  }\n  else \n    elctx |= CTX_TOP;\n\n  if (errt_track(ctx)) {\n    errt_ptrack(ctx) && this.pt_reset();\n    errt_atrack(ctx) && this.at_reset();\n    errt_strack(ctx) && this.st_reset();\n  }\n\n  var pc0 = -1, pli0 = -1, pcol0 = -1;\n  var ac0 = -1, ali0 = -1, acol0 = -1;\n  var sc0 = -1, sli0 = -1, scol0 = -1;\n\n  var y = 0, ci = -1;\n  do {\n    elem && this.spc(elem, \'aft\');\n    this.next();\n    this.first__proto__ = first__proto__;\n    elem = this.parseMem(elctx, ST_OBJMEM);\n\n    if (elem === null)\n      break;\n\n    y += this.Y(elem);\n\n    if (!first__proto__ && this.first__proto__)\n      first__proto__ = this.first__proto__;\n\n    list.push(core(elem));\n    if (ci === -1 && core(elem).computed)\n      ci = list.length - 1;\n\n    if (!errt_track(elctx))\n      continue;\n\n    if (errt_ptrack(elctx) && this.pt_override(pt)) {\n      pt = this.pt, pe = this.pe, po = elem;\n      if (errt_pin(pt))\n        pc0 = this.pin.p.c0, pli0 = this.pin.p.li0, pcol0 = this.pin.p.col0;\n      if (errt_psyn(pt))\n        elctx |= CTX_HAS_A_PARAM_ERR;\n    }\n    if (errt_atrack(elctx) && this.at_override(at)) {\n      at = this.at; ae = this.ae; ao = elem;\n      if (errt_pin(at))\n        ac0 = this.pin.a.c0, ali0 = this.pin.a.li0, acol0 = this.pin.a.col0;\n      if (errt_asyn(at))\n        elctx |= CTX_HAS_AN_ASSIG_ERR;\n    }\n    if (errt_strack(elctx) && this.st_override(st)) {\n      st = this.st; se = this.se; so = elem;\n      if (errt_pin(st))\n        sc0 = this.pin.s.c0, sli0 = this.pin.s.li0, scol0 = this.pin.s.col0;\n      if (errt_ssyn(st))\n        elctx |= CTX_HAS_A_SIMPLE_ERR;\n    }\n  } while (this.lttype === CH_COMMA);\n\n  elem ? this.spc(core(elem), \'aft\') : this.suc(cb, \'inner\');\n\n  n = {\n    properties: list,\n    type: \'ObjectExpression\',\n    start: c0,\n    end: this.c,\n    loc: { start: loc0, end: this.loc() }, \n    \'#c\': cb,\n    \'#ci\': ci,\n    \'#y\': y, \'#rest\': -1 /* rest */, \'#t\': null\n  };\n\n  if (errt_perr(ctx,pt)) {\n    this.pt_teot(pt,pe,po);\n    errt_pin(pt) && this.pin_pt(pc0,pli0,pcol0);\n  }\n  if (errt_aerr(ctx,at)) {\n    this.at_teot(at,ae,ao);\n    errt_pin(at) && this.pin_at(ac0,ali0,acol0);\n  }\n  if (errt_serr(ctx,st)) {\n    this.st_teot(st,se,so);\n    errt_pin(st) && this.pin_st(sc0,sli0,scol0);\n  }\n\n  if (!this.expectT(CH_RCURLY))\n    this.err(\'obj.unfinished\');\n\n  return n;\n};\n\n\n\n');
resolver.set('./src/Parser/parse-program.js', '  import GlobalScope from \'../GlobalScope/cls.js\';\n  import {ASSERT} from \'../other/constants.js\';\n  import SourceScope from \'../SourceScope/cls.js\';\n  import {ST_SCRIPT} from \'../other/scope-constants.js\';\n  import {TK_EOF} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseProgram = function () {\n  var c0 = this.c, li0 = this.li, col0 = this.col;\n  var ec = -1, eloc = null;\n\n  if (this.bundler === null && this.bundleScope === null)\n    this.bundleScope = new GlobalScope();\n\n  ASSERT.call(this, this.bundleScope, \'bundleScope\');\n  this.scope = new SourceScope(this.bundleScope, ST_SCRIPT);\n\n  this.scope.synthBase = this.bundleScope ;\n\n  this.scope.parser = this;\n  if (!this.isScript)\n    this.scope.makeStrict();\n\n  this.next();\n\n  this.enterPrologue();\n  var list = this.stmtList(); \n\n  this.scope.finish();\n\n  var cb = {};\n  list.length || this.suc(cb, \'inner\');\n\n  var n = {\n    type: \'Program\',\n    body: list,\n    start: 0,\n    end: this.src.length,\n    sourceType: !this.isScript ? \"module\" : \"script\" ,\n    loc: {\n      start: {line: li0, column: col0},\n      end: {line: this.li, column: this.col}\n    }, \n    \'#scope\': this.scope,\n    \'#c\': cb,\n    \'#y\': 0, \n    \'#imports\': null,\n    \'#uri\': \"\"\n  };\n\n  if (!this.expectT(TK_EOF))\n    this.err(\'program.unfinished\');\n\n  var bundler = this.bundler;\n  if (bundler) {\n    ASSERT.call(this, bundler.bundleScope === this.bundleScope, \'bundler\\\'s scope is not the same as parser\\\'s\' );\n    bundler.save(n);\n    n[\'#imports\'] = n[\'#scope\'].satisfyWithBundler(bundler);\n  }\n\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/scope.js', 'import {ASSERT} from \'../other/constants.js\';\nimport {DT_NONE, DT_LET, DT_CONST} from \'../other/scope-constants.js\';\nimport {_m} from \'../other/scope-util.js\';\nimport {cls} from \'./cls.js\';\n\ncls.declare = function(id) {\n  ASSERT.call(this, this.declMode !== DT_NONE, \'Unknown declMode\');\n  if (this.declMode & (DT_LET|DT_CONST)) {\n    if (id.name === \'let\')\n      this.err(\'lexical.name.is.let\');\n  }\n\n  var decl = this.scope.decl_m(_m(id.name), this.declMode);\n  if (!decl.site) {\n    ASSERT.call(this, decl.site === null, \'null\');\n    decl.s(id);\n  }\n\n  id[\'#ref\'] = decl.ref;\n\n  // lexport {e as E}; lexport var e = 12\n  var entry = null;\n\n  if (decl.isExported()) {\n    entry = this.scope.registerExportedEntry_oi(id.name, id, id.name);\n    this.scope.regulateOwnExport(entry);\n    this.scope.refreshUnresolvedExportsWith(decl);\n  }\n  else {\n    var sourceScope = decl.ref.scope;\n    sourceScope.isSourceLevel() && sourceScope.refreshUnresolvedExportsWith(decl);\n  }\n};\n\ncls.enterScope = function(scope) {\n  this.scope = scope;\n};\n\ncls.exitScope = function() {\n  var scope = this.scope;\n  scope.finish();\n  this.scope = this.scope.parent;\n  return scope;\n};\n\ncls.allow = function(allowedActions) {\n  this.scope.actions |= allowedActions;\n};\n\n\n');
resolver.set('./src/Parser/new-validate.js', '  import {cls} from \'./cls.js\';\n\ncls.isResv =\nfunction (name) {\n  switch (name.length) {\n  case 1:\n    return false;\n  case 2: \n    switch (name) {\n    case \'do\': case \'if\': case \'in\':\n      return true;\n    }\n    return false;\n\n  case 3:\n    switch (name) {\n    case \'int\' :\n      return this.v<=5;\n    case \'let\' :\n      return this.scope.insideStrict();\n    case \'var\': case \'for\':\n    case \'try\': case \'new\' :\n      return true;\n    }\n    return false;\n\n  case 4:\n    switch (name) {\n    case \'byte\': case \'char\':\n    case \'goto\': case \'long\':\n      return this.v<=5;\n\n    case \'case\': case \'else\':\n    case \'this\': case \'void\':\n    case \'with\': case \'enum\':\n    case \'true\': case \'null\':\n      return true;\n    }\n    return false;\n\n  case 5:\n    switch (name) {\n    case \'await\':\n      return !this.isScript ||\n        this.scope.canAwait();\n\n    case \'final\':\n    case \'float\':\n    case \'short\':\n      return this.v<=5;\n    \n    case \'yield\': \n      return this.scope.insideStrict() ||\n        this.scope.canYield();\n\n    case \'break\': case \'catch\':\n    case \'class\': case \'const\':\n    case \'false\': case \'super\':\n    case \'throw\': case \'while\': \n      return true;\n    }\n    return false;\n\n  case 6:\n    switch (name) {\n    case \'double\': case \'native\': case \'throws\':\n      return this.v<=5;\n    case \'public\':\n      return this.v<=5 ||\n        this.scope.insideStrict();\n    case \'static\':\n      return this.scope.insideStrict();\n    case \'delete\': case \'export\':\n    case \'import\': case \'typeof\':\n    case \'switch\': case \'return\': \n      return true;\n    }\n    return false;\n\n  case 7:\n    switch (name) {\n    case \'extends\':\n    case \'default\':\n    case \'finally\':\n      return true;\n    case \'package\':\n    case \'private\':\n      return this.v<=5 ||\n        this.scope.insideStrict();\n    case \'boolean\':\n      return this.v<=5;\n    }\n    return false;\n\n  case 8:\n    switch (name) {\n    case \'abstract\':\n    case \'volatile\':\n      return this.v<=5;\n    case \'continue\':\n    case \'debugger\':\n    case \'function\':\n      return true;\n    }\n    return false;\n\n  case 9:\n    switch (name) {\n    case \'protected\':\n    case \'interface\':\n      return this.scope.insideStrict() ||\n        this.v<=5;\n    case \'transient\':\n      return this.v<=5;\n    }\n    return false;\n\n   case 10:\n     switch (name) {\n     case \'implements\':\n       return this.v <= 5 ||\n         this.scope.insideStrict();\n\n     case \'instanceof\':\n       return true;\n     }\n     return false;\n\n  case 12:\n    return this.v<=5 && name === \'synchronized\';\n  default: return false;\n  }\n};\n\ncls.validate =\nfunction(name) {\n  this.isResv(name) && this.ri();\n};\n\n\n');
resolver.set('./src/Parser/parse-pat-obj-new.js', '  import {TK_ID, TK_NUM} from \'../other/lexer-constants.js\';\n  import {CH_LSQBRACKET, CH_SINGLE_QUOTE, CH_MULTI_QUOTE, CH_COLON, PAREN, CH_COMMA, CH_RCURLY} from \'../other/constants.js\';\n  import {arorev, core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parsePat_obj =\nfunction() {\n  this.v<=5 && this.err(\'ver.patobj\');\n\n  var isID = false, c0 = this.c0, loc0 = this.loc0();\n  var name = null, val = null, list = [], isShort = false;\n\n  if (this.scope.insideArgs())\n    this.scope.enterUniqueArgs();\n\n  var cb = {}, ci = -1, y = 0;\n\n  this.suc(cb, \'bef\');\n  var elem = null;\n\n  LOOP:\n  do {\n    elem && this.spc(elem, \'aft\');\n    this.next();\n    var y0 = 0;\n    switch (this.lttype) {\n    case TK_ID:\n      isID = true;\n      name = this.id();\n      break;\n\n    case CH_LSQBRACKET:\n      name = this.mem_expr();\n      y0 += this.Y(name);\n      break;\n\n    case TK_NUM:\n      name = this.getLit_num();\n      break;\n\n    case CH_SINGLE_QUOTE:\n    case CH_MULTI_QUOTE:\n      name = this.parseString(this.lttype);\n      break;\n\n    default: break LOOP;\n    }\n\n    isShort = isID;\n    if (isID) {\n      if (this.expectT(CH_COLON)) {\n        isShort = false;\n        val = this.parsePat();\n      }\n      else {\n        this.validate(name.name);\n        this.declare(name);\n        if (this.scope.insideStrict() && arorev(name.name))\n          this.err(\'bind.arguments.or.eval\');\n        val = name;\n      }\n    }\n    else {\n      if (!this.expectT(CH_COLON))\n        this.err(\'obj.pattern.no.:\');\n      val = this.parsePat();\n    }\n\n    if (val === null)\n      this.err(\'obj.prop.is.null\');\n\n    if (this.peekEq())\n      val = this.parsePat_assig(val);\n\n    y0 += this.Y(val);\n    y += y0;\n\n    list.push(elem = {\n      type: \'Property\',\n      start: name.start,\n      key: core(name),\n      end: val.end,\n      loc: {\n        start: name.loc.start,\n        end: val.loc.end },\n      kind: \'init\',\n      computed: name.type === PAREN,\n      value: val,\n      method: false, \n      shorthand: isShort,\n      \'#y\': y0, \'#c\': {}\n    });\n    if (ci === -1 && name.type === PAREN)\n      ci = list.length - 1;\n  } while (this.lttype === CH_COMMA);\n\n  var n = {\n    properties: list,\n    type: \'ObjectPattern\',\n    loc: { start: loc0, end: this.loc() },\n    start: c0,\n    end: this.c,\n    \'#y\': y, \'#ci\': ci, \'#c\': {}, \'#rest\': -1\n  };\n\n  if (!this.expectT(CH_RCURLY))\n    this.err(\'pat.obj.is.unfinished\');\n\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/new-parse-async.js', '  import {INTERMEDIATE_ASYNC, CTX_PAT, CH_LPAREN} from \'../other/constants.js\';\n  import {ERR_INTERMEDIATE_ASYNC, ERR_ASYNC_NEWLINE_BEFORE_PAREN} from \'../other/error-constants.js\';\n  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {ST_ASYNC} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseAsync_otherID =\nfunction(asyncID, ctx) {\n  this.cutEx();\n  if (this.nl)\n    return asyncID;\n\n  this.validate(this.ltval);\n\n  var id = this.id();\n  var n = {\n    type: INTERMEDIATE_ASYNC,\n    id: id,\n    start: asyncID.start,\n    loc: asyncID.loc,\n    asyncID: asyncID\n  };\n\n  this.st = ERR_INTERMEDIATE_ASYNC;\n  this.se = n;\n\n  return n;\n};\n\ncls.parseAsync_exprHead =\nfunction(asyncID, ctx) {\n  if (!(ctx & CTX_PAT))\n    return asyncID;\n\n  if (this.lttype === TK_ID)\n    return this.parseAsync_otherID(asyncID, ctx);\n\n  if (this.lttype !== CH_LPAREN)\n    return asyncID;\n\n  var stmt = this.canBeStatement; // save\n  if (stmt)\n    this.canBeStatement = false;\n\n  var nl = this.nl;\n  this.cutEx();\n\n  this.spc(asyncID, \'aft\');\n  var list = this.parseParen(CTX_PAT), n = null;\n\n  var cb = {};\n  if (list[\'#c\'].inner)\n    cb.inner = list[\'#c\'].inner;\n\n  n = {\n    type: \'CallExpression\',\n    callee: asyncID,\n    start: asyncID.start,\n    end: list.end,\n    arguments: list.expr ?\n      list.expr.type === \'SequenceExpression\' ?\n        list.expr.expressions :\n        [list.expr] :\n      [],\n    loc: {\n      start: asyncID.loc.start,\n      end: list.loc.end\n    },\n    \'#y\': this.Y(list), \'#c\': cb\n  };\n\n  if (nl) {\n    this.pt = ERR_ASYNC_NEWLINE_BEFORE_PAREN;\n    this.pe = n;\n  }\n\n  if (stmt)\n    this.canBeStatement = true; // restore\n\n  return n;\n};\n\ncls.parseAsync_fn =\nfunction(asyncID, ctx) {\n  if (this.nl) \n    return asyncID;\n\n  var asyncFn = this.parseFn(ctx, ST_ASYNC);\n  asyncFn.start = asyncID.start;\n  asyncFn.loc.start = asyncID.loc.start;\n\n  asyncFn[\'#c\'][\'async.bef\'] = asyncID[\'#c\'].bef;\n  return asyncFn;\n};\n\ncls.parseAsync =\nfunction(asyncID, ctx) {\n  if (this.peekID(\'function\'))\n    return this.parseAsync_fn(asyncID, ctx);\n\n  this.cutEx();\n  return this.parseAsync_exprHead(asyncID, ctx);\n};\n\n\n');
resolver.set('./src/Parser/err-listener.js', '  import {HAS} from \'../other/constants.js\';\n  import ErrorString from \'../ErrorString/cls.js\';\n  import Template from \'../Template/cls.js\';\n  import {cls} from \'./cls.js\';\n\ncls.onErr = function(errorType, errParams) {\n   var message = \"\";\n   if (!HAS.call(ErrorBuilders, errorType))\n     message = \"Error: \" + errorType + \"\\n\" +\n       this.src.substr(this.c-120,120) +\n       \">>>>\" + this.src.charAt(this.c+1) + \"<<<<\" +\n       this.src.substr(this.c, 120);\n\n   else {\n     var errorBuilder = ErrorBuilders[errorType];  \n     var errorInfo = this.buildErrorInfo(errorBuilder, errParams);\n\n     var offset = errorInfo.c0,\n         line = errorInfo.li0,\n         column = errorInfo.col0,\n         errMessage = errorInfo.messageTemplate.applyTo(errParams);\n\n     message += \"Error: \"+line+\":\"+column+\" (src@\"+offset+\"): \"+errMessage;\n\n     // TODO: add a way to print a \'pin-range\', i.e., the particular chunk of the\n     // source code that is causing the error\n   }\n\n   throw new Error(message);\n};\n  \n// TODO: find a way to squash it with normalize\ncls.buildErrorInfo = function(builder, params) {\n  if (builder.preprocessor !== null)\n    builder.preprocessor.call(params);\n\n  var errInfo = {\n    messageTemplate: builder.messageTemplate,\n    c: -1, li: -1, col: -1,\n    c0: -1, li0: -1, col0: -1,\n    parser: params[\'parser\'],\n    extra: params.extra\n  };\n\n  var cur0 = params.cur0, cur = params.cur;\n\n  if (HAS.call(builder, \'tn\')) {\n    var tn = builder.tn.applyTo(params);\n    if (HAS.call(tn,\'start\')) cur0.c = tn.start;\n    if (HAS.call(tn,\'end\')) cur.c = tn.end;\n    if (HAS.call(tn,\'loc\')) {\n      if (HAS.call(tn.loc, \'start\')) {\n        cur0.loc.li = tn.loc.start.line;\n        cur0.loc.col = tn.loc.start.column;\n      }\n      if (HAS.call(tn.loc, \'end\')) {\n        cur.loc.li = tn.loc.end.line;\n        cur.loc.col = tn.loc.end.column;\n      }\n    }\n  }\n\n  if (HAS.call(builder, \'cur0\'))\n    cur0 = builder.cur0.applyTo(params);\n\n  if (HAS.call(builder, \'cur\'))\n    cur = builder.cur.applyTo(params);\n\n  if (HAS.call(builder, \'loc0\'))\n    cur0.loc = builder.loc0.applyTo(params);\n\n  if (HAS.call(builder, \'loc\'))\n    cur.loc = builder.loc.applyTo(params);\n\n  if (HAS.call(builder, \'li0\'))\n    cur0.loc.li = builder.li0.applyTo(params);\n\n  if (HAS.call(builder, \'li\'))\n    cur.loc.li = builder.li.applyTo(params);\n\n  if (HAS.call(builder, \'col0\'))\n    cur0.loc.col = builder.col0.applyTo(params);\n\n  if (HAS.call(builder, \'col\'))\n    cur.loc.col = builder.col.applyTo(params);\n\n  if (HAS.call(builder, \'c0\'))\n    cur0.c = builder.c0.applyTo(params);\n\n  if (HAS.call(builder, \'c\'))\n    cur.c = builder.c.applyTo(params);\n\n  errInfo.c0 = cur0.c; errInfo.li0 = cur0.loc.li; errInfo.col0 = cur0.loc.col;\n  errInfo.c = cur.c; errInfo.li = cur.loc.li; errInfo.col = cur.loc.col;\n\n  return errInfo;\n};\n\nvar ErrorBuilders = {};\nfunction a(errorType, builderOutline) {\n  if (HAS.call(ErrorBuilders, errorType))\n    throw new Error(\'Error type has already got a builder: <\'+errorType+\'>\');\n  var builder = {preprocessor:null};\n  for (var name in builderOutline) {\n    if (name === \'m\')\n      builder.messageTemplate = ErrorString.from(builderOutline[name]);\n    else if (name === \'p\')\n      builder.preprocessor = builderOutline.p; \n    else\n      builder[name] = Template.from(builderOutline[name]);\n  }\n\n  ErrorBuilders[errorType] = builder;\n\n  return builder;\n}\n\nfunction set(newErrorType, existingErrorType) {\n  if (HAS.call(ErrorBuilders, newErrorType))\n    throw new Error(\'cannot override the existing <\'+\n      newErrorType+\'> with <\'+existingErrorType);\n  if (!HAS.call(ErrorBuilders, existingErrorType))\n    throw new Error(\'error is not defined: <\'+existingErrorType+\'>\');\n  \n  var builder = ErrorBuilders[existingErrorType];\n  ErrorBuilders[newErrorType] = builder;\n\n  return builder;\n}\n\n// TODO: the argument that is coming last is a sample error code; builders must have this value as a property.\n// also a list of options may come after each of these \"samples\" signifying which options they should be parsed with\n\na(\'arg.non.tail\', {c0:\'c0\', li0:\'li0\',col0:\'col0\', m: \'unexpected comma -- tail arguments not allowed in versions before 7\'}, \'a(b,)\');\n\na(\'arg.non.tail.in.func\', {c0:\'c0\',li0:\'li0\',col0:\'col0\', m: \'unexpected comma -- tail parameters not allowed in versions before 7\'}, \'function a(b,) {}\', \'(a,)=>b\');\n\na(\'array.unfinished\', {c0:\'parser.c0\', li0: \'parser.li0\', col0: \'parser.col0\', m: \'a \\\']\\\' was expected -- got {parser.lttype}\'}, \'[a 12\');\n\na(\'arrow.has.a.paren.async\', {tn: \'parser.parenAsync\', m: \'\\\'async\\\' can not have parentheses around it (the \\\'=>\\\' at {parser.li0}:{parser.col0} (offset {parser.c0}) requires this to hold\'}, \'(async)(a,b)=>12\');\n\na(\'arrow.newline.before.paren.async\', {tn:\'parser.pe\', m: \'\\\'async\\\' of an async can not have a newline after it\'}, \'async\\n(a)=>12\');\n\na(\'arrow.arg.is.await.in.an.async\', {tn:\'tn\', m: \'await is not allowed as an async arrow\\\'s parameter\'}, \'async(a=await)=>12\');\n\na(\'arrow.missing.after.empty.list\', {c0:\'parser.se.end\', li0:\'parser.se.loc.end.line\', col0: \'parser.se.loc.end.column\', m:\'unexpected \\\')\\\'\'}, \'()\');\n\na(\'assig.not.first\', {c0:\'parser.c0\', li0:\'parser.li0\', col0:\'parser.col0\', m: \'Unexpected \\\'=\\\'\'}, \'a-b=12\');\n\na(\'assig.not.simple\', {tn:\'tn\', m: \'an identifier or a member expression was expected; instead got a {tn.type}\'}, \'([a])--\');\n\na(\'assig.to.arguments.or.eval\', {tn:\'parser.se\', m:\'can not assign to {parser.se.name} while in strict mode\'}, \'\"use strict\"; [arguments] = 12\');\n\na(\'async.gen.not.yet.supported\', {c0:\'parser.c0\', li0:\'parser.li0\',col0:\'parser.col0\', m:\'unexpected \\\'*\\\' -- async generators not yet supported\'}, \'async function *l() {}\');\n\na(\'async.newline\', {c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'unexpected newline after async -- async modifier in an object can not have a newline after it\'}, \'({async l(){}})\');\n\na(\'await.args\', {c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'an async function may not contain \\\'await\\\' anywhere in its parameter list\'}, \'async function l(e=[await]) {}\', \'async function l(await) {}\');\n\n// TODO: await.label\n\na(\'await.in.strict\', {c0:\'parser.c0\',li0:\'parserl.li0\',col0:\'parser.col0\',m: \'await is a reserved word when in a module, no matter it is in an async function or not\'}, \'await = 12\');\n\na(\'rest.binding.arg.not.id\', {tn:\'tn.argument\',m:\'binding rests can only have an argument of type \\\'Identifier\\\'(which {tn.argument.type} isn\\\'t) in versions before 7; current version is {parser.v}.\'}, \'function a(...[b]){}\');\n\na(\'binding.to.arguments.or.eval\',{tn:\'tn\',m:\'invalid binding name in strict mode: {tn.name}\'}, \'\"use strict\"; (arguments)=>12\');\n\na(\'<unfinished>\', {\'tn\':\'tn\', m:\'unexpected {parser.lttype} -- a {extra.delim} was expected to end the {tn.type} at {tn.loc.start.line}:{tn.loc.start.column} (offset {tn.start})\'});\n\nset(\'block.dependent.is.unfinished\', \'<unfinished>\', \'try { 12\');\n\na(\'block.dependent.no.opening.curly\', {c0:\'parser.c0\', li0:\'parser.li\', col0: \'parser.col0\', m:\'unexpected {parser.lttype} after {extra.name} -- expected {}\'}, \'try 12\');\n\nset(\'block.unfinished\', \'<unfinished>\');\n\na(\'break.no.such.label\',{tn:\'tn\',m:\'no such label: {tn.name}\'}, \'while (false) break L;\');\n\na(\'break.not.in.breakable\', {c0:\'c0\',li0:\'li0\',col0:\'col0\',m:\'breaks without any targets can only appear inside an iteration statement or a switch\'}, \'break;\');\n\nset(\'call.args.is.unfinished\', \'<unfinished>\');\n\na(\'catch.has.no.end.paren\',{c0:\'c0\',li0:\'li0\',col0:\'col0\',m:\'unexpected {parser.lttype} -- a ) was expected\'}, \'try {} catch (a) { 12\');\n\na(\'catch.has.no.opening.paren\',{c0:\'c0\',li0:\'li0\',col0:\'col0\',m:\'unexpected {parser.lttype} -- a ( was expected\'}, \'try {} catch 12\');\n\na(\'catch.has.an.asiig.param\',{c0:\'c0\',li0:\'li0\',col0:\'col0\',m:\'the parameter for a catch clause can not be an assignment pattern\'},\'try{} catch(a=12){}\');\n\na(\'catch.has.no.param\',{c0:\'c0\',li0:\'li0\',col0:\'col0\',m:\'a catch clause must have a parameter\'}, \'try{} catch(){}\');\n\na(\'class.constructor.is.a.dup\', {tn:\'tn\',m:\'this class has already got a constructor\'}, \'class A{constructor(){} constructor(){}}\');\n\n// TODO: what about this: class A { static get constructor() {} }\na(\'class.constructor.is.special.mem\',{tn:\'tn\',m:\'a class member named constructor (or \\\'constructor\\\') can not be a getter, generator, setter, or async. (it can be a static member, though.)\'}, \'class A{get constructor(){}}\');\n\na(\'class.decl.has.no.name\',{c0:\'c0\',li0:\'li0\',col0:\'col0\',m:\'this context requires that the class declaration has a name\'}, \'class {}\');\n\na(\'class.decl.not.in.block\',{c0:\'c0\',li0:\'li0\',col0:\'col0\',m:\'this scope can not contain a class declaration -- block scope (i.e, those wrapped between {} and }), module scope, and script scope are the only ones that can.\'}, \'if (false) class{}\');\n\na(\'class.label.not.allowed\',{c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'can not label a class\'}, \'L: class A{}\');\n\na(\'class.no.curly\',{c0:\'c0\',li0:\'li0\',col0:\'col0\',m:\'a {} was expected -- got {parser.lttype} instead\'},\'class L 12\');\n\na(\'class.prototype.is.static.mem\',{tn:\'tn\',m:\'class can not have a static member named prototype\'},\'class A{static prototype() {}}\');\n\na(\'class.super.call\',{tn:\'tn\',m:\'can not call super in this context\'},\'class A{constructor(){var a = super()}\');\n\na(\'class.super.lone\',{tn:\'tn\',m:\'unexpected {parser.lttype} after \\\'super\\\' -- a \"(\" or \".\" or \"[\" was expected\'}, \'class A extends B { constructor() { (super * 12); }}\');\n\na(\'class.super.mem\',{tn:\'tn\',m:\'member access from super not allowed in this context -- super member access must only occur inside an object method or inside a non-static class member\'}, \'class A { static b() { (super.l()); }\');\n\nset(\'class.unfinished\', \'<unfinished>\');\n\na(\'comment.multi.unfinished\', {c0:\'parser.c\',li0:\'parser.li\',col0:\'parser.col\',m:\'reached eof before finding a matching */ for the multiline comment at {extra.li0}:{extra.col0} (offset {extra.c0})\'},\'/* 12\');\n\n// TODO: tell what was got\na(\'complex.assig.not.pattern\',{c0:\'c0\',li0:\'li0\',col0:\'col0\',m:\'a \\\'=\\\' was expected\'},\'(a-=12)=>12\');\n\na(\'cond.colon\',{c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'a \\\':\\\' was expected; got {parser.lttype}\'}, \'a ? b 5\');\n\na(\'const.has.no.init\',{c0:\'c0\',li0:\'li0\',col0:\'col0\',m:\'a \\\'=\\\' was expected, got {parser.lttype} -- the declarator at {extra.e.loc.start.line}:{extra.e.loc.start.column} (offset {extra.e.start}) is a const  declarator and needs an initialiser.\'},\'const a\' );\n\na(\'const.not.in.v5\',{c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'in versions before ES2015 (current version is {parser.v}), const is a reserved word and can\\\'t be an actual identifier reference.\'}, \'a * const\');\n\na(\'continue.no.such.label\',{tn:\'tn\', m:\'no such label: {tn.name}\'},\'while (false) continue L;\');\n\na(\'continue.not.a.loop.label\',{tn:\'tn\',m:\'label {tn.name} is not referring to a loop -- a continue\\\'s label, if any, must refer to a loop.\'},\'while (false)L:if(false)continue L;\');\n\na(\'continue.not.in.loop\',{c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'continue is not allowed in this context -- it has to appear in loops only\'},\'is (false) continue;\');\n\na(\'decl.label\', {c0:\'c0\',li0:\'li0\',col0:\'col0\',m:\'{parser.ltval} declarations can not have labels\'}, \'L: const a = 12;\');\n\na(\'delete.arg.not.a.mem\',{tn:\'tn\',m:\'when in strict mode code, the delete operator must take a member expression as argument; currently, its argument is a {tn.type}\'},  \'\"use strict\"; a * (delete l)\');\n\na(\'<closing>\', {c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'a ) was expected; got {parser.lttype}\'});\n\nset(\'do.has.no.closing.paren\', \'<closing>\');\n\na(\'<opening>\', {c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'a ( was expected; got {parser.lttype}\'});\n\nset(\'do.has.no.opening.paren\', \'<opening>\');\n\na(\'do.has.no.while\',{c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'while expected; got {parser.lttype}\'}, \'do {};\');\n\na(\'esc.8.or.9\',{c0:\'parser.c\',li0:\'parser.li\',col0:\'parser.col0\',m:\'escapes \\\\8 or \\\\9 are not syntactically valid escapes\'},\'\"\\\\8\"\');\n\na(\'exists.in.current\',{tn:\'tn\',m:\'\\\'{tn.name}\\\' has been actually declared at {extra.loc.start.line}:{extra.loc.start.column} (offset {extra.start})\'},\'let a;{var a;}\');\n\na(\'export.all.no.from\', {c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'\\\'from\\\' expected; got {parser.ltval}\'}, \'export * not \\\'12\\\'\');\n\na(\'export.all.not.*\', {c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'unexpected {parser.ltraw}; a * was expected\'}, \'export - from \\\'12\\\'\');\n\na(\'export.all.source.not.str\',{c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'a string literal was expected\'}, \'export * from 12\');\n\na(\'export.async.but.no.function\',{c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'function expected to immediately follow async; got {parser.lttype}\'},\'export async\\n12\');\n\na(\'export.default.const.let\',{c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'const and let declarations can\\\'t be default exports\'},\'export default let r = 12;\');\n\na(\'export.named.has.reserved\',{tn:\'tn\',m:\'local {tn.name} is actually a reserved word\'},\'export {a, if as l};\');\n\na(\'export.named.list.not.finished\',{c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'unfinished specifier list -- expected }, got {parser.lttype}\'},\'export {a 12 from \\\'l\\\'\');\n\na(\'export.named.no.exports\',{c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'unexpected {parser.lttype} -- it is not something that can appear at the beginning of an actual declaration\'},\'export 12\');\n\nset(\'export.named.not.id.from\',\'export.all.no.from\');\n\nset(\'export.named.source.not.str\',\'export.all.source.not.str\');\n\na(\'export.newline.before.the.function\',{c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'a newline is not allowed before \\\'function\\\' in exported async declarations.\'},\'export async\\nfunction l() {}\');\n\na(\'export.not.in.module\', {c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\'});\n\na(\'export.specifier.after.as.id\', {c0:\'parser.c0\',li0:\'parser.li0\',col0:\'parser.col0\',m:\'got {parser.lttype}; an identifier was expected\'}, \'export {a as 12}\');\n\na(\'export.specifier.not.as\', {m:\'\\\'as\\\' or } was expected; got {parser.lttype}\'},\'export {a 12 e}\');\n\na(\'for.decl.multi\',{tn:\'tn.declarations.1\',m:\'head of a {extra.2} can only have one declarator\'},\'for (var a, b in e) break;\');\n\na(\'for.decl.no.init\',{m:\'initialiser \"=\" was expected; got {parser.lttype}\'},\'for (var [a];;) break;\');\n\na(\'for.in.has.decl.init\',{tn:\'tn.declarations.0.init\',m:\'{tn.kind} declarations and non-Identifier declarators can not have initialisers; also it is not allowed altogether in versions before 7; current version is {parser.v}\'},\'for (var a = 12 in e) break;\');\n\na(\'for.in.has.init.assig\',{tn:\'tn\',m:\'assignment expressions can not be a {extra.2}\\\'s head\'},\'for (a=12 in e) break;\');\n\na(\'for.iter.no.end.paren\',{m:\'a ) was expected; got {parser.lttype}\'},\'for (a in b 5\');\n\na(\'for.iter.not.of.in\',{m:\'an \\\'in\\\' or \\\'of\\\' expected; got {parser.ltval}\'},\'for (a to e) break;\');\n\na(\'for.of.var.overrides.catch\',{tn:\'tn\',m:\'{tn.name} overrides the surrounding catch block\\\'s variable of the same name\'},\'try {} catch (a) { for (var a of l) break;}\');\n\nset(\'for.simple.no.end.paren\', \'for.iter.no.end.paren\');\n\na(\'for.simple.no.init.semi\',{m:\'a ; was expected; got {parser.lttype}\'}, \'for (a 12 b; 12) break;\');\n\nset(\'for.simple.no.test.semi\', \'for.simple.no.init.semi\');\n\nset(\'for.with.no.opening.paren\', \'<opening>\');\n\n// TODO: precision\na(\'func.args.has.dup\',{tn:\'tn\',m:\'{tn.name}: duplicate params are not allowed\'}, \'function l([a,a]) {}\');\n\nset(\'func.args.no.end.paren\', \'<closing>\');\n\nset(\'func.args.no.opening.paren\', \'<opening>\');\n\na(\'func.args.not.enough\', {m:\'unexpected {parser.lttype}\'}, \'({ get a(l) {} })\', \'({set a() {}})\');\n\na(\'func.body.is.unfinished\', {m:\'a } was expected to end the current function\\\'s body; got {parser.lttype}\'}, \'function l() { 12\');\n\na(\'func.decl.not.allowed\', {m:\'the current scope does not allow a function to be declared in it\'}, \'while (false) function l() {}\');\n\na(\'func.label.not.allowed\', {m:\'can not label this declaration\'}, \'L:function* l() {}\');\n\na(\'func.strict.non.simple.param\', {tn:\'parser.firstNonSimpArg\', m:\'a function containing a Use Strict directive can not have any non-simple paramer -- all must be Identifiers\'});\n\na(\'hex.esc.byte.not.hex\', {c0:\'parser.c\',li0:\'parser.li\',col0:\'parser.col\',m:\'a hex byte was expected\'}, \'\"\\\\xab\\\\xel\"\');\n\na(\'id.esc.must.be.idbody\',{cur0:\'cur\',m:\'unicode codepoint with value {extra} is not a valid identifier body codepoint\'});\n\na(\'id.esc.must.be.id.head\',{cur0:\'cur\',m:\'unicode codepoint with value {extra} is not a valid identifier start codepoint\'});\n\na(\'id.multi.must.be.idhead\', {cur0:\'cur\',m:\'the unicode surrogate pair [{extra.0},{extra.1}] don\\\'t represent an identifier start.\'});\n\na(\'id.multi.must.be.idbody\', {cur0:\'cur\',m:\'the unicode surrogate pair [{extra.0},{extra.1}] don\\\'t represent an identifier body codepoint\'});\n\na(\'id.name.has.surrogate.pair\',{m:\'unicode escapes in identifier names can not be parts of a surrogate pair\'});\n\na(\'id.u.not.after.slash\',{m:\'a \\\'u\\\' was expected after \\\\\'}, \'\\\\e\');\n\nset(\'if.has.no.closing.paren\', \'<closing>\');\n\nset(\'if.has.no.opening.paren\', \'<opening>\');\n\na(\'import.from\',{m:\'\\\'from\\\' expected\'},\'import * 12\');\n\na(\'import.invalid.specifier.after.comma\',{m:\'unexpected {parser.lttype}\'},\'import a, 12 from \\\'l\\\'\');\n\na(\'import.namespace.specifier.not.*\',{m:\'unexpected {parser.ltraw} -- a * was expected\'},\'import - as \\\'12\\\'\');\n\na(\'import.namespace.specifier.local.not.id\', {m:\'valid identifier was expected; got {parser.lttype}\'},\'import {a as 12} from \\\'12\\\'\');\n\na(\'import.namespace.specifier.no.as\', {m:\'\\\'as\\\' expected\'}, \'import {a 12 l} from \\\'12\\\'\');\n\na(\'import.not.in.module\', {m:\'import is not allowed in script mode\'});\n\na(\'import.source.is.not.str\', {m:\'string literal was expected\'},\'import * as a from 12\');\n\na(\'import.specifier.list.unfinished\', {m:\'a } was expected; got {parser.lttype}\'}, \'import {a as b, e as l 12\');\n\nset(\'import.specifier.local.not.id\', \'import.namespace.specifier.local.not.id\');\n\nset(\'import.specifier.no.as\', \'import.namespace.specifier.no.as\');\n\na(\'incdec.post.not.simple.assig\',{m:\'member expression or identifier expected -- got {tn.type}\'},\'[a]--\');\n\nset(\'incdec.pre.not.simple.assig\', \'incdec.post.not.simple.assig\');\n\na(\'label.is.a.dup\', {m:\'{tn.name} has been actually declared at {extra.li0}:{extra:col0} (offset {extra.c0})\'}, \'a: a: for (;false;) break;\');\n\n// TODO:\n// a(\'let.dcl.not.in.block\',{m: \n\na(\'lexical.decl.not.in.block\',{m:\'a {extra.kind}-binding can not be declared in this scope\'}, \'if (false) const a = 12;\');\n\na(\'lexical.name.is.let\', {m:\'let/const bindings can not have the name \\\'let\\\'\'}, \'let [[let=let]=let*let] = 12;\');\n\na(\'mem.gen.has.no.name\',{m:\'unexpected {parser.lttype}\'},\'({**() {}} })\');\n\n// v < 5\na(\'mem.id.is.null\',{m:\'got {parser.ltval} -- a valid member identifier was expected\'},\'a.this\');\n\na(\'mem.name.not.id\',{m:\'unexpected {parser.lttype} -- a valid member identifier was expected\'}, \'a.12\');\n\na(\'mem.unfinished\',{m:\'unexpected {parser.lttype} -- a ] was expected\'}, \'a[e 12\');\n\na(\'meta.new.has.unknown.prop\',{m:\'\\\'target\\\' is currently the only allowed meta property of new; got {parser.ltval}\'},\'function l() { new.a }\');\n\na(\'meta.new.not.in.function\',{m:\'\\\'new.target\\\' must be in the body of a function\'}, \'new.target\');\n\n// TODO: precision\na(\'meth.paren\',{m:\'unexpected {parser.lttype} -- a ( was expected to start method-params\'},\'({get a 12})\');\n\na(\'func.decl.has.no.name\',{m:\'function declaration must have a name in this context\'},\'function() {}\');\n\na(\'new.args.is.unfinished\',{m:\'unexpected {parser.lttype} -- a ) was expected\'}, \'new L(12\');\n\na(\'new.head.is.not.valid\',{m:\'unexpected {parser.lttype}\'}, \'new ?\');\n\na(\'arrow.newline\', {m:\'\\\'=>\\\' can not have a newline before it\'}, \'a \\n=>12\');\n\na(\'nexpr.null.head\',{m:\'unexpected {parser.lttype} -- something that can start an actual expression was expected\'},\'a-- * ?\');\n\na(\'non.tail.rest\',{m:\'a rest element can not be followed by a comma (a fact that also implies it must be the very last element)\'}, \'[...a,]=12\');\n\n// TODO: this.noSemiAfter(nodeType)\na(\'no.semi\',{m:\'a semicolon was expected (or a \\\'}\\\' if appropriate), but got a {parser.lttype}\'},\'a e\'); \n\na(\'not.assignable\',{m:\'{tn.type} is not a valid assignment left hand side\'},\'a[0]-- = 12\');\n\na(\'not.bindable\',{m:\'{tn.type} can not be treated as an actual binding pattern\'});\n\n// TODO: for now it would suffice\na(\'not.stmt\',{m:\'unexpected {parser.lttype} -- it can\\\'t be used in an expression\'},\'a * while (false) { break; }\');\n\na(\'null.stmt\',{m:\'unexpected {parser.lttype} -- expected something that would start a statement\'}, \'{ for (a=0;a>=0 && false;a--) }\');\n\na(\'num.has.no.mantissa\',{m:\'a mantissa was expected\'},\'12e?\');\n\na(\'num.idhead.tail\',{m:\'a number literal can not immediately precede an identifier head\'},\'120l\');\n\na(\'num.legacy.oct\',{m:\'legacy octals not allowed in strict mode\'},\'01\');\n\na(\'num.with.first.not.valid\',{m:\'{extra} digit not valid\'},\'0xG\',\'0b5\');\n\na(\'num.with.no.digits\',{m:\'{extra} digits were expected to follow -- none found\'},\'0x\',\'0b\');\n\na(\'obj.pattern.no.:\',{m:\'a : was expected -- got {parser.lttype}\'},  \'({a 12 e, e: a})\');\n\na(\'obj.prop.assig.not.allowed\',{m:\'shorthand assignment not allowed in this context, because the containing object can not be an assignment left-hand side\'},\'-{a=12} = 12\');\n\na(\'obj.prop.assig.not.assigop\',{m:\'a \\\'=\\\' was expected\'},\'({a -= 12 } = 12)\');\n\na(\'obj.prop.assig.not.id\',{m:\'a shorthand assignment\\\'s left hand side must be a plain (non-computed) identifier\'},\'({[a]=12})\');\n\na(\'obj.prop.is.null\',{m:\'unexpected {parser.lttype} -- a [, {}, or an Identifier (anything starting a pattern) was expected\'},\'var {a:-12} = 12\');\n\na(\'obj.proto.has.dup\',{m:\'can not have more than a  single property in the form __proto__: <value> or  \\\'__proto_\\\': <value>; currently the is already one at {parser.first__proto__.loc.start.line}:{parser.first__proto__.loc.start.column} (offset {parser.first__proto__.start})\'}, \'({__proto__:12, a, e, \\\'__proto__\\\': 12})\');\n\na(\'obj.unfinished\',{m:\'unfinished object literal: a } was expected; got {parser.lttype}\'},\'({e: a 12)\');\n\na(\'unexpected.lookahead\',{m:\'unexpected {parser.lttype}\'},\'-- -a\');\na(\'param.has.yield.or.super\',{p:function(){if(this.tn !== null && this.tn.type === \'Identifier\') this.tn = {type:\'AwaitExpression\',start:this.tn.start,loc:this.tn.loc,end:this.tn.end,argument:null};},m:\'{tn.type} isn\\\'t allowed to appear in this context\'},\'function* l() { ([a]=[yield])=>12; }\');\n\na(\'paren.unbindable\',{m:\'unexpected ) -- bindings should not have parentheses around them, neither should non-simple assignment-patterns\'},\'([(a)])=>12\', \'[a,b,e,([l])]=12\');\n\nset(\'pat.array.is.unfinished\', \'array.unfinished\');\n\na(\'pat.obj.is.unfinished\',{m:\'unexpected {parser.lttype} -- a } was expected\'},\'var {a=12 l} = 12)\');\n\na(\'program.unfinished\',{m:\'unexpected {parser.lttype} -- an EOF was expected\'},\'a, b, e, l; ?\');\n\na(\'prop.dyna.is.unfinished\',{m:\'unexpected {parser.lttype}\'},\'({[a 12]: e})\');\n\nset(\'prop.dyna.no.expr\', \'prop.dyna.is.unfinished\');\n\nfunction regp() {\n  this.col0 = this.col + (this.c0-this.c);\n  if (this.extra === null)\n    this.extra = {};\n\n  this.extra.ch = this.parser.src.charAt(this.c0);\n}\n\n// TODO: precision\na(\'regex.flag.is.dup\',{p: regp, m:\'regex flag is duplicate\'},\'/a/guymu\');\n\na(\'regex.newline\',{p:regp, m:\'regular expressions can not contain a newline\'},\'/a\\n/\');\n\na(\'regex.newline.esc\',{p:regp, m:\'regular expressions can not contain escaped newlines\'},\'/a\\\\\\n/\');\n\na(\'regex.unfinished\',{cur0:\'cur\',m:\'unfinished regex -- a / was expected\'},\'/a\');\n\n// TODO: precision\na(\'regex.val.not.in.range\',{m:\'regex contains an out-of-range value\'});\n\na(\'reserved.id\',{m:\'{tn.name} is actually a reserved word in this context\'},\'\"use strict\"; var implements = 12;\');\n\na(\'rest.binding.arg.peek.is.not.id\',{m:\'unexpected {parser.lttype} -- in versions before 7, a rest\\\'s argument must be an id\'},\'var [...[a]] = 12\');\n\na(\'rest.arg.not.valid\',{tn:\'tn.argument\',m:\'a rest\\\'s argument is not allowed to have a type of {tn.arguments.type}\'},\'[...a=12]=12\');\n\na(\'resv.unicode\',{cur:\'parser.eloc\',m:\'{parser.ltraw} is actually a reserved word ({parser.ltval}); as such, it can not contain any unicode escapes\'},\'whil\\\\u0065 (false) break;\');\n\na(\'return.not.in.a.function\',{m:\'return statements are only allowed inside a function\'},\'return 12\');\n\na(\'seq.non.tail.expr\',{m:\'trailing comma was not expected\'},\'(a,)\');\n\na(\'shorthand.unassigned\',{m:\'shorthand assignments are not allowed somewhere other than am assignment\\\'s left hand side\'},\'a = [{b=12},]\');\n\na(\'stmt.null\',{m:\'unexpected {parser.lttype} because it can not start a statement\'},\'while (false) ?\');\n\na(\'strict.err.esc.not.valid\',{cur0:\'parser.eloc\',m:\'legacy octals are not allowed in strict mode\'},\'\"\\\\12\"; \"use strict\"\');\n\na(\'strict.let.is.id\',{m:\'let can\\\'t be used as an id in strict mode\'},\'\"use strict\"; a * b * e * l * let\');\n\na(\'strict.oct.str.esc\',{m:\'legacy octals not allowed in strict mode\'},\'\"use strict\"; \"\\\\12\"\');\n\na(\'strict.oct.str.esc.templ\',{m:\'legacy octals not allowed inside templates\'},\'`\\\\12`\');\n\na(\'str.newline\',{li0: \'parser.li\', m:\'a string literal may not contain line breaks\'},\'\"a\\n\"\');\n\na(\'str.unfinished\',{li0: \'parser.li\', m:\'the string starting at {parser.li0}:{parser.col0} (offset {parser.c0}) not finished\'},\'\"abel\');\n\na(\'switch.case.has.no.colon\',{m:\'unexpected {parser.lttype} -- a \\\':\\\' was expected\'},\'switch (a) { case 12 a break; }\');\n\na(\'switch.has.a.dup.default\',{m:\'this switch has already got a default\'},\'swicth (a) { case a: break; case b: break; case e: break; default: break; default: 12; }\');\n\na(\'switch.has.no.opening.curly\',{m:\'unexpected {parser.lttype} -- a {} was expected\'},\'switch (a) 12\');\n\na(\'switch.has.no.closing.paren\',{m:\'unexpected {parser.lttype} -- a ) was expected\'},\'switch (a 12\');\n\na(\'switch.has.no.opening.paren\',{m:\'unexpected {parser.lttype} -- a ( was expected\'},\'switch ?\');\n\na(\'switch.unfinished\',{m:\'unexpected {parser.lttype} -- a } was expected\'},\'switch (a) { case 12: break; ?\');\n\na(\'templ.expr.is.unfinished\',{m:\'unexpected {parser.lttype} -- a } was expected at the end of the current interpolated expression\'},\'`abel${e 12}`\');\n\na(\'templ.lit.is.unfinished\',{m:\'the template literal at {extra.loc.start.line}:{extra.loc.start.column} (offset {extra.start}) is unfinished\'},\'`abel\');\n\na(\'throw.has.newline\',{m:\'throw can not have a line-break after it\'},\'throw \\n12\');\n\na(\'throw.has.no.argument\',{m:\'unexpected {parser.lttype}\'},\'throw ?\');\n\na(\'try.has.no.tain\',{m:\'unexpected {parser.lttype} -- try must have a \\\'catch\\\' or \\\'finally\\\' block coming after it\'},\'try {}\\nif (false);\');\n\na(\'u.curly.is.unfinished\',{p: regp, m:\'a } was expected\'},\'\\\\u{12;\');\n\na(\'u.curly.not.in.range\',{p: regp, m:\'unicode codepoints must have a max decimal value of 1114111 (0x10FFFF)\'}, \'\\\\u{125400}\');\n\na(\'u.esc.hex\',{p: regp, m:\'invalid hex\'},\'\\\\u00el\');\n\na(\'unary.before.an.exponentiation\',{m:\'left operand for an exponentiation operator is not allowed to be an unparenthesized unary expression\'},\'-a**e\');\n\na(\'unexpected.id\',{m:\'got {parser.ltval} rather than {extra}\'},\'export * as a from \\\'12\\\'\');\n\na(\'an.id.was.expected\',{m:\'unexpected {parser.lttype} -- identifier \\\'{extra}\\\' was expected\'},\'export * as a 12 \\\'l\\\'\');\n\na(\'meth.parent\',{m:\'a ) was expected\'},\'class A { e: 12 }\');\n\na(\'obj.meth.no.paren\',{m:\'a ) was expected\'},\'({get a: 12})\');\n\na(\'rest.arg.has.trailing.comma\',{m:\'trailing comma not expected after rest\'},\'(...a,)\');\n\na(\'unexpected.rest\',{m:\'unexpected rest element\'},\'(...a)\');\n\na(\'unfinished.paren\',{c0:\'tn.end\',li0:\'tn.loc.end.line\',col0:\'tn.loc.end.column\',m:\'the parenthesis at {tn.loc.start.line}:{tn.loc.start.column} (offset {tn.start}) is unfinished\'}, \'(a,b 12\');\n\na(\'u.second.esc.not.u\',{p:function(){this.col0++;}, cur0:\'cur\', m:\'a \\\'u\\\' was expected after the slash\', col0:\'col\'},\'\\\\ee\');\n\na(\'u.second.not.in.range\',{p:function(){this.col0+=(this.c-this.extra);},cur0:\'cur\',col0:\'col\',m:\'the second surrogate must be in range [0x0dc00, 0x0dfff]\'});\n\na(\'var.decl.neither.of.in\',{m:\'unexpected {parser.lttype}\'},\'var [a] -= 12\');\n\na(\'var.decl.not.=\', {m:\'Unexpected {parser.lttype} -- (maybe you mean \\\'=\\\'?)\'},\'var a -= l\');\n\na(\'var.must.have.init\', {m:\'a \\\'=\\\' was expected -- current declarator needs an initialiser\'},\'var a, [e]\');\n\na(\'var.has.no.declarators\',{m:\'unexpected {parser.lttype}\'}, \'var -a = l\');\n\na(\'var.has.an.empty.declarator\',{m:\'unexpected {parser.lttype}\'}, \'var a, -\');\n\na(\'while.has.no.closing.paren\',{m:\'unexpected {parser.lttype} -- a ) was expected\'},\'while (a 12\');\n\na(\'while.has.no.opening.paren\',{m:\'unexpected {parser.lttype} -- a ( was expected\'},\'while 12) break;\');\n\na(\'with.has.no.opening.paren\',{m:\'unexpected {parser.lttype} -- a ( was expected\'},\'with 12) {}\');\n\na(\'with.has.no.end.paren\',{m:\'unexpected {parser.lttype} -- a ) was expected\'},\'with (a 12 {}\');\n\na(\'with.strict\',{m:\'with statements not allowed in strict mode\'},\'\"use strict\"; with (l) {}\');\n\na(\'yield.args\',{m:\'yield expression not allowed in generator\\\'s argument list\'},\'function* l(e=yield 12) {}\');\n\na(\'yield.as.an.id\',{m:\'yield is not allowed as an identifier in this context\'},\'function* l() { var yield = 12 }\');\n\na(\'yield.has.no.expr.deleg\',{m:\'unexpected {parser.lttype} -- it can not star an expression\'},\'function* l() { yield* ?}\');\n\n\n\n');
resolver.set('./src/Parser/reg-class.js', '  import {CH_XOR, CH_RSQBRACKET, ASSERT, CH_BACK_SLASH} from \'../other/constants.js\';\n  import {isTrail, uAkin, isLead} from \'../other/regex-util.js\';\n  import {cpReg} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.regClass =\nfunction() {\n  var c0 = this.c, loc0 = this.loc(), list = [];\n  var e = null, latest = null;\n  var n = null;\n\n  var inverse = false;\n  if (this.scat(c0+1) === CH_XOR)\n    inverse = true;\n\n  this.setsimpoff(inverse ? c0 + 2 : c0 + 1);\n\n  while (true) {\n    e = this.regClassElem(); \n    if (this.regErr)\n      return null;\n    if (e === null)\n      break;\n    this.regPushClassElem(list, e);\n  }\n\n  if (this.regSemiRange && !this.regTryCompleteSemiRange())\n    return null; // an error has got set\n\n  if (!this.expectChar(CH_RSQBRACKET))\n    return this.regErr_classUnfinished(n);\n\n  n = {\n    type: \'#Regex.Class\',\n    elements: list,\n    start: c0,\n    end: this.c,\n    inverse: inverse,\n    loc: { start: loc0, end: this.loc() }\n  };\n\n  this.regIsQuantifiable = true;\n  return n;\n};\n\ncls.regPushClassElem =\nfunction(list, tail) {\n  if (list.length === 0) { list.push(tail); return; }\n\n  var len = list.length;\n  var ltop = list[len-1];\n  var sr = this.regSemiRange;\n\n  if (sr) {\n    ASSERT.call(this, sr === ltop, \'semiRange must not have existed if it were not the last elem\');\n    ASSERT.call(this, isTrail(tail), \'semiRange should not have existed if the next class elem is a non-unicode escape\');\n    ASSERT.call(this, this.regexFlags.u, \'semiRange could not have existed if the u flags was not initially set\');\n    sr.max.next = tail;\n    if (uAkin(sr.max, tail))\n      sr.max = this.regMakeSurrogate(sr.max, tail);\n    else\n      list.push(tail);\n    this.regTryCompleteSemiRange();\n    return;\n  }\n\n  if (isLead(ltop) && isTrail(tail)) {\n    if (this.regexFlags.u && ltop.escape !== \'{}\' && uAkin(ltop, tail)) {\n      list.pop();\n      list.push(this.regMakeSurrogate(ltop, tail));\n    }\n    else\n      list.push(tail);\n    ltop.next = tail;\n    return;\n  }\n\n  if (ltop.type === \'#Regex.Range\' && isLead(ltop.max) && isTrail(tail)) ltop.max.next = tail;\n  if (len < 2 || ltop.type !== \'#Regex.Hy\') { list.push(tail); return; }\n\n  var max = tail;\n  var maxv = cpReg(max);\n  if (maxv === -1) { list.push(tail); return; }\n\n  var min = list[len-2];\n  var minv = cpReg(min);\n  if (minv === -1) { list.push(tail); return; }\n\n  var semi = false;\n  if (this.regexFlags.u && isLead(tail) && tail.escape !== \'{}\')\n    semi = true;\n  else if (minv > maxv)\n    return this.regErr_minBiggerThanMax(min, tail);\n\n  list.pop(); // \'-\'\n  list.pop(); // head\n\n  var elem = {\n    type: semi ? \'#Regex.SemiRange\' : \'#Regex.Range\',\n    min: min,\n    start: min.start,\n    end: max.end,\n    max: max,\n    loc: { start: min.loc.start, end: max.loc.end }\n  };\n  if (semi) {\n    ASSERT.call(this, this.regSemiRange === null, \'semi\' );\n    this.regSemiRange = elem;\n  }\n  list.push(elem);\n};\n\ncls.regTryCompleteSemiRange =\nfunction() {\n  var sr = this.regSemiRange;\n  ASSERT.call(this, sr.type === \'#Regex.SemiRange\', \'semi\' );\n  ASSERT.call(this, sr.max.cp >= 0, \'max\');\n  ASSERT.call(this, sr.min.cp >= 0, \'min\');\n  if (sr.min.cp > sr.max.cp)\n    return this.regErr_minBiggerThanMax(sr.min, sr.max);\n\n  sr.type = \'#Regex.Range\';\n  sr.end = sr.max.end;\n  sr.loc.end = sr.max.loc.end;\n\n  this.regSemiRange = null;\n  return sr;\n};\n\n// true if completeing the semi-range results in a `regErr\ncls.testSRerr =\nfunction() {\n  return this.regSemiRange && !this.regTryCompleteSemiRange();\n};\n\ncls.regClassElem =\nfunction() {\n  var c = this.c, s = this.src, l = this.regLastOffset;\n  if (c >= l)\n    return null;\n  switch (s.charCodeAt(c)) {\n  case CH_BACK_SLASH:\n    return this.regEsc(true);\n  case CH_RSQBRACKET:\n    return null;\n  default:\n    return this.regChar(true);\n  }\n};\n\n\n');
resolver.set('./src/Parser/parse-with.js', '  import {CH_LPAREN, CTX_TOP, CH_RPAREN} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseWith = \nfunction() {\n  this.resvchk();\n  this.testStmt() || this.err(\'not.stmt\');\n  if (this.scope.insideStrict())\n    this.err(\'with.strict\')  ;\n\n  this.fixupLabels(false);\n\n  this.enterScope(this.scope.spawnBare());\n  var scope = this.scope;\n\n  var c0 = this.c0, cb = {}, loc0 = this.loc0();\n\n  this.suc(cb, \'bef\');\n  this.next(); // \'with\'\n\n  this.suc(cb, \'with.aft\' );\n  if (!this.expectT(CH_LPAREN))\n    this.err(\'with.has.no.opening.paren\');\n\n  var obj = core(this.parseExpr(CTX_TOP));\n\n  this.spc(obj, \'aft\' );\n  if (!this.expectT(CH_RPAREN))\n    this.err(\'with.has.no.end.paren\');\n\n  var nbody = this.parseStatement(true);\n  this.exitScope();\n\n  this.foundStatement = true;\n  return  {\n    type: \'WithStatement\',\n    loc: { start: loc0, end: nbody.loc.end },\n    start: c0,\n    end: nbody.end,\n    object: obj,\n    body: nbody,\n    \'#scope\': scope,\n    \'#y\': this.Y(obj, nbody ), \'#c\': cb\n  };\n};\n\n\n');
resolver.set('./src/Parser/reg-paren.js', '  import {CH_QUESTION, CH_RPAREN, CH_EQUALITY_SIGN, CH_EXCLAMATION, CH_COLON} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.regParen =\nfunction() {\n  var c0 = this.c;\n  var s = this.src;\n  var l = this.regLastOffset;\n\n  if (c0+1 >= l)\n    return this.regErr_unfinishedParen();\n\n  if (s.charCodeAt(c0+1) === CH_QUESTION)\n    return this.regPeekOrGroup();\n\n  var loc0 = this.loc();\n  this.setsimpoff(c0+1);\n\n  var elem = this.regPattern();\n  if (this.regErr)\n    return null;\n\n  this.regIsQuantifiable = true;\n  var finished = this.expectChar(CH_RPAREN);\n  var n = {\n    type: \'#Regex.Paren\',\n    capturing: true,\n    start: c0,\n    end: this.c,\n    pattern: elem,\n    loc: { start: loc0, end: this.loc() }\n  };\n\n  if (finished)\n    return n;\n\n  return this.regErr_unfinishedParen(n);\n};\n\ncls.regPeekOrGroup =\nfunction() {\n  var c0 = this.c, s = this.src, l = this.regLastOffset;\n  var r = this.scat(c0+2);\n  switch (r) {\n  case CH_EQUALITY_SIGN:\n    return this.regPeek(true);\n  case CH_EXCLAMATION:\n    return this.regPeek(false);\n  case CH_COLON:\n    return this.regGroup();\n  default:\n    return this.regErr_invalidCharAfterQuestionParen(r); // (?\n  }\n};\n\ncls.regPeek =\nfunction(notInverse) {\n  var c0 = this.c, loc0 = this.loc(), n = null, elem = null, finished = false;\n  this.setsimpoff(c0+3);\n  elem = this.regPattern();\n  finished = this.expectChar(CH_RPAREN);\n  n = {\n    type: \'#Regex.Peek\',\n    inverse: !notInverse,\n    start: c0,\n    pattern: elem,\n    end: this.c,\n    loc: { start: loc0, end: this.loc() }\n  };\n  this.regIsQuantifiable = !this.rf.u;\n\n  if (finished) return n;\n  return this.regErr_unfinishedParen(n);\n};\n\ncls.regGroup = \nfunction() {\n  var c0 = this.c, loc0 = this.loc(), n = null, elem = null, finished = false;\n  this.setsimpoff(c0+3);\n  elem = this.regPattern();\n  finished = this.expectChar(CH_RPAREN);\n  n = {\n    type: \'#Regex.Paren\',\n    capturing: false,\n    start: c0,\n    end: this.c,\n    pattern: elem,\n    loc: { start: loc0, end: this.loc() }\n  };\n  this.regIsQuantifiable = !this.rf.u;\n\n  if (finished) return n;\n  return this.regErr_unfinishedParen(n);\n};\n\n\n');
resolver.set('./src/Parser/parse-yield.js', '  import {PREC_NONE} from \'../other/lexer-constants.js\';\n  import {CTX_FOR, CTX_NULLABLE} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseYield = \nfunction(ctx) {\n  var c = this.c, li = this.li, col = this.col;\n  var deleg = false, arg = null;\n  var c0 = this.c0, cb = {}, loc0 = this.loc0();\n\n  this.suc(cb, \'bef\');\n  this.next(); // \'yield\'\n\n  if (!this.nl) {\n    if (this.peekMul()) {\n      deleg = true;\n      this.suc(cb, \'*.bef\');\n      this.next(); // \'*\'\n      arg = this.parseNonSeq(PREC_NONE, ctx&CTX_FOR);\n      if (!arg)\n        this.err(\'yield.has.no.expr.deleg\');\n    }\n    else\n      arg = this.parseNonSeq(PREC_NONE, (ctx&CTX_FOR)|CTX_NULLABLE);\n  }\n\n  var ec = -1, eloc = null;\n  if (arg) { ec = arg.end; eloc = arg.loc.end; }\n  else { ec = c; eloc = { line: li, column: col }; }\n\n  var n = {\n    type: \'YieldExpression\',\n    argument: arg && core(arg),\n    start: c0,\n    delegate: deleg,\n    end: ec,\n    loc: { start : loc0, end: eloc },\n    \'#y\': 1+this.Y0(arg), \'#c\': cb\n  };\n\n  if (this.suspys === null)\n    this.suspys = n;\n\n  return n;\n};\n\n\n');
resolver.set('./src/Parser/read-op-lt.js', '  import {CH_EQUALITY_SIGN, CH_LESS_THAN} from \'../other/constants.js\';\n  import {PREC_COMP, TK_SIMP_BINARY, TK_OP_ASSIG, PREC_SH} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readOp_lt =\nfunction() {\n  var c = this.c; c++; // \'<\'\n  var ch = this.scat(c);\n\n  if (ch === CH_EQUALITY_SIGN) {\n    c++;\n    this.prec = PREC_COMP;\n    this.lttype = TK_SIMP_BINARY;\n    this.ltraw = \'<=\';\n  }\n  else if (ch === CH_LESS_THAN) {\n    c++;\n    ch = this.scat(c);\n    if (ch === CH_EQUALITY_SIGN) {\n      c++;\n      this.lttype = TK_OP_ASSIG;\n      this.ltraw = \'<<=\';\n    }\n    else {\n      this.lttype = TK_SIMP_BINARY;\n      this.prec = PREC_SH;\n      this.ltraw = \'<<\';\n    }\n  }\n  else {\n    this.lttype = TK_SIMP_BINARY;\n    this.prec = PREC_COMP;\n    this.ltraw = \'<\';\n  }\n\n  this.setsimpoff(c);\n};\n\n\n');
resolver.set('./src/Parser/regex.js', '  import {HAS} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\n// GENERAL RULE: if error occurs while parsing an elem, the parse routine sets the `regexErr and returns null\ncls. parseRegex =\nfunction(rc, rli, rcol, regLast, nump, flags, \n  /* tail (flags) */\n  tc, tli, tcol) {\n  var c = this.c;\n  var li = this.li;\n  var col = this.col;\n  var luo0 = this.luo;\n  var src0 = this.src;\n\n  var e = 0, str = \'guymi\';\n  while (e < str.length) \n    this.rf[str[e++]] = false;\n  e = 0;\n\n  this.li = tli;\n  this.col = tcol;\n  this.c = tc;\n  this.luo = this.c;\n\n  var n = null;\n  while (e < flags.length) {\n    var fl = flags[e];\n    if (!HAS.call(this.rf, fl)) {\n      this.setsimpoff(tc+e);\n      n = { type: \'#Regex.Err\', kind: \'flagunknown\', loc: this.loc(), position: tc + e, ctx: { flag: fl } };\n      break;\n    }\n    if (this.rf[fl]) {\n      this.setsimpoff(tc+e);\n      n = { type: \'#Regex.Err\', kind: \'flagduplicate\', loc: this.loc(), position: tc + e, ctx: { flag: fl } };\n      break;\n    }\n    this.rf[fl] = true;\n    e++;\n  }\n\n  if (n === null) {\n    this.c = rc;\n    this.li = rli;\n    this.col = rcol;\n    this.regLastOffset = regLast - 1 - flags.length; // -(\'/\'.length+flags.length)\n    this.regNC = nump;\n\n    this.luo = this.c;\n\n    var n = this.regPattern();\n    \n    if (this.regErr) { n = this.regErr; this.regErr = null; }\n    else if (this.c !== this.regLastOffset) {\n      this.err(\'regex.no.complete.parse\');\n      // must never actually happen or else an error-regex-elem would have existed for it\n      if (n.branches.length <= 0)\n        this.err(\'regex.with.no.elements\');\n    }\n  }\n\n  this.c = c;\n  this.li = li;\n  this.col = col;\n\n  this.luo = luo0;\n  this.src = src0;\n\n  return n;\n};\n\n\n\n\n');
resolver.set('./src/Parser/peek.js', '  import {TK_SIMP_BINARY, TK_ID, TK_SIMP_ASSIG} from \'../other/lexer-constants.js\';\n  import {CH_SINGLE_QUOTE, CH_MULTI_QUOTE} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.peekMul =\nfunction() { \n  return this.lttype === TK_SIMP_BINARY && this.ltraw === \'*\';\n};\n\ncls.peekID =\nfunction(name) {\n  return this.lttype === TK_ID && this.ltval === name;\n};\n\ncls.peekEq =\nfunction() {\n  return this.lttype === TK_SIMP_ASSIG && this.ltraw === \'=\';\n};\n\ncls.peekStr =\nfunction() {\n\n  switch (this.lttype) {\n  case CH_SINGLE_QUOTE:\n  case CH_MULTI_QUOTE:\n    return true;\n  }\n\n  return false;\n};\n\n\n');
resolver.set('./src/Parser/prepare-op.js', '  import {TK_SIMP_BINARY, TK_AA_MM, TK_UNBIN, PREC_ADD, TK_OP_ASSIG, PREC_MUL, TK_ID, PREC_COMP, PREC_COND} from \'../other/lexer-constants.js\';\n  import {CH_DIV, CH_EQUALITY_SIGN, CTX_FOR, CH_QUESTION} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.getOp = \nfunction(ctx) {\n  switch ( this. lttype ) {\n  case TK_SIMP_BINARY:\n  case TK_AA_MM:\n    return true;\n  case TK_UNBIN:\n    this.prec = PREC_ADD;\n    return true;\n  case CH_DIV:\n    if (this.scat(this.c) === CH_EQUALITY_SIGN) {\n      this.lttype = TK_OP_ASSIG;\n      this.ltraw = \'/=\';\n      this.setsimpoff(this.c+1);\n    }\n    else {\n      this.lttype = TK_SIMP_BINARY; // unnecessary\n      this.ltraw = \'/\';\n      this.prec = PREC_MUL; \n    }\n    return true;\n\n  case TK_ID:\n    switch (this.ltval) {\n    case \'in\':\n      this.resvchk();\n    case \'of\':\n      if (ctx & CTX_FOR) break;\n\n      this.prec = PREC_COMP;\n      this.ltraw = this.ltval;\n      return true;\n\n    case \'instanceof\':\n      this.resvchk();\n      this.prec = PREC_COMP;\n      this.ltraw = this.ltval ;\n      return true;\n    }\n    return false;\n\n  case CH_QUESTION:\n    this.prec = PREC_COND;\n    return true;\n\n  default: return false;\n  }\n\n};\n\n\n');
resolver.set('./src/Parser/read-esc.js', '  import {CH_BACK_SLASH, CH_MULTI_QUOTE, CH_SINGLE_QUOTE, CH_v, CH_b, CH_f, CH_t, CH_r, CH_n, CH_u, CH_x, CH_0, CH_8, CH_1, CH_2, CH_3, CH_4, CH_5, CH_6, CH_7, CH_9, CH_CARRIAGE_RETURN, CH_LINE_FEED} from \'../other/constants.js\';\n  import {cp2sp, hex2num} from \'../other/util.js\';\n  import {ERR_NONE_YET, ERR_PIN_OCTAL_IN_STRICT} from \'../other/error-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readEsc =\nfunction(t) { // is it a template escape?\n  var c = this.c,\n      s = this.src,\n      l = s.length,\n      v = \'\',\n      setoff = true;\n\n  if (c+1>=l)\n    this.err(\'slash.eof\');\n\n  var ch1 = -1, ch2 = -1;\n  switch (s.charCodeAt(c+1)) {\n  case CH_BACK_SLASH: c+=2; v = \'\\\\\'; break;\n  case CH_MULTI_QUOTE: c+=2; v = \'\\\"\'; break;\n  case CH_SINGLE_QUOTE: c+=2; v = \'\\\'\'; break;\n  case CH_v: c+=2; v = \'\\v\'; break;\n  case CH_b: c+=2; v = \'\\b\'; break;\n  case CH_f: c+=2; v = \'\\f\'; break;\n  case CH_t: c+=2; v = \'\\t\'; break;\n  case CH_r: c+=2; v = \'\\r\'; break;\n  case CH_n: c+=2; v = \'\\n\'; break;\n\n  case CH_u:\n    v = cp2sp(this.readBS());\n    setoff = false;\n    break;\n\n  case CH_x:\n    c+=2; // \\x\n    if (c>=l)\n      this.err(\'x.esc.first.got.eof\');\n    ch1 = hex2num(s.charCodeAt(c));\n    if (ch1 === -1)\n      this.err(\'x.esc.first.got.nonhex\');\n    c++;\n    if (c>=l)\n      this.err(\'x.esc.next.got.eof\');\n    ch2 = hex2num(s.charCodeAt(c));\n    if (ch2 === -1)\n      this.err(\'x.esc.next.got.nonhex\');\n    c++;\n    v = String.fromCharCode((ch1<<4)|ch2);\n    break;\n\n  case CH_0:\n    if (c+2>=l ||\n       (ch1=s.charCodeAt(c+2), ch1 < CH_0 || ch1 >= CH_8)) {\n      c += 2;\n      v = \'\\0\';\n      break;\n    }\n  case CH_1:\n  case CH_2:\n  case CH_3:\n  case CH_4:\n  case CH_5:\n  case CH_6:\n  case CH_7:\n    t && this.err(\'template.esc.is.legacy\');\n    v = this.readEsc_legacy();\n    setoff = false;\n    break;\n\n  case CH_8:\n  case CH_9:\n    this.err(\'esc.8.or.9\');\n    break;\n\n  case CH_CARRIAGE_RETURN:\n    if (\n      c+2<l &&\n      s.charCodeAt(c+2) === CH_LINE_FEED\n    ) c++;\n  case CH_LINE_FEED:\n  case 0x2028: case 0x2029:\n    c++;\n    this.setzoff(c+1);\n    v = \'\';\n    setoff = false;\n    break;\n\n  default:\n    v = s.charAt(c+1);\n    c+=2;\n  }\n\n  if (setoff)\n    this.setsimpoff(c);\n\n  return v;\n};\n\ncls.readEsc_legacy =\nfunction() {\n  if (this.scope.insideStrict())\n    this.err(\'esc.legacy.not.allowed.in.strict.mode\');\n\n  if (this.scope.insidePrologue() &&\n    this.ct === ERR_NONE_YET) {\n    this.ct = ERR_PIN_OCTAL_IN_STRICT;\n    this.pin_ct(this.c,this.li,this.col);\n  }\n\n  var c = this.c+1, s = this.src, l = s.length, v = -1;\n\n  v = s.charCodeAt(c) - CH_0;\n  var max = v >= 4 ? 1 : 2;\n  c++;\n  while (c<l && max--) {\n    var ch = s.charCodeAt(c);\n    if (ch < CH_0 || ch >= CH_8)\n      break;\n    v = (v<<3)|(ch-CH_0);\n    c++;\n  }\n\n  this.setsimpoff(c);\n\n  return String.fromCharCode(v);\n};\n\n\n');
resolver.set('./src/Parser/read-dot.js', '  import {CH_SINGLEDOT} from \'../other/constants.js\';\n  import {isNum} from \'../other/ctype.js\';\n  import {FL_HEADLESS_FLOAT, TK_NUM} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.read_dot =\nfunction() {\n  var ch = this.scat(this.c+1);\n  if (ch === CH_SINGLEDOT)\n    return this.read_ellipsis();\n  \n  if (isNum(ch)) {\n    this.readNum_tail(FL_HEADLESS_FLOAT);\n    this.ltval = parseFloat(this.ltraw = this.c0_to_c());\n    this.lttype = TK_NUM;\n  }\n  else {\n    this.setsimpoff(this.c+1);\n    this.lttype = CH_SINGLEDOT;\n  }\n};\n\n\n');
resolver.set('./src/Parser/read-op-xor.js', '  import {CH_EQUALITY_SIGN} from \'../other/constants.js\';\n  import {TK_OP_ASSIG, PREC_BIT_XOR, TK_SIMP_BINARY} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readOp_xor =\nfunction() {\n  var c = this.c; c++; // \'^\'\n  var ch = this.scat(c);\n\n  if (ch === CH_EQUALITY_SIGN) {\n    c++;\n    this.lttype = TK_OP_ASSIG;\n    this.ltraw = \'^=\';\n  }\n  else {\n    this.prec = PREC_BIT_XOR;\n    this.lttype = TK_SIMP_BINARY;\n    this.ltraw = \'^\';\n  }\n\n  this.setsimpoff(c);\n};\n\n\n');
resolver.set('./src/Parser/read-comment.js', '  import {CH_CARRIAGE_RETURN, CH_LINE_FEED, CH_MUL, CH_DIV} from \'../other/constants.js\';\n  import Comments from \'../Comments/cls.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readComment_line =\nfunction() {\n  var c = this.c, s = this.src, l = s.length;\n  var li0 = this.li, col0 = this.col, c0 = c;\n\n  COMMENT:\n  while (c<l)\n    switch (s.charCodeAt(c)) {\n    case CH_CARRIAGE_RETURN:\n    case CH_LINE_FEED:\n    case 0x2028:\n    case 0x2029:\n      break COMMENT;\n    default: c++;\n    }\n\n  this.setsimpoff(c);\n  this.foundComment(c0,li0,col0,c,\'Line\');\n};\n\ncls.readComment_multi =\nfunction() {\n  var c = this.c, s = this.src, l = s.length;\n  var li0 = this.li, col0 = this.col, c0 = c, hasNL = false, finished = false;\n  var l0o = -1; // line 0 offset\n  COMMENT:\n  while (c<l)\n    switch (s.charCodeAt(c)) {\n    case CH_CARRIAGE_RETURN:\n      if (c+1<l && s.charCodeAt(c+1) === CH_LINE_FEED)\n        c++;\n    case CH_LINE_FEED:\n    case 0x2028: case 0x2029:\n      c++;\n      this.setzoff(c);\n      if (!hasNL) {\n        hasNL = true;\n        l0o = c;\n      }\n      continue;\n\n    case CH_MUL:\n      if (c+1<l && s.charCodeAt(c+1) === CH_DIV) {\n        c += 2; // \'*/\'\n        finished = true;\n        break COMMENT;\n      }\n    default: c++;\n    }\n\n  this.setsimpoff(c);\n  if (!finished)\n    this.err(\'comment.multi.is.unfinished\');\n\n  if (!hasNL)\n    l0o = c;\n  else\n    l0o--; // do not count the break\n\n  this.foundComment(c0,li0,col0,l0o,\'Block\');\n  return hasNL;\n};\n\ncls.foundComment =\nfunction(c0,li0,col0,l0o,t) {\n  var c = this.c, li = this.li, col = this.col;\n  if (this.commentBuf === null)\n    this.commentBuf = new Comments();\n\n  var line = t === \'Line\';\n  var comment = {\n    type: t,\n    value: this.src.substring(c0, line ? c : c-2),\n    start: c0,\n    end: c,\n    loc: {\n      start: { line: li0, column: col0 },\n      end: { line: li, column: col }\n    },\n    \'#firstLen\': l0o - c0 + 2\n  };\n\n  this.commentBuf.push(comment);\n  this.commentCallback && this.commentCallback(comment);\n};\n\n\n');
resolver.set('./src/Parser/new-parse-break.js', '  import {TK_ID} from \'../other/lexer-constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseBreak =\nfunction() {\n  this.resvchk();\n  this.testStmt() || this.err(\'not.stmt\');\n  this.fixupLabels(false);\n\n  var c0 = this.c0, loc0 = this.loc0();\n  var c = this.c, li = this.li, col = this.col;\n\n  var cb = {li: li};\n  this.suc(cb, \'bef\');\n  this.next();\n  var label = null;\n  if (!this.nl && this.lttype === TK_ID) {\n    this.validate(this.ltval);\n    label = this.id();\n    var target = this.findLabel_m(_m(label.name));\n    if (target === null)\n      this.err(\'break.no.such.label\');\n  }\n  else if (!this.scope.canBreak())\n    this.err(\'break.not.in.breakable\');\n\n  label && this.spc(label, \'aft\');\n  this.semi(label ? label.cb : cb, label ? \'aft\' : \'break.aft\') || this.err(\'no.semi\');\n\n  var ec = this.semiC || (label && label.end) || c;\n  var eloc = this.semiLoc ||\n    (label && label.loc.end) ||\n    { line: li, column: col };\n\n  this.foundStatement = true;\n  return {\n    type: \'BreakStatement\',\n    label: label,\n    start: c0,\n    end: ec,\n    loc: { start: loc0, end: eloc },\n    \'#y\': 0,\n    \'#c\': cb\n  };\n};\n\n\n');
resolver.set('./src/Parser/parse-array.js', '  import {errt_elem_ctx_of, errt_track, errt_ptrack, errt_atrack, errt_strack, errt_psyn, errt_pin, errt_asyn, errt_ssyn, errt_perr, errt_aerr, errt_serr} from \'../other/errt.js\';\n  import {CTX_NULLABLE, CH_COMMA, PAREN_NODE, CTX_HAS_A_PARAM_ERR, CTX_HAS_AN_ASSIG_ERR, CTX_HAS_A_SIMPLE_ERR, CH_RSQBRACKET} from \'../other/constants.js\';\n  import {ERR_NONE_YET, ERR_PAREN_UNBINDABLE, ERR_NON_TAIL_REST} from \'../other/error-constants.js\';\n  import {PREC_NONE, TK_ELLIPSIS} from \'../other/lexer-constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseArray = \nfunction(ctx) {\n  var c0 = this.c0, cb = {}, loc0 = this.loc0();\n\n  this.suc(cb, \'bef\');\n  this.next(); // \'[\'\n\n  var elem = null, list = [];\n  var elctx = errt_elem_ctx_of(ctx);\n\n  elctx |= CTX_NULLABLE;\n\n  var pt = ERR_NONE_YET, pe = null, po = null;\n  var at = ERR_NONE_YET, ae = null, ao = null;\n  var st = ERR_NONE_YET, se = null, so = null;\n\n  var pc0 = -1, pli0 = -1, pcol0 = -1;\n  var ac0 = -1, ali0 = -1, acol0 = -1;\n  var sc0 = -1, sli0 = -1, scol0 = -1;\n\n  if (errt_track(ctx)) {\n    errt_ptrack(ctx) && this.pt_reset();\n    errt_atrack(ctx) && this.at_reset();\n    errt_strack(ctx) && this.st_reset();\n  }\n\n  var hasMore = true;\n  var hasRest = false, hasNonTailRest = false;\n\n  var y = 0, si = -1;\n\n  cb.holes = [];\n  cb.h = 0;\n  while (hasMore) {\n    elem = this.parseNonSeq(PREC_NONE, elctx);\n    if (elem === null && this.lttype === TK_ELLIPSIS) {\n      elem = this.parseSpread(elctx);\n      si = list.length;\n      hasRest = true;\n    }\n    if (this.lttype === CH_COMMA) {\n      if (hasRest)\n        hasNonTailRest = true; \n      if (elem === null) {\n        if (this.v <= 5) this.err(\'ver.elision\');\n        this.commentBuf && cb.holes.push([list.length, this.cc()]);\n        list.push(null);\n      }\n      else {\n        list.push(core(elem));\n        this.spc(core(elem), \'aft\');\n      }\n      this.next();\n    }\n    else {\n      if (elem) {\n        list.push(core(elem));\n        hasMore = false;\n      }\n      else break;\n    }\n \n    if (elem)\n       y += this.Y(elem);\n\n    if (elem && errt_track(elctx)) {\n      var elemCore = elem;\n      // TODO: [...(a),] = 12\n      var t = ERR_NONE_YET;\n      if (elemCore.type === PAREN_NODE)\n        t = ERR_PAREN_UNBINDABLE;\n      else if (hasNonTailRest)\n        t = ERR_NON_TAIL_REST;\n\n      if (errt_ptrack(ctx)) {\n        if (this.pt === ERR_NONE_YET && t !== ERR_NONE_YET) {\n          this.pt = t; this.pe = elemCore;\n        }\n        if (this.pt_override(pt)) {\n          pt = this.pt; pe = this.pe; po = core(elem);\n          if (errt_psyn(pt))\n            elctx |= CTX_HAS_A_PARAM_ERR;\n          if (errt_pin(pt)) \n            pc0 = this.pin.p.c0, pli0 = this.pin.p.li0, pcol0 = this.pin.p.col0;\n        }\n      }\n\n      // ([a]) = 12\n      if (t === ERR_PAREN_UNBINDABLE && this.ensureSAT(elem.expr))\n        t = ERR_NONE_YET;\n\n      if (errt_atrack(ctx)) {\n        if (this.at === ERR_NONE_YET && t !== ERR_NONE_YET) {\n          this.at = t; this.ae = elemCore;\n        }\n        if (this.at_override(at)) {\n          at = this.at; ae = this.ae; ao = core(elem);\n          if (errt_asyn(at))\n            elctx |= CTX_HAS_AN_ASSIG_ERR;\n          if (errt_pin(at))\n            ac0 = this.pin.a.c0, ali0 = this.pin.a.li0, acol0 = this.pin.a.col0;\n        }\n      }\n      if (errt_strack(ctx)) {\n        if (this.st_override(st)) {\n          st = this.st; se = this.se; so = core(elem);\n          if (errt_ssyn(st))\n            elctx |= CTX_HAS_A_SIMPLE_ERR;\n          if (errt_pin(st))\n            sc0 = this.pin.s.c0, sli0 = this.pin.s.li0, scol0 = this.pin.s.col0;\n        }\n      }\n    }\n\n    hasRest = hasNonTailRest = false;\n  }\n  \n  var n = {\n    type: \'ArrayExpression\',\n    loc: { start: loc0, end: this.loc() },\n    start: c0,\n    end: this.c,\n    elements : list,\n    \'#y\': -1, \'#si\': si, \'#c\': cb\n  };\n\n  if (errt_perr(ctx,pt)) {\n    this.pt_teot(pt,pe,po);\n    errt_pin(pt) && this.pin_pt(pc0,pli0,pcol0);\n  }\n  if (errt_aerr(ctx,at)) {\n    this.at_teot(at,ae,ao);\n    errt_pin(at) && this.pin_at(ac0,ali0,acol0);\n  }\n  if (errt_serr(ctx,st)) {\n    this.st_teot(st,se,so);\n    errt_pin(st) && this.pin_st(sc0,sli0,scol0);\n  }\n\n  elem ? this.spc(core(elem), \'aft\') : this.suc(cb, \'inner\');\n  if (!this.expectT(CH_RSQBRACKET))\n    this.err(\'array.unfinished\');\n  \n  return n;\n};\n\n\n');
resolver.set('./src/Parser/new-parse-id-expr-head.js', '  import {DT_LET, DT_VAR, DT_CONST, ST_NONE} from \'../other/scope-constants.js\';\n  import {TK_UNARY, VDT_VOID, TK_YIELD, VDT_AWAIT, VDT_DELETE} from \'../other/lexer-constants.js\';\n  import {CTX_NONE, CTX_FOR, ASSERT} from \'../other/constants.js\';\n  import {ERR_NONE_YET, ERR_PIN_UNICODE_IN_RESV} from \'../other/error-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseIDExprHead =\nfunction(ctx) {\n  var name = this.ltval;\n  SWITCH:\n  switch (name.length) {\n  case 1:\n    return this.id();\n  case 2:\n    switch (name) {\n    case \'do\': return this.parseDoWhile();\n    case \'if\': return this.parseIf();\n    case \'in\': this.ri();\n    }\n    break;\n\n  case 3:\n    switch (name) {\n    case \'new\':\n      if (this.canBeStatement)\n        this.canBeStatement = false;\n      return this.parseNew();\n\n    case \'for\': return this.parseFor();\n    case \'try\': return this.parseTryStatement();\n    case \'let\':\n      return this.parseVar(DT_LET,ctx);\n    case \'var\':\n      this.resvchk();\n      return this.parseVar(DT_VAR,ctx);\n\n    case \'int\':\n      this.resvchk();\n      this.v <= 5 && this.ri();\n    }\n    break;\n\n  case 4:\n    switch (name) {\n    case \'null\': return this.getLit_null();\n    case \'void\':\n      this.resvchk();\n      this.lttype = TK_UNARY; \n      this.vdt = VDT_VOID;\n      return null;\n\n    case \'this\': return this.parseThis();\n    case \'true\': return this.getLit_true();\n    case \'case\':\n      this.resvchk();\n      if (this.canBeStatement) {\n        this.canBeStatement = false ;\n        this.foundStatement = true;\n        return null;\n      }\n      this.ri();\n\n    case \'else\': this.ri();\n    case \'with\': return this.parseWith();\n\n    case \'enum\': this.ri();\n\n    case \'byte\': case \'char\':\n    case \'goto\': case \'long\':\n      this.v <= 5 && this.ri();\n    }\n    break;\n\n  case 5:\n    switch (name) {\n    case \'super\': return this.parseSuper();\n    case \'break\': return this.parseBreak();\n    case \'catch\': this.ri();\n    case \'class\': return this.parseClass(CTX_NONE);\n    case \'const\':\n      this.resvchk();\n      return this.parseVar(DT_CONST,CTX_NONE);\n    case \'throw\': return this.parseThrow();\n    case \'while\': return this.parseWhile();\n    case \'yield\': \n      if (this.scope.canYield()) {\n        this.resvchk();\n        if (this.scope.insideArgs())\n          this.err(\'yield.args\');\n        if ( this.canBeStatement )\n          this.canBeStatement = false;\n        this.lttype = TK_YIELD;\n        return null;\n      }\n      if (this.scope.insideStrict())\n        this.ri();\n      break SWITCH;\n\n    case \'false\': return this.getLit_false();\n    case \'await\':\n      if (this.scope.canAwait()) {\n        this.resvchk();\n        if (this.scope.insideArgs())\n          this.err(\'await.args\');\n        if (this.canBeStatement)\n          this.canBeStatement = false;\n        this.lttype = TK_UNARY;\n        this.vdt = VDT_AWAIT;\n        return null;\n      }\n      if (!this.isScript) {\n        this.resvchk();\n        this.err(\'await.in.strict\');\n      }\n\n      // async(e=await)=>l ;\n      return this.suspys = this.id(); \n\n    case \'async\': return this.parseAsync(this.id(), ctx);\n\n    case \'final\':\n    case \'float\':\n    case \'short\':\n      this.v <= 5 && this.ri();\n    }\n    break;\n\n  case 6:\n    switch (name) {\n    case \'static\':\n      if (this.scope.insideStrict() || this.v <= 5)\n        this.ri();\n\n    case \'delete\':\n    case \'typeof\':\n      this.resvchk();\n      this.lttype = TK_UNARY; \n      this.vdt = name === \'delete\' ?\n        VDT_DELETE : VDT_VOID;\n      return null;\n\n    case \'export\': return this.parseExport();\n    case \'import\': return this.parseImport();\n    case \'return\': return this.parseReturn();\n    case \'switch\': return this.parseSwitch();\n    case \'public\':\n      if (this.scope.insideStrict())\n        this.ri();\n    case \'double\':\n    case \'native\':\n    case \'throws\':\n      this.v <= 5 && this.ri();\n    }\n    break;\n\n  case 7:\n    switch (name) {\n    case \'default\':\n      this.resvchk();\n      if (this.canBeStatement) {\n        this.canBeStatement = false;\n        this.foundStatement = true;\n      }\n      return null;\n\n    case \'extends\':\n    case \'finally\':\n      this.ri();\n\n    case \'package\':\n    case \'private\':\n      if (this.scope.insideStrict())\n        this.ri();\n\n    case \'boolean\':\n      this.v <= 5 && this.ri();\n    }\n\n  case 8:\n    switch (name) {\n    case \'function\':\n      return this.parseFn(ctx&CTX_FOR, ST_NONE);\n    case \'debugger\':\n      return this.parseDbg();\n    case \'continue\':\n      return this.parseContinue();\n    case \'abstract\':\n    case \'volatile\':\n      this.v <= 5 && this.ri();\n    }\n    break;\n\n  case 9:\n    switch (name) {\n    case \'interface\':\n    case \'protected\':\n      if (this.scope.insideStrict())\n        this.ri() ;\n    case \'transient\':\n      this.v <= 5 && this.ri();\n    }\n    break;\n\n  case 10:\n    switch (name) {\n    case \'instanceof\':\n      this.ri();\n    case \'implements\':\n      if (this.v <= 5 ||\n        this.scope.insideStrict())\n        this.ri();\n    }\n    break;\n\n  case 12:\n    this.v <= 5 &&\n    name === \'synchronized\' &&\n    this.ri();\n  }\n\n  return this.id();\n};\n \ncls.resvchk = function() {\n  if (this.ct !== ERR_NONE_YET) {\n    ASSERT.call(this.ct === ERR_PIN_UNICODE_IN_RESV,\n      \'the error in this.ct is something other than ERR_PIN_UNICODE_IN_RESV: \' + this.ct);\n    this.err(\'resv.unicode\');\n  }\n};\n\n\n\n');
resolver.set('./src/Parser/offman.js', '  import {cls} from \'./cls.js\';\n\ncls.setsimpoff =\nfunction(offset) {\n  this.col += (this.c = offset) - this.luo;\n  // TODO: will luo remain relevant even if\n  // we only use this.c at the start and end of a lexer routine\n  this.luo = offset;\n};\n\ncls.setzoff =\nfunction(offset) {\n  this.luo = offset;\n  this.c = offset;\n  this.col = 0;\n  this.li++;\n};\n\ncls.scat =\nfunction(offset) {\n  return offset < this.src.length ?\n    this.src.charCodeAt(offset) : -1;\n};\n\n\n');
resolver.set('./src/Parser/new-parse-list-params.js', '  import {CH_LPAREN, CH_COMMA, ARGLEN_ANY, CH_RPAREN} from \'../other/constants.js\';\n  import {TK_ELLIPSIS} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseParams =\nfunction(argLen) {\n  var\n    c0 = -1, li0 = -1, col0 = -1,\n    tail = true, elem = null,\n    list = [],\n    gnsa = false;\n\n  var argploc = this.loc0();\n  if (!this.expectT(CH_LPAREN))\n    this.err(\'fun.args.no.opening.paren\');\n\n  while (list.length !== argLen) {\n    elem = this.parsePat();\n    if (elem) {\n      if (this.peekEq()) {\n        this.scope.enterUniqueArgs();\n        elem = this.parsePat_assig(elem);\n      }\n      if (!gnsa && elem.type !== \'Identifier\') {\n        gnsa = true;\n        this.scope.firstNonSimple = elem;\n      }\n      list.push(elem);\n    }\n    else {\n      if (list.length !== 0) // trailing comma\n        this.v<7 &&\n        this.err(\'arg.non.tail.in.fun\',\n          {c0:c0,li0:li0,col0:col0}); // what about when v < 7 and having (a, ...b)?\n\n      break;\n    }\n\n    if (this.lttype === CH_COMMA) {\n      c0 = this.c0;\n      li0 = this.li0;\n      col0 = this.col0;\n      this.spc(elem, \'aft\');\n      this.next();\n    }\n    else { tail = false; break; }\n  }\n\n  if (argLen === ARGLEN_ANY) {\n    if (tail && this.lttype === TK_ELLIPSIS) {\n      this.scope.enterUniqueArgs();\n      elem = this.parsePat_rest();\n      list.push(elem);\n      if (!gnsa) {\n        gnsa = true;\n        this.scope.firstNonSimple = elem;\n      }\n    }\n  }\n  else if (list.length !== argLen)\n    this.err(\'fun.args.not.enough\');\n\n  if (elem) {\n    this.spc(elem, \'aft\');\n    this.cb = null;\n  } else\n    this.cb = this.cc();\n  \n  if (!this.expectT(CH_RPAREN))\n    this.err(\'fun.args.no.end.paren\');\n\n  this.argploc = argploc;\n\n  return list;\n};\n\n\n');
resolver.set('./src/Parser/read-op-eq.js', '  import {CH_EQUALITY_SIGN, CH_GREATER_THAN} from \'../other/constants.js\';\n  import {TK_SIMP_BINARY, PREC_EQ, TK_SIMP_ASSIG} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readOp_eq =\nfunction() {\n  var c = this.c; c++; // \'=\'\n  var ch = this.scat(c);\n\n  if (ch === CH_EQUALITY_SIGN) {\n    this.lttype = TK_SIMP_BINARY;\n    c++; this.prec = PREC_EQ;\n    ch = this.scat(c);\n    if (ch === CH_EQUALITY_SIGN) {\n      c++;\n      this.ltraw = \'===\';\n    }\n    else this.ltraw = \'==\';\n  }\n  else if (ch === CH_GREATER_THAN) {\n    this.lttype = TK_SIMP_ASSIG;\n    c++;\n    this.ltraw = \'=>\';\n  }\n  else {\n    this.lttype = TK_SIMP_ASSIG;\n    this.ltraw = \'=\';\n  }\n\n  this.setsimpoff(c);\n};\n\n\n');
resolver.set('./src/Parser/parse-unary.js', '  import {VDT_NONE, PREC_UNARY, VDT_DELETE, VDT_AWAIT} from \'../other/lexer-constants.js\';\n  import {CTX_FOR} from \'../other/constants.js\';\n  import {core} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.parseUnary =\nfunction(ctx) {\n  var op = \"\", loc0 = this.loc0(), c0 = this.c0, vdt = this.vdt;\n\n  if (vdt !== VDT_NONE) {\n    this.vdt = VDT_NONE;\n    op = this.ltval;\n  }\n  else\n    op = this.ltraw;\n\n  var cb = {}; this.suc(cb, \'bef\');\n  this.next();\n  var arg = this.parseNonSeq(PREC_UNARY, ctx & CTX_FOR);\n\n  if (this.scope.insideStrict() &&\n    vdt === VDT_DELETE &&\n    core(arg).type !== \'MemberExpression\')\n    this.err(\'delete.arg.not.a.mem\',{tn:arg,extra:{c0:startc,loc0:startLoc,context:context}});\n\n  if (vdt === VDT_AWAIT) {\n    var n = {\n      type: \'AwaitExpression\',\n      argument: core(arg),\n      start: c0,\n      end: arg.end,\n      loc: { start: loc0, end: arg.loc.end },\n      \'#c\': cb,\n      \'#y\': this.Y(arg)\n    };\n    this.suspys = n;\n    return n;\n  }\n\n  return {\n    type: \'UnaryExpression\',\n    operator: op,\n    start: c0,\n    end: arg.end,\n    loc: { start: loc0, end: arg.loc.end },\n    prefix: true,\n    \'#c\': cb,\n    argument: core(arg),\n    \'#y\': this.Y(arg)\n  };\n};\n\n\n');
resolver.set('./src/Parser/read-div.js', '  import {CH_DIV} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.readDiv =\nfunction() {\n  this.lttype = CH_DIV;\n  this.setsimpoff(this.c+1);\n};\n\n\n');
resolver.set('./src/VirtualResourceResolver/new-core.js', '  import {ASSERT, HAS} from \'../other/constants.js\';\n  import Parser from \'../Parser/cls.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.asNode =\nfunction(uri) {\n  ASSERT.call(this, this.has(uri), \'resource not found (\'+uri+\')\');\n  var newParser = new Parser(this.fsMap[_m(uri)], {sourceType: \'module\'});\n  newParser.bundleScope = this.bundleScope;\n  return newParser.parseProgram();\n};\n\ncls.has =\nfunction(uri) { return HAS.call(this.fsMap, _m(uri)); };\n\ncls.set =\nfunction(uri, value) {\n  ASSERT.call(this, !this.has(uri), \'has\' );\n  this.fsMap[_m(uri)] = value;\n};\n\n\n\n\n');
resolver.set('./src/VirtualResourceResolver/whole.js', '  import \'./new-core.js\';\n');
resolver.set('./src/VirtualResourceResolver/cls.js', '  import ResourceResolver from \'../ResourceResolver/cls.js\';\n\nexport default function VirtualResourceResolver(pathMan) {\n  ResourceResolver.call(this, pathMan);\n  this.fsMap = {};\n}\n\n import {createObj} from \'../other/util.js\';\n export var cls = VirtualResourceResolver.prototype = createObj(ResourceResolver.prototype);\n');
resolver.set('./src/PathMan/new-core.js', '  import {CH_DIV, ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.isSlash =\nfunction(path, at) {\n  return path.length <= at ? false : \n    path.charCodeAt(at) === CH_DIV;\n};\n\ncls.findSlash =\nfunction(path, at) {\n  ASSERT.call(this, arguments.length === 2, \'arguments\');\n  return path.indexOf(\'/\', at);\n};\n\ncls.findLastSlash =\nfunction(path, at) {\n  ASSERT.call(this, arguments.length === 2, \'arguments\');\n  return path.lastIndexOf(\'/\', at);\n}; \n\n// tail(a/b) -> b; tail(a) -> \"\"\ncls.tail =\nfunction(path) {\n  var slash = this.findLastSlash(path, path.length);\n  if (slash === -1)\n    return \"\";\n  ++slash;\n  return slash >= path.length ? \"\" : path.substring(slash);\n};\n\n// head(a/b) -> a; head(a) -> \"\"\ncls.head =\nfunction(path) {\n  var slash = this.findLastSlash(path, path.length);\n  return slash === -1 ? \"\" : slash === 0 ? path.charAt(0) : path.substring(0, slash);\n};\n \ncls.len =\nfunction(path, start) {\n  if (start >= path.length)\n    return 0;\n  var tail = -1;\n  if (this.isSlash(path, start))\n    tail = start + 1;\n  else {\n    tail = this.findSlash(path, start);\n    if (tail === -1) \n      tail = path.length;\n  }\n  while (path.length > tail && this.isSlash(path, tail))\n    tail++;\n  return tail - start;\n};\n\ncls.trimSlash =\nfunction(path) {\n  return path !== \'/\' && this.isSlash(path, path.length-1) ?\n    path.substring(0, path.length-1) : path;\n};\n\ncls.trimAll =\nfunction(path) {\n  var slash = this.findSlash(path, 0);\n  return slash === -1 ? path :\n    slash === 0 ? path.charAt(0) : path.substring(0,slash);\n};\n\ncls.hasTailSlash =\nfunction(path) {\n  return this.isSlash(path, path.length-1) ;\n};\n\ncls.hasHeadSlash =\nfunction(path) {\n  return this.isSlash(path, 0);\n};\n\ncls.joinRaw =\nfunction(a, b, nd) {\n  if (this.hasHeadSlash(b))\n    return b;\n  if (b === \'.\' && nd)\n    return a;\n  a = this.trimSlash(a);\n  if (a != \'/\') a += \'/\';\n  return a + b\n};\n\n\n');
resolver.set('./src/PathMan/whole.js', '  import \'./new-core.js\';\n');
resolver.set('./src/PathMan/cls.js', '\nexport default function PathMan() {}\n\n export var cls = PathMan.prototype;\n');
resolver.set('./src/ConcreteScope/whole.js', '  import \'./sp.js\';\n  import \'./liq.js\';\n  import \'./synth-names.js\';\n');
resolver.set('./src/ConcreteScope/sp.js', '\n\n\n');
resolver.set('./src/ConcreteScope/liq.js', '  import {_m} from \'../other/scope-util.js\';\n  import {ASSERT} from \'../other/constants.js\';\n  import LiquidGroup from \'../LiquidGroup/cls.js\';\n  import {cls} from \'./cls.js\';\n\ncls.gocLG =\nfunction(gName) {\n  var lg = this.getLG(gName);\n  return lg || this.createLG(gName);\n};\n\ncls.getLG =\nfunction(gName) {\n  var mname = _m(gName);\n  if (this.liquidDefs.has(mname))\n    return this.liquidDefs.get(mname);\n  return null;\n};\n\ncls.createLG =\nfunction(gName) {\n  var mname = _m(gName);\n  ASSERT.call(this, this.getLG(gName) === null, \'LGr exists\');\n  var group = new LiquidGroup(gName);\n  group.scope = this;\n//group.newL();\n  return this.liquidDefs.set(mname, group );\n};\n\n\n');
resolver.set('./src/ConcreteScope/synth-names.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import SortedObj from \'../SortedObj/cls.js\';\n  import {ATS_DISTINCT} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.synth_boot =\nfunction(r) {\n  if (this.renamer === null) this.renamer = r;\n  ASSERT.call(this, this.isSourceLevel(), \'script m\');\n\n  // TODO: source-level-scope.synthNamesUntilNow will be a 0-length SortedObj (because it has a synthBase other than itself),\n  // yet because it gets recorded in rsList-s, it might be receiving queries like `locateSynth` (findSynth), etc., and this in turn requires\n  // the value for its synthNamesUntilNow be non-null; this behaviour is somewhat hacky though, and it has got to be eliminated as soon as possible\n  this.synth_boot_init(); \n\n  this.synth_defs_to(this.synthBase);\n};\n\ncls.synth_finish =\nfunction() {\n  this.synth_liquids_to(this.synthBase);\n};\n\ncls.synth_start =\nfunction(r) {\n  ASSERT.call(this, this.isSourceLevel(), \'script m\');\n  this.isBooted || this.synth_boot(r);\n};\n\ncls.synth_liquids_to =\nfunction(targetScope) {\n  if (this.spThis !== null && this.spThis.ref.i)\n    targetScope.synthLiquid(this.spThis);\n  if (this.isAnyFn() && this.spArguments !== null) {\n    if (this.spArguments.ref.i)\n      targetScope.synthLiquid(this.spArguments);\n    else {\n      this.spArguments.synthName = this.spArguments.name;\n      targetScope.insertSynth_m(_m(this.spArguments.name), this.spArguments);\n    }\n  }\n\n  var list = this.liquidDefs, e = 0, len = list.length();\n  while (e < len)\n    this.synth_lg_to(list.at(e++), targetScope);\n};\n\ncls.synth_externals =\nfunction() {\n  ASSERT.call(this, this.isSourceLevel(), \'script m\');\n  var list = this.parent.defs, e = 0, len = list.length()  ;\n  while (e < len)\n    this.synthGlobal(list.at(e++));\n};\n\ncls.synth_lg_to =\nfunction(lg, target) {\n  var list = lg.list, e = 0;\n  while (e < list.length)\n    target.synthLiquid(list[e++]);\n};\n\ncls.synth_boot_init =\nfunction() {\n  ASSERT.call(this, this.isBootable(), \'not bootable\');\n  ASSERT.call(this, !this.isBooted, \'scope has been already booted\'); \n  if (this.synthNamesUntilNow === null)\n    this.synthNamesUntilNow = new SortedObj();\n  this.isBooted = true;\n};\n\ncls.findSynth_m =\nfunction(mname) {\n  var sn = this.synthNamesUntilNow;\n  return sn.has(mname) ? sn.get(mname) : null;\n};\n\n// can this name escape the current scope anyway?\n// there is a difference between \'can\' and \'do\', of course -- a name could potentially escape a scope but still remain there because of a synth homonym.\n// on the other hand, some names never escape a scope -- for example, an `arguments` never escapes an emitted function\ncls.synth_ref_may_escape_m =\nfunction(mname) {\n  ASSERT.call(this, this.isSourceLevel(), \'script m\');\n  return true;\n};\n\n// can this name get bound in the current scope anyway?\n// there is a difference between being a valid binding name and being a valid binding -- any name that is not an `eval/arguments` (when strict) and is not reserved\n// can be a valid binding name; but even then, they might remain invalid bindings, for example because they may be duplicates of an existing binding\ncls.synth_name_is_valid_binding_m =\nfunction(mname) { return true; };\n\ncls.synth_ref_find_homonym_m =\nfunction(mname, r) {\n  ASSERT.call(this, this.isSourceLevel(), \'script m\');\n  this.isBooted || this.synth_boot(r);\n  return this.findSynth_m(mname);\n};\n\ncls.synth_decl_find_homonym_m =\nfunction(mname) {\n  ASSERT.call(this, this.isSourceLevel(), \'script m\');\n  this.isBooted || this.synth_boot(r);\n  return this.findSynth_m(mname);\n};\n\ncls.insertSynth_m =\nfunction(mname, synth) {\n  var sn = this.synthNamesUntilNow || \n    (this.synthNamesUntilNow = new SortedObj()); // for msynth which uses it before the scope is booted\n\n  ASSERT.call(this, !sn.has(mname), \'\"\'+mname+\'\" exists\');\n  return sn.set(mname, synth);\n};\n\ncls.synth_globals =\nfunction(r) {\n  this.synth_boot_init();\n  ASSERT.call(this, this.isGlobal() || this.isBundle(), \'global/bundler\' );\n  ASSERT.call(this, this.renamer === null, \'renamer\' );\n\n  this.renamer = r;\n\n  var list = this.defs, len = list.length(), l = 0;\n  while (l < len)\n    this.synthGlobal(list.at(l++));\n};\n\ncls.synthDecl =\nfunction(decl) {\n  ASSERT.call(this,\n    decl.isFnArg() ||\n    decl.isLet() ||\n    decl.isConst() ||\n    decl.isVar() ||\n    decl.isCls() ||\n    decl.isFn() ||\n    (decl.isCatchArg() && decl.ref.scope.argIsSimple === false),\n    \'fun/let/const/var/fnarg\'\n  );\n\n  ASSERT.call(this, decl.synthName === \"\", \'has synth\');\n\n  var rsList = decl.ref.rsList;\n  var num = 0;\n  var baseName = decl.name;\n  var mname = \"\";\n  var synthName = this.rename(baseName, num);\n\n  RENAME:\n  do {\n    mname = _m(synthName); \n    var l = 0;\n    var synth = null;\n\n    while (l < rsList.length) {\n      var scope = rsList[l++];\n      if (!scope.synth_ref_may_escape_m(mname))\n        continue RENAME;\n\n      synth = scope.synth_ref_find_homonym_m(mname, this.renamer);\n      if (synth) {\n        if (synth.isName() && synth.getAS() !== ATS_DISTINCT)\n          synth = synth.source;\n        if (synth !== decl)\n          continue RENAME;\n      }\n    }\n\n    if (num === 0 && !this.synth_name_is_valid_binding_m(mname)) // shortcut: num === 0 (because currently no invalid name contains a number)\n      continue RENAME;\n\n    synth = this.synth_decl_find_homonym_m(mname, this.renamer);\n    if (synth) {\n      if (synth.isName() && synth.getAS() !== ATS_DISTINCT)\n        synth = synth.source;\n      if (synth !== decl)\n        continue RENAME;\n    }\n\n    break;\n  } while (synthName = this.rename(baseName, ++num), true);\n\n  decl.synthName = synthName;\n  this.insertSynth_m(mname, decl);\n};\n\ncls.synthGlobal =\nfunction(global) {\n  ASSERT.call(this, this.isGlobal() || this.isBundle(), \'script m\');\n  ASSERT.call(this, global.isGlobal(), \'not g\');\n  if (!global.mustSynth()) {\n    ASSERT.call(this, global.synthName === \"\", \'synth name\');\n    global.synthName = global.name;\n    return;\n  }\n  var rsList = global.ref.rsList;\n  var num = 0;\n  var name = global.name;\n  var synthNames = [name, \"\"]; // no rename(base, 0) -- this is a global\n\n  var m = 0, mname = \"\";\n\n  RENAME:\n  do {\n    while (m < synthNames.length) {\n      mname = _m(synthNames[m++]);\n      if (mname === _m(\"\")) {\n        ASSERT.call(this, num === 0, \'num\');\n        break RENAME;\n      }\n      var l = 0;\n      while (l < rsList.length) {\n        var scope = rsList[l++];\n        if (!scope.synth_ref_may_escape_m(mname))\n          continue RENAME;\n        var synth = scope.synth_ref_find_homonym_m(mname, this.renamer);\n        if (synth) {\n          if (synth.isName() && synth.getAS() !== ATS_DISTINCT)\n            synth = synth.source;\n          if (synth !== global)\n            continue RENAME;\n        }\n      }\n    }\n\n    break;\n  } while (\n    ++num,\n    synthNames[0] = this.rename(name, num),\n    synthNames[1] = synthNames[0] + \"u\",\n    true\n  );\n\n  global.synthName = synthNames[0];\n\n  this.insertSynth_m(_m(synthNames[0]), global);\n  if (num > 0)\n    this.insertSynth_m(_m(synthNames[1]), global /* TODO: s/global/null/ */);\n};\n\ncls.synthLiquid =\nfunction(liquid) {\n  ASSERT.call(this, liquid.isLiquid(), \'not liquid\');\n  ASSERT.call(this, liquid.synthName === \"\", \'has init\');\n\n  var rsList = liquid.ref.rsList;\n  var num = 0;\n  var baseName = liquid.name;\n  var mname = \"\";\n  var synthName = this.rename(baseName, num);\n\n  RENAME:\n  do {\n    mname = _m(synthName);\n    var l = 0;\n\n    while (l < rsList.length) {\n      var scope = rsList[l++ ];\n      if (!scope.synth_ref_may_escape_m(mname))\n        continue RENAME;\n\n      if (scope.synth_ref_find_homonym_m(mname, this.renamer))\n        continue RENAME;\n    }\n\n    if (!this.synth_name_is_valid_binding_m(mname))\n      continue RENAME;\n\n    if (this.synth_decl_find_homonym_m(mname, this.renamer))\n      continue RENAME;\n\n     break;\n  } while (synthName = this.rename(baseName, ++num), true);\n\n  liquid.synthName = synthName;\n  this.insertSynth_m(mname, liquid );\n};\n\ncls.rename =\nfunction(base, i) { return this.renamer(base, i); };\n\n\n');
resolver.set('./src/ConcreteScope/cls.js', '  import Scope from \'../Scope/cls.js\';\n  import SortedObj from \'../SortedObj/cls.js\';\n\nexport default function ConcreteScope(parent, type) {\n  Scope.call(this, parent, type);\n\n  this.liquidDefs = new SortedObj();\n  this.synthNamesUntilNow = null;\n\n  this.spThis = null;\n  this.isBooted = false;\n\n  this.renamer = null;\n}\n\n import {createObj} from \'../other/util.js\';\n export var cls = ConcreteScope.prototype = createObj(Scope.prototype);\n');
resolver.set('./src/JZMap/cls.js', ' import SortedObj from \'../SortedObj/cls.js\';\n import {ASSERT, HAS} from \'../other/constants.js\';\n export default function JZMap(helpers) {\n   this.jzmap = new SortedObj();\n   this.active = new SortedObj();\n   var len = helpers.length, l = 0;\n   while (l < len) {\n     var h = helpers[l++];\n     ASSERT.call(this, !HAS.call(this.jzmap, h.id), \'helper \'+h.id+\' exists\');\n     this.jzmap.set(h.id, h);\n   }\n }\n\n var jcl = JZMap.prototype;\n\n jcl.use =\n function(id) {\n   ASSERT.call(this, this.jzmap.has(id), \'no such name: \'+id );\n   if (!HAS.call(this.active, id)) { \n     this.active.set(id, true);\n     var list = this.jzmap.get(id).uses, l = 0;\n     while (l < list.length)\n       this.use(list[l++]);\n   }\n };\n\n jcl.asCode =\n function() {\n   var list = this.active, l = 0, len = list.length();\n   var str = \"\";\n   while (l < len) {\n     var name = list.keys[l++];\n     str += this.jzmap.get(name).codeString;\n   }\n\n   return str;\n };\n');
resolver.set('./src/LiquidGroup/new-core.js', '  import {ASSERT} from \'../other/constants.js\';\n  import Liquid from \'../Liquid/cls.js\';\n  import Ref from \'../Ref/cls.js\';\n  import {cls} from \'./cls.js\';\n\ncls.getL =\nfunction(idx) {\n  return idx < this.list.length ?\n    this.list[idx] : null;\n};\n\ncls.seal = function() {\n  ASSERT.call(this, !this.hasSeal, \'has seal\');\n  this.hasSeal = true;\n  return this;\n};\n\ncls.newL =\nfunction() {\n  ASSERT.call(this, !this.hasSeal, \'has seal\');\n\n  var liq = new Liquid(this.category);\n  liq.r(new Ref(this.scope));\n  liq.idx = this.length;\n  this.list.push(liq);\n  this.length = this.list.length;\n  return liq;\n};\n\n\n');
resolver.set('./src/LiquidGroup/whole.js', '  import \'./new-core.js\';\n');
resolver.set('./src/LiquidGroup/cls.js', '\nexport default function LiquidGroup(cat, scope) {\n  this.category = cat;\n  this.scope = scope;\n  this.list = [];\n  this.hasSeal = false;\n  this.length = 0;\n}\n\n export var cls = LiquidGroup.prototype;\n');
resolver.set('./src/AutoImex/new-core.js', '  import PathMan from \'../PathMan/cls.js\';\n  import {_m, _u} from \'../other/scope-util.js\';\n  import {ASSERT, HAS} from \'../other/constants.js\';\n  import SortedObj from \'../SortedObj/cls.js\';\n  import {cls} from \'./cls.js\';\n\n/* @<name>.js: \n *   export default <name>\n *   export var cls = <name>\n *\n * <sub>@<name>.js\n *   import <name>, {cls} from @<name>.js#relativeTo(<sub>@<name>.js)\n *\n * <name>.js\n *   <for binding in the source>\n *     export {<binding>};\n */\n\nvar pathMan = new PathMan();\n\ncls.insertSourceByURI =\nfunction(uri) {\n  var m = _m(uri);\n  ASSERT.call(this, !this.sources.has(m), \'existing [\'+uri+\']\');\n  var src = this.loadSource(uri), n = new this.Parser(src).parseProgram();\n\n  var scope = n[\'#scope\'];\n\n  n[\'#uri\'] = uri;\n\n  scope[\'#importList\'] = {ns: null, names: []};\n  scope[\'#exportList\'] = {bindings: [], defaultExpr: \"\", cls: \"\"};\n\n  var subName = pathMan.tail(uri);\n  var at = subName.indexOf(\'@\');\n  if (at === 0) {\n    var name = subName.substring(1, subName.indexOf(\'.\'));\n    var binding = scope.findDeclAny_m(_m(name));\n    ASSERT.call(this, binding, \'no [\'+name+\'] in [\'+uri+\']\');\n    scope[\'#exportList\'].defaultExpr = name;\n    this.logBinding(name, \'*default*\', uri);\n    this.insertBundleBinding(uri, binding);\n    ASSERT.call(this, scope.findDeclAny_m(_m(\'cls\')) === null, \'cls exists in \' + uri );\n    scope[\'#exportList\'].cls = \'cls\';\n    var cul = this.clsUriList;\n    var mname = _m(name);\n    ASSERT.call(this, !HAS.call(cul, mname),\n      \'class has been registered: [\'+name+\']<==[\'+uri+\']\');\n    cul[mname] = uri;\n    this.logBinding(name, \'<<cls>>\', uri);\n  }\n  else if (at > 0) {\n    scope[\'#clsThisList\'] = [];\n    var list = n.body, l = 0;\n    this.logE(\'stmts\', list.length);\n    while (l < list.length) {\n      var elem = list[l++];\n      this.logE(\'[uri-\'+uri+\';\'+elem.type+\']\');\n      if (elem.type !== \'ExpressionStatement\')\n        continue;\n\n      elem = elem.expression;\n      this.logE(\'[uri-\'+uri+\';\'+elem.type+\']\');\n      if (elem.type !== \'AssignmentExpression\')\n        continue;\n\n      elem = elem.left;\n      this.logE(\'[uri-\'+uri+\';\'+elem.type+\']\');\n      if (elem.type !== \'MemberExpression\')\n        continue;\n\n      elem = elem.object;\n      this.logE(\'[uri-\'+uri+\';\'+elem.type+\']\');\n      if (elem.type !== \'ThisExpression\')\n        continue;\n\n      scope[\'#clsThisList\'].push(elem);\n    }\n  }\n  else {\n    var list = scope.defs, l = 0, len = list.length();\n    while (l < len) {\n      var elem = list.at(l++ );\n      scope[\'#exportList\'].bindings.push({real: elem.name, outer: elem.name});\n      this.logBinding(elem.name, elem.name, uri );\n      this.insertBundleBinding(uri, elem);\n    }\n  }\n//this.handleSourceLevelBindings(uri, n[\'#scope\']);\n\n  n[\'#src\'] = src;\n\n  return this.sources.set(m, n);\n};\n\ncls.resolveAll =\nfunction() {\n  var list = this.sources, l = 0, len = list.length();\n  this.logE(\' --------- [\'+len+\'] sources ----------; START\');\n  while (l < len) {\n    var elem = list.at(l++ );\n    this.tryResolveExternals(elem);\n  }\n  this.logE(\' --------- [\'+l+\'/\'+len+\'] complete ---------\');\n};\n\ncls.tryResolveExternals =\nfunction(n) {\n  var sourceScope = n[\'#scope\'], globalScope = sourceScope.parent;\n  var list = globalScope.defs, l = 0, len = list.length();\n  while (l < len) {\n    var name = list.at(l++);\n    var b = this.findBundleBinding(name.name);\n    if (b) {\n      sourceScope[\'#importList\'].names.push({name: name.name, target: b});\n      this.logE(\'  [\'+n[\'#uri\']+\']:import [\'+name.name+\'] from [\'+b.uri+\'] \'+\n        (name.name === b.binding.ref.scope[\'#exportList\'].defaultExpr ? \'default\' : \'raw\' ) );\n    }\n  }\n};\n\ncls.insertBundleBinding =\nfunction(uri, elem) {\n  var name = elem.name;\n  var b = this.findBundleBinding(name);\n  if (b) ASSERT.call(this, false, \'name [\'+name+\'] exists @[\'+b.uri+\']\');\n\n  return this.bundleBindings.set(_m(name), {uri: uri, binding: elem});\n};\n\ncls.findBundleBinding =\nfunction(name) {\n  var mname = _m(name), bb = this.bundleBindings;\n  return bb.has(mname) ? bb.get(mname) : null;\n};\n\ncls.flush =\nfunction() {\n  var list = this.sources, l = 0, len = list.length();\n  while (l < len) {\n    var elem = list.at(l++);\n    this.onStartImports(elem);\n    this.writeImports(elem);\n    this.onFinishImports(elem);\n\n    this.onStartExports(elem);\n    this.writeExports(elem);\n    this.onFinishExports(elem);\n  }\n};\n\ncls.writeImports = \nfunction writeImports(n) {\n  var scope = n[\'#scope\'];\n  var uri = n[\'#uri\'];\n  this.logE(\'writing imports for [\'+uri+\']\');\n  var im = scope[\'#importList\'].names, usedSources = new SortedObj();\n  var len = im.length, l = 0;\n  while (l < len) {\n    var elem = im[l++];\n    var name = elem.name;\n    var target = elem.target;\n    var targetUri = target.uri, binding = target.binding;\n    var mname = _m(targetUri);\n//  console.error(\'  name[\'+name+\']\', mname, usedSources.obj);\n    var entry = usedSources.has(mname) ? usedSources.get(mname) : null;\n    if (entry === null)\n      entry = usedSources.set(mname, {bindings: [], defaultName: \"\", wholeNS: \"\" });\n    if (name === binding.ref.scope[\'#exportList\'].defaultExpr) {\n      ASSERT.call(this, entry.defaultName === \"\", \'[\'+targetUri+\'] default\');\n      entry.defaultName = name;\n    }\n    else { entry.bindings.push(name); }\n  }\n\n  len = usedSources.length(), l = 0;\n  while (l < len) {\n    var sourceBindings = usedSources.at(l);\n    var sourceUri = _u(usedSources.keys[l]);\n    var str = \"\";\n    if (sourceBindings.defaultName !== \"\")\n      str += sourceBindings.defaultName;\n    if (sourceBindings.bindings.length) {\n      if (str.length) str += \', \';\n      str += \'{\';\n      var bindings = sourceBindings.bindings, b = 0;\n      while (b < bindings.length) {\n        if (b) str += \', \';\n        str += bindings[b];\n        b++;\n      }\n      str += \'}\';\n    }\n    this.onImport({str: str, to: uri, from: sourceUri, usedSources: usedSources});\n    l++;\n  }\n};\n\ncls.writeExports = function(elem) {\n  var scope = elem[\'#scope\'];\n  var ex = scope[\'#exportList\'];\n  var str = \"\";\n  if (ex.defaultExpr !== \"\")\n    this.onExport(\' export default \'+ex.defaultExpr+\';\');\n  var list = ex.bindings, l = 0;\n  str = \"\";\n  while (l < list.length) {\n    if (l) str += \', \';\n    else { str = \'{\'; }\n    var elem = list[l++];\n    ASSERT.call(this, elem.real && elem.real === elem.outer, \'[real-\'+elem.real+\'; outer-\'+elem.outer+\']\');\n    str += elem.real;\n  }\n  if (l) {\n    str += \'}\';\n    this.onExport(\' export \'+str+\';\');\n  }\n\n  if (ex.cls !== \"\") {\n    ASSERT.call(this, ex.defaultExpr !== \"\", \'cls but no default\');\n    this.onExport(\' export var cls = \'+ex.defaultExpr+\'.prototype = ;\');\n  }\n};\n\ncls.pathThatLeads2to1 =\nfunction(from, to) {\n  var fromNum = 0, toNum = 0;\n  var fromStart = 0, toStart = 0;\n  var fromElemLen = 0, toElemLen = 0;\n\n  var manp = new PathMan();\n  var str = \"\";\n\n  var hasLeadingToElem = false;\n\n  while (true) {\n    fromElemLen = manp.len(from, fromStart);\n    if (fromElemLen === 0) {\n      ASSERT.call(this, fromNum > 0, \'[\'+from+\'] -- from has no elems\');\n      break;\n    }\n\n    toElemLen = manp.len(to, toStart);\n    if (toElemLen === 0) {\n      ASSERT.call(this, toNum > 0, \'[\'+to+\'] to has no elems\');\n      break;\n    }\n\n    var fromElem = manp.trimSlash(from.substr(fromStart, fromElemLen));\n    fromNum++;\n    fromStart += fromElemLen;\n\n    var toElem = manp.trimSlash(to.substr(toStart, toElemLen));\n    toNum++;\n    toStart += toElemLen;\n\n    if (fromElem !== toElem) {\n      str = \'..\';\n      hasLeadingToElem = true;\n      break;\n    }\n  }\n\n  while (true) {\n    fromElemLen = manp.len(from, fromStart);\n    if (fromElemLen === 0)\n      break;\n    if (str.length) str += \'/\';\n    str += \'..\';\n    fromStart += fromElemLen;\n  }\n\n  if (hasLeadingToElem) {\n    ASSERT.call(this, str.length, \'str must not be empty if hasLeadingToElem is set to on\' );\n    str += \'/\' + toElem;\n  }\n\n  while (true) {\n    toElemLen = manp.len(to, toStart);\n    if (toElemLen === 0)\n      break;\n    var toElem = manp.trimSlash(to.substr(toStart, toElemLen));\n    if (str.length) str += \'/\';\n    else str = \'./\';\n    str += toElem;\n    toStart += toElemLen;\n  }\n\n  console.error(\'[\'+from+\']*[\'+str+\']->[\'+to+\']\');\n  return str;\n};\n\ncls.logE =\nfunction() {\n  return console.error.apply(console, arguments);\n};\n\ncls.logBinding = \nfunction(real, outer, uri) {\n  this.logE(\'  [\'+uri+\']:export {[\'+real+\'] as [\'+outer+\']}\');\n};\n\n\n');
resolver.set('./src/AutoImex/whole.js', '  import \'./new-core.js\';\n');
resolver.set('./src/AutoImex/cls.js', '  import SortedObj from \'../SortedObj/cls.js\';\n\nexport default function AutoImex() {\n  this.Parser = null;\n  this.Emitter = null;\n  this.sources = new SortedObj();\n  this.unresolvedNames = new SortedObj();\n  this.bundleBindings = new SortedObj();\n  this.clsUriList = {};\n}\n\n export var cls = AutoImex.prototype;\n');
resolver.set('./src/Comments/new-core.js', '  import {cls} from \'./cls.js\';\n\ncls. push =\nfunction(comment) {\n  this.c.push(comment);\n  if (!this.n) {\n    this.firstLen += comment[\'#firstLen\'];\n    this.n = comment.type === \'Line\' ||\n      (comment.loc.start.line !== comment.loc.end.line);\n  }\n};\n\ncls.mergeWith =\nfunction(another) {\n  if (!this.n)\n    this.n = another.n;\n  this.c = this.c.concat(another.c);\n};\n\n\n');
resolver.set('./src/Comments/whole.js', '  import \'./new-core.js\';\n');
resolver.set('./src/Comments/cls.js', '\nexport default function Comments() {\n  this.c = [];\n  this.n = false;\n  this.firstLen = 0;\n}\n\n export var cls = Comments.prototype;\n');
resolver.set('./src/Bundler/new-core.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\n// \n// a\n// |__ b.js: import \'./l.js\'\n// |__ l.js: console.log(\'l.js in a\')\n//\n// e\n// |__ u.js -> a link to \'a/b.js\'\n// |__ l.js -> console.log(\'l.js in b\')\n//\n// with above, consider:\n// limport \'a/b.js\'; limport \'e/u.js\'\n// \n// what is its output supposed to be?\n\ncls.enter = \nfunction(relPath) {\n  var ll = { uri: this.curURI, dir: this.curDir };\n  var man = this.pathMan;\n\n  var at = 0, len = -1, n = this.curDir;\n  while (at < relPath.length) {\n    len = man.len(relPath, at);\n    var elem = relPath.substr(at, len);\n    n = man.joinRaw(n, man.trimAll(elem), true );\n    at += len;\n  }\n  this.curURI = n;\n  this.curDir = man.head(this.curURI);\n\n  return ll;\n};\n\ncls.setURIAndDir =\nfunction(uri, dir) {\n  this.curURI = uri;\n  this.curDir = dir;\n};\n\ncls.save =\nfunction(n) {\n  n[\'#scope\'][\'#uri\'] = this.curURI;\n  this.resolver.cache(this.curURI, n);\n};\n\ncls.getExistingSourceNode =\nfunction() {\n  return this.resolver.loadCached(this.curURI);\n};\n\ncls.loadNewSource =\nfunction() {\n  ASSERT.call(this, !this.resolver.hasInCache(this.curURI), \'incache\');\n  var n = this.resolver.loadNew(this.curURI);\n  this.resolver.cache(this.curURI, n);\n\n//n[\'#imports\'] = n[\'#scope\'].satisfyWithBundler(this);\n\n  this.freshSources.push(n);\n  return n;\n};\n\n\n');
resolver.set('./src/Bundler/whole.js', '  import \'./new-core.js\';\n');
resolver.set('./src/Bundler/cls.js', '  import BundleScope from \'../BundleScope/cls.js\';\n\nexport default function Bundler(pathMan) {\n  this.type = \'#Bundler\';\n  this.pathMan = pathMan;\n  this.curDir = \"\";\n  this.curURI = \"\";\n  this.resolver = null;\n  this.freshSources = [];\n  this[\'#scope\'] = null;\n  this.rootNode = null;\n  this.bundleScope = new BundleScope();\n}\n\n export var cls = Bundler.prototype;\n');
resolver.set('./src/ClassScope/whole.js', '  import \'./has.js\';\n');
resolver.set('./src/ClassScope/has.js', '  import {SF_HERITAGE} from \'../other/scope-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.hasHeritage =\nfunction() { return this.flags & SF_HERITAGE; };\n\n\n');
resolver.set('./src/ClassScope/cls.js', '  import Scope from \'../Scope/cls.js\';\n  import {ST_CLS} from \'../other/scope-constants.js\';\n\nexport default function ClassScope(sParent, sType) {\n  Scope.call(this, sParent, sType|ST_CLS);  \n  this.scopeName = null;\n}\n\n import {createObj} from \'../other/util.js\';\n export var cls = ClassScope.prototype = createObj(Scope.prototype);\n');
resolver.set('./src/SourceScope/new-core.js', '  import {_m} from \'../other/scope-util.js\';\n  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.forwardsSource =\nfunction(src) {\n  return this.allSourcesForwarded.has(_m(src));\n};\n\ncls.fillForwardedSourceEntryWith =\nfunction(fw, scope ) {\n  var mname = _m(fw);\n  ASSERT.call(this, this.allSourcesForwarded.has(mname) &&\n    this.allSourcesForwarded.get(mname) === null, \'not null\');\n  ASSERT.call(this, this.allSourcesImported.has(mname),\n    \'must also be in importsList\');\n\n  this.allSourcesForwarded.set(mname, scope);\n};\n\n\n');
resolver.set('./src/SourceScope/whole.js', '  import \'./new-core.js\';\n  import \'./ex.js\';\n  import \'./im.js\';\n  import \'./satisfy.js\';\n');
resolver.set('./src/SourceScope/ex.js', 'import {ASSERT} from \'../other/constants.js\';\nimport {_m} from \'../other/scope-util.js\';\nimport {cls} from \'./cls.js\';\nimport {DT_EFW, DT_EALIASED} from \'../other/scope-constants.js\';\n\ncls.regulateForwardExportList =\nfunction(list, src) {\n  var sourceImported = this.gocSourceImported(src.value);\n  var l = 0;\n  while (l < list.length)\n    this.regulateForwardExport(list[l++], sourceImported );\n};\n\ncls.regulateForwardExport =\nfunction(ex, sourceImported) {\n  var entry = ex[\'#entry\'];\n  var nd = this.createImportedBinding(ex.local, DT_EFW);\n  this.addImportedAlias_ios(nd, entry.innerName /* or outerName */, sourceImported );\n  ASSERT.call(this, entry.target === null, \'entry\');\n  entry.target = entry.target || { prev: null, v: nd, next: null };\n};\n\ncls.regulateOwnExportList =\nfunction(list) {\n  var l = 0;\n  while (l < list.length)\n    this.regulateOwnExport(list[l++][\'#entry\']);\n};\n\ncls.regulateOwnExport =\nfunction(entry) {\n  var mname = _m(entry.innerName), nd = this.findDeclAny_m(mname);\n  entry.target = nd ?\n    {p: null, v: nd, n: null} :\n    this.focUnresolvedExportedTarget(entry.innerName);\n};\n\ncls.registerForwardedSource =\nfunction(src) {\n  var mname = _m(src.value);\n  if (this.allSourcesForwarded.has(mname))\n    return;\n\n  this.allSourcesForwarded.set(mname, null);\n\n  this.allSourcesImported.has(mname) ||\n  this.allSourcesImported.set(mname, null);\n};\n\ncls.refreshUnresolvedExportsWith =\nfunction(n) {\n  var mname = _m(n.name);\n  var target = this.allUnresolvedExports.has(mname) ?\n    this.allUnresolvedExports.get(mname) : null;\n  if (target === null)\n    return;\n\n  ASSERT.call(this, target.v === null, \'target\' );\n  this.allUnresolvedExports.set(mname, null);\n\n  target.v = n; n.type = DT_EALIASED;\n  var tp = target.prev, tn = target.next;\n  if (target === this.latestUnresolvedExportTarget)\n    this.latestUnresolvedExportTarget = tp;\n\n  tp && (tp.next = tn);\n  tn && (tn.prev = tp);\n\n  target.next = target.prev = null;\n};\n\ncls.registerExportedEntry_oi =\nfunction(outerName, outerID, innerName) {\n  var mname = _m(outerName);\n  var entry = this.allNamesExported.has(mname) ?\n    this.allNamesExported.get(mname) : null;\n  entry && this.err(\'existing.export\');\n\n  var target = this.findDeclAny_m(_m(innerName));\n  if (target) target.type |= DT_EALIASED;\n\n  return this.allNamesExported.set(\n    mname, {innerName: innerName, outerName: outerName, target: null, outerID: outerID});\n};\n\ncls.focUnresolvedExportedTarget =\nfunction(name) {\n  var mname = _m(name);\n  if (this.allUnresolvedExports.has(mname))\n    return this.allUnresolvedExports.get(mname);\n\n  var target = null;\n  target = { prev: null, v: null, next: null };\n\n  var luet = this.latestUnresolvedExportTarget;\n  this.latestUnresolvedExportTarget = target;\n  if (luet) { luet.next = target; target.prev = luet; }\n\n  return this.allUnresolvedExports.set(mname, target  );\n};\n\n\n');
resolver.set('./src/SourceScope/im.js', '  import {_m} from \'../other/scope-util.js\';\n  import SortedObj from \'../SortedObj/cls.js\';\n  import Decl from \'../Decl/cls.js\';\n  import {cls} from \'./cls.js\';\n\ncls.regulateImports_sl =\nfunction(src, list) {\n  var sourceImported = this.gocSourceImported(src.value);\n  var e = 0;\n  while (e < list.length) {\n    var item = list[e++], target = item[\'#decl\'];\n    this.addImportedAlias_ios(\n      target,\n      target.isIAliased() ? item.imported.name :\n      target.isIDefault() ? \'*default*\' : \'*\', sourceImported\n    );\n  }\n};\n\ncls.addImportedAlias_ios =\nfunction(inner, outer, sourceImported) {\n  var aliases = this.gocAliasesImported(sourceImported, outer);\n  aliases.push(inner);\n};\n\ncls.gocSourceImported =\nfunction(src) {\n  var mname = _m(src);\n  var im = this.allSourcesImported.has(mname) ?\n    this.allSourcesImported.get(mname) : null;\n\n  return im || this.allSourcesImported.set(mname, new SortedObj());\n};\n\ncls.declareImportedName =\nfunction(id, t) {\n  var mname = _m(id.name);\n  var existing = this.findDeclAny_m(mname);\n  existing && this.err(\'existing.binding.for.import\');\n\n  var nd = this.createImportedBinding(id, t);\n  nd.r(this.rocRefU_m(mname));\n  this.insertDecl_m(mname, nd);\n  this.refreshUnresolvedExportsWith(nd );\n\n  return nd;\n};\n\ncls.gocAliasesImported =\nfunction(sourceImported, outerName) {\n  var mname = _m(outerName);\n  return sourceImported.has(mname) ? \n    sourceImported.get(mname) :\n    sourceImported.set(mname, []);\n};\n\ncls.createImportedBinding =\nfunction(id, t) {\n  var nd = new Decl()\n  nd.t(t).s(id).n(id.name);\n  return nd;\n};\n\n\n');
resolver.set('./src/SourceScope/satisfy.js', 'import {_u, _m} from \'../other/scope-util.js\';\nimport {ASSERT, HAS} from \'../other/constants.js\';\nimport {DT_EFW} from \'../other/scope-constants.js\';\nimport {cls} from \'./cls.js\';\n\ncls.satisfyWithBundler =\nfunction(bundler) {\n  var bundlerSources = bundler.freshSources;\n  var allSourcesImported = this.allSourcesImported,\n      e = 0, len = allSourcesImported.length();\n\n  bundler.freshSources = [];\n\n  while (e < len) {\n    var sourcePath = _u(allSourcesImported.keys[e]);\n    var exitPath = bundler.enter(sourcePath);\n    var src = bundler.getExistingSourceNode();\n    var isNew = false;\n    if (src === null) {\n      src = bundler.loadNewSource();\n      isNew = true;\n    }\n    ASSERT.call(this, src, \'source not found: \"\'+sourcePath+\'\"\' );\n\n    var satisfierScope = src[\'#scope\'];\n    this.registerImportedScope(sourcePath, src[\'#scope\']);\n\n    if (this.forwardsSource(sourcePath))\n      this.fillForwardedSourceEntryWith(sourcePath, satisfierScope);\n\n    if (isNew)\n      src[\'#imports\'] = src[\'#scope\'].satisfyWithBundler(bundler);\n\n    var entriesImported = allSourcesImported.at(e);\n    entriesImported && satisfierScope.satisfyEntries(entriesImported );\n\n    bundler.setURIAndDir(exitPath.uri, exitPath.dir);\n    e++;\n  }\n\n  var im = bundler.freshSources;\n  bundler.freshSources = bundlerSources;\n\n  return im;\n};\n\ncls.satisfyEntries =\nfunction(list) {\n  var len = list.length(), l = 0;\n  while (l < len) {\n    var name = _u(list.keys[l]);\n    var bindingList = list.at(l), bi = 0;\n    while (bi < bindingList.length)\n      this.satisfyBindingWithName(bindingList[bi++], name);\n    l++;\n  }\n};\n\ncls.satisfyBindingWithName =\nfunction(binding, name) {\n  var ex = this.searchExports(name, null);\n\n  if (!ex) this.parser.err(\'unresolved.name\');\n  this.resolve1to2(binding, ex.ref.getDecl_real());\n};\n\ncls.searchInOwnExports =\nfunction(name) {\n  var mname = _m(name);\n  var entry = this.allNamesExported.has(mname) ?\n    this.allNamesExported.get(mname) : null;\n  if (entry) {\n    ASSERT.call(this, entry.target.v, \'entry [\'+name+\'] in [\'+this[\'#uri\']+\']\' );\n    return entry.target.v;\n  }\n  return null;\n};\n\ncls.searchExports =\nfunction(name, soFar) {\n  var ex = this.searchInOwnExports(name);\n  if (ex === null) {\n    if (soFar === null) soFar = {};\n    soFar[this.ai] = this;\n    ex = this.searchInForwardedExports(name, soFar);\n  } \n  return ex;\n};\n\ncls.searchInForwardedExports =\nfunction(name, soFar) {\n  var list = this.allSourcesForwarded, l = 0, len = list.length();\n  var entry = null\n  while (l < len) {\n    var satisfier = list.at(l++);\n    if (!HAS.call(soFar, satisfier.ai)) {\n      entry = satisfier.searchExports(name, soFar);\n      if (entry) break;\n    }\n  }\n  return entry;\n};\n\ncls.resolve1to2 =\nfunction(slave, master) {\n  ASSERT.call(this, master === master.ref.getDecl_real(), \'master\');\n  ASSERT.call(this, master !== slave, \'same\');\n\n  var slaveRef = slave.ref;\n  if (slaveRef) {\n//  slaveRef.hasTarget = false;\n//  slaveRef.targetDecl = null;\n\n    var slaveRSList = slaveRef.rsList, l = 0;\n    if (master.rsMap === null)\n      master.refreshRSListWithList(master.ref.rsList);\n\n    master.refreshRSListWithList(slaveRef.rsList);\n    master.refreshRSListWith(slaveRef.scope);\n\n    ASSERT.call(this, slaveRef.parentRef === null, \'slaveRef\');\n    slaveRef.parentRef = master.ref;\n  }\n  else {\n    ASSERT.call(this, slave.type & DT_EFW, \'slave\' );\n    slave.ref = master.ref;\n  }\n\n  master.ref.i += slaveRef.i;\n  master.ref.d++; // TODO: must be exact\n};\n\ncls.registerImportedScope =\nfunction(uri, scope) {\n  var mname = _m(uri);\n  ASSERT.call(this, !this.allImportedScopes.has(mname), \'have [\'+uri+\']\');\n  this.allImportedScopes.set(mname, scope);\n};\n');
resolver.set('./src/SourceScope/cls.js', 'import ConcreteScope from \'../ConcreteScope/cls.js\';\nimport SortedObj from \'../SortedObj/cls.js\';\n\nexport default function SourceScope(parent, st) {\n  ConcreteScope.call(this, parent, st);\n  this.spThis = null;\n\n  this.allSourcesImported = this.asi = new SortedObj();\n  this.allNamesExported = this.ane = new SortedObj();\n  this.allSourcesForwarded = this.asf = new SortedObj();\n\n  this.latestUnresolvedExportTarget = null;\n  this.allUnresolvedExports = this.aue = new SortedObj();\n\n  this.renamedHoisted = [];\n  this.allImportedScopes = new SortedObj();\n\n  this[\'#uri\'] = \"\";\n  this[\'#loader\'] = \"\";\n}\n\nimport {createObj} from \'../other/util.js\';\nexport var cls = SourceScope.prototype = createObj(ConcreteScope.prototype);\n');
resolver.set('./src/Transformer/new-transform-AssignmentExpression.js', '  import {TransformByLeft, Transformers} from \'../other/globals.js\';\n  import {CB, tg, tzc, cvc} from \'../other/util.js\';\n  import {ASSERT, ASSERT_EQ, CVTZ_C, CHK_V, CHK_NONE} from \'../other/constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\nTransformByLeft[\'ArrayPattern\'] =\nfunction(n, isVal, isB) {\n  n.right = this.tr(n.right, true);\n\n  var s = [],\n      t = this.saveInTemp(this.synth_ArrIter(n.right), s),\n      list = n.left.elements,\n      idx = 0,\n      tElem = null;\n\n  var cbl = CB(n.left);\n  while (idx < list.length) {\n    var elem = list[idx];\n    tElem = this.trArrayElem(elem, t, idx, isB, cbl);\n    tElem && s.push(tElem);\n    idx++;\n  }\n\n  tElem = this.synth_ArrIterEnd(t);\n  tElem && s.push(tElem);\n\n  this.releaseTemp(t);\n\n  var res = this.synth_AssigList(s); // result\n  var cb = CB(res);\n\n  this.ac(cb, \'bef\', this.gec0(cbl, \'bef\'));\n  this.ac(cb, \'inner\', this.gec0(cbl, \'inner\'));\n  this.ac(cb, \'left.aft\', this.gec0(cbl, \'aft\'));\n  this.ac(cb, \'aft\', this.gec0(CB(n), \'aft\'));\n\n  return res;\n};\n\nTransformByLeft[\'ObjectPattern\'] =\nfunction(n, isVal, isB) {\n  n.right = this.tr(n.right, true);\n\n  var s = [],\n      t = this.saveInTemp(this.synth_ObjIter(n.right), s),\n      l = n.left.properties,\n      i = 0,\n      tElem = null;\n\n  while (i < l.length) {\n    tElem = this.trObjElem(l[i], t, isB);\n    tElem && s.push(tElem);\n    i++;\n  }\n\n  isVal && s.push(this.synth_ObjIterEnd(t));\n\n  this.releaseTemp(t);\n\n  var res = this.synth_AssigList(s);\n  var cb = CB(res), cbl = CB(n.left);\n\n  this.ac(cb, \'bef\', this.gec0(cbl, \'bef\'));\n  this.ac(cb, \'inner\', this.gec0(cbl, \'inner\'));\n  this.ac(cb, \'left.aft\', this.gec0(cbl, \'aft\'));\n  this.ac(cb, \'aft\', this.gec0(CB(n), \'aft\'));\n\n  return res;\n};\n\nTransformByLeft[\'AssignmentPattern\'] =\nfunction(n, isVal, isB) {\n  var l = n.left.left;\n  var d = n.left.right;\n  var r = n.right;\n\n  ASSERT.call(this, r.type === \'#Untransformed\',\n    \'assignment pattern can not have a transformable right\');\n\n  var t = this.allocTemp();\n\n  var test = this.synth_U(this.synth_TempSave(t, r) || t);\n  this.releaseTemp(t);\n\n//var cvtz = this.setCVTZ(createObj(this.cvtz));\n  var consequent = /* this.tr(d, true) */ d;\n//this.setCVTZ(cvtz);\n\n  var assig = this.synth_SynthAssig(\n    l,\n    this.synth_UCond(test, consequent, t, (true)),\n    isB\n  );\n\n  var res = this.tr(assig, isVal);\n  var cb = CB(res);\n\n  this.ac(cb, \'aft\', this.gec0(CB(n.left), \'aft\'));\n  return res;\n};\n\nTransformByLeft[\'MemberExpression\'] =\nfunction(n, isVal, isB) {\n  ASSERT_EQ.call(this, isB, false);\n  if (n.operator === \'**=\') {\n    this.accessJZ();\n    var mem = n.left;\n    mem.object = this.tr(mem.object, true );\n    var t1 = this.allocTemp();\n    mem.object = this.synth_TempSave(t1, mem.object);\n    var t2 = null;\n    if (mem.computed) {\n      mem.property = this.tr(mem.property, true);\n      t2 = this.allocTemp();\n      mem.property = this.synth_TempSave(t2, mem.property);\n      this.releaseTemp(t2);\n    } else\n      t2 = mem.property;\n\n    this.releaseTemp(t1);\n    var r = this.tr(n.right, true );\n\n    n.left = mem;\n    n.operator = \'=\';\n\n    var sm = this.synth_node_MemberExpression(t1,t2);\n    sm.computed = mem.computed;\n    sm.loc = mem.loc;\n    sm[\'#acloc\'] = mem[\'#acloc\'];\n\n    n.right = this.synth_node_BinaryExpression(sm, \'**\', r);\n  } else {\n    n.left = this.trSAT(n.left);\n    n.right = this.tr(n.right, true);\n  }\n  return n;\n};\n\nTransformByLeft[\'Identifier\'] =\nfunction(n, isVal, isB) {\n  if (n.operator === \'**=\')\n    this.accessJZ();\n\n  n.right = this.tr(n.right, true);\n  var rn = n.left = this.toResolvedName(n.left, isB ? \'binding\' : \'sat\', true); // target\n  if (!isB) {\n    var l = tg(n.left);\n    l.ref.assigned();\n    if (this.needsCVLHS(l)) {\n      n.left[\'#cvtz\'] |= CVTZ_C;\n      this.cacheCVLHS(l);\n    }\n    else if (l.isRG())\n      n = this.synth_GlobalUpdate(n, false);\n  }\n\n  if (tzc(rn) || cvc(rn))\n    n.right = this.synth_TC(n.right, n.left)\n\n  if (isB) {\n    var target = tg(n.left);\n    if (!target.isReached())\n      this.makeReached(target);\n  } \n\n  return n;\n};\n\nTransformers[\'AssignmentExpression\'] =\nfunction(n, isVal, isB) {\n  return TransformByLeft[n.left.type].call(this, n, isVal, false);\n};\n\nTransformers[\'#SynthAssig\'] =\nfunction(n, isVal) {\n  ASSERT_EQ.call(this, isVal, false);\n  return TransformByLeft[n.left.type].call(this, n, isVal, n.binding);\n};\n\ncls.trArrayElem =\nfunction(left, iter, at, isB, cbn) {\n  var right = null, rest_cb = null;\n  if (left && left.type === \'RestElement\') {\n    right = this.synth_ArrIterGetRest(iter, at);\n    rest_cb = CB(left);\n    left = left.argument;\n  }\n  else\n    right = this.synth_ArrIterGet(iter, at);\n\n  if (left === null) {\n    if (cbn.h < cbn.holes.length) {\n      var h = cbn.holes[cbn.h];\n      if (h[0] <= at) {\n        this.ac(CB(right), \'bef\', h[1]);\n        cbn.h++;\n      }\n    }\n    return right;\n  }\n\n  var assig = this.synth_SynthAssig(left, right, isB);\n\n  var res = this.tr(assig, false), cb = CB(res);\n  if (rest_cb) {\n    this.ac(cb, \'bef\', this.gec0(rest_cb, \'bef\'));\n    this.ac(cb, \'aft\', this.gec0(rest_cb, \'aft\'));\n  }\n  return res;\n};\n\ncls.trObjElem =\nfunction(elem, iter, isB) {\n  var name = elem.key;\n  if (elem.computed)\n    name = elem.key = this.tr(name, true );\n\n  var right = this.synth_ObjIterGet(iter, name, elem.computed);\n  var left = elem.value;\n\n  return this.tr(this.synth_SynthAssig(left, right, isB), false);\n};\n\ncls.needsCVLHS =\nfunction(decl) {\n  if (!decl.isImmutable())\n    return false;\n  var tc = this.getTCCache(decl);\n  if (tc && (tc & CHK_V))\n    return false;\n  return true;\n};\n\ncls.cacheCVLHS =\nfunction(decl) {\n  var tc = this.getTCCache(decl);\n  if (tc)\n    ASSERT.call(this, !(tc & CHK_V), \'cache\');\n  else\n    tc = CHK_NONE;\n  this.cvtz[_m(decl.ref.scope.scopeID+\':\'+decl.name)] = tc | CHK_V;\n};\n\n\n');
resolver.set('./src/Transformer/new-transform-ContinueStatement.js', '  import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'ContinueStatement\'] =\nfunction(n, isVal) {\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-while-do.js', '  import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'DoWhileStatement\'] =\nfunction(n, isVal) {\n  var w = n[\'#scope\'];\n  var s = this.setScope(w);\n  n.body = this.tr(n.body, false);\n  this.setScope(s);\n  n.test = this.tr(n.test, true);\n\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-CallExpression.js', '  import {Transformers} from \'../other/globals.js\';\n  import {RS_SCALL, RS_THIS} from \'../other/scope-constants.js\';\n  import {THS_IS_REACHED, THS_NEEDS_CHK} from \'../other/constants.js\';\n  import {findElem} from \'../other/util.js\';\n\nTransformers[\'CallExpression\'] =\nfunction(n, isVal) {\n  var ti = false, l = n.callee;\n  if (l.type === \'Super\') {\n    l[\'#liq\'] = this.cur.findRefU_m(RS_SCALL).getDecl_nearest();\n    var th = this.cur.findRefU_m(RS_THIS).getDecl_nearest();\n    l[\'#this\'] = this.synth_BareThis(th);\n    if (!(this.thisState & THS_IS_REACHED)) {\n      ti = true;\n      var lg = th.ref.scope.gocLG(\'ti\'), li = lg.getL(0);\n      if (li === null) { li = lg.newL(); lg.seal(); li.name = \'ti\'; }\n      l[\'#ti\'] = li;\n      li.track(this.cur); li.ref.d--;\n    }\n  }\n\n  var si = findElem(n.arguments, \'SpreadElement\');\n  if (si === -1) {\n    if (l.type !== \'Super\')\n      n.callee = this.tr(n.callee, true );\n    this.trList(n.arguments, true );\n    if (ti) { this.thisState |= THS_IS_REACHED; this.thisState &= ~THS_NEEDS_CHK; }\n    return n;\n  }\n\n  this.accessJZ();\n\n  var head = n.callee, mem = null;\n  if ( head.type === \'MemberExpression\') {\n    head.object = this.tr(head.object, true);\n    var loc = head.object.loc;\n    var t = this.allocTemp();\n    var h0 = head;\n    head = this.synth_TempSave(t, head.object);\n    h0.object = t;\n    t.loc = loc;\n    this.releaseTemp(t);\n    if (h0.computed)\n      h0.property = this.tr(h0.property, true );\n    mem = h0;\n  }\n  else if (l.type === \'Super\') {\n    mem = l;\n    head = this.synth_BareThis(this.cur.findRefU_m(RS_THIS).getDecl_nearest());\n  }\n  else\n    head = this.tr(head, true );\n\n  this.trList(n.arguments, true );\n\n  if (ti) { this.thisState |= THS_IS_REACHED; this.thisState &= ~THS_NEEDS_CHK; }\n\n  var synthcall = this.synth_Call(head, mem, n.arguments);\n  synthcall.loc = n.loc;\n  synthcall[\'#argloc\'] = n[\'#argloc\'];\n\n  return synthcall;\n};\n\n');
resolver.set('./src/Transformer/core.js', '  import {HAS} from \'../other/constants.js\';\n  import {Transformers} from \'../other/globals.js\';\n  import {cls} from \'./cls.js\';\n\ncls.setCVTZ =\nfunction(cvtz) {\n  var l = this.cvtz;\n  this.cvtz = cvtz;\n  return l;\n};\n\ncls.setRR =\nfunction(reachedRef) {\n  var rr = this.reachedRef;\n  this.reachedRef = reachedRef;\n  return rr;\n};\n\ncls.setScope =\nfunction(scope) {\n  var cur = this.cur;\n  this.cur = scope ;\n  return cur;\n};\n\ncls.setTS =\nfunction(ts) {\n  var ts0 = this.tempStack;\n  this.tempStack = ts;\n  return ts0;\n};\n\ncls.setThis =\nfunction(thisState) {\n  var th = this.thisState;\n  this.thisState = thisState;\n  return th;\n};\n\ncls.tr =\nfunction(n, isVal) {\n  var ntype = n.type;\n  switch (ntype) {\n  case \'EmptyStatement\':\n  case \'#Untransformed\':\n  case \'Literal\':\n    return n;\n  }\n\n  var transformer = null;\n  if (HAS.call(Transformers, ntype))\n    transformer = Transformers[ntype];\n\n  if (transformer === null)\n    throw new Error(\'could not find <\'+ntype+\'>-transformer\');\n\n  return transformer.call(this, n, isVal);\n};\n\ncls.rename =\nfunction(base, i) { return this.renamer(base, i); };\n\n\n');
resolver.set('./src/Transformer/new-transform-BlockStatement.js', '  import {Transformers} from \'../other/globals.js\';\n  import {ASSERT_EQ} from \'../other/constants.js\';\n\nTransformers[\'BlockStatement\'] =\nfunction(n, isVal) {\n  ASSERT_EQ.call(this, isVal, false);\n  var bs = n[\'#scope\'];\n  if (bs.isCatch())\n    bs = null;\n  if (bs !== null) {\n    var s = this.setScope(bs);\n    this.cur.synth_defs_to(this.cur.synthBase);\n  }\n  this.trList(n.body, isVal);\n  if (bs !== null) this.setScope(s);\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-synth-Bundler.js', '  import {Transformers} from \'../other/globals.js\';\n  import {cls} from \'./cls.js\';\n\nTransformers[\'#Bundler\'] =\nfunction(n, isVal) {\n  var bs = n.bundleScope ;\n  bs.synth_globals(this.renamer);\n  n.rootNode = this.transformBundleItem(n.rootNode);\n\n  var jzLG = bs.getLG(\'jz\');\n  if (jzLG)\n    bs.synthLiquid(jzLG.getL(0));\n\n  return n;\n};\n\ncls.transformBundleItem =\nfunction(n) {\n//n[\'#scope\'].setSynthBase(this.bundleScope);\n  var list = n[\'#imports\'], len = list ? list.length : 0, l = 0;\n\n  while (l < len) {\n    list[l] =\n      this.transformBundleItem(list[l]);\n    l++;\n  }\n\n  return this.tr(n, false);\n};\n\n\n');
resolver.set('./src/Transformer/new-transform-ThisExpression.js', '  import {Transformers} from \'../other/globals.js\';\n  import {RS_THIS} from \'../other/scope-constants.js\';\n  import {ASSERT, THS_NEEDS_CHK, THS_IS_REACHED} from \'../other/constants.js\';\n\nTransformers[\'ThisExpression\'] =\nfunction(n, isVal) {\n  var ref = this.cur.findRefU_m(RS_THIS);\n  ASSERT.call(this, ref, \'could not find [:this:]\');\n  var th = ref.getDecl_nearest();\n  var ths = this.thisState;\n  if ((ths & THS_NEEDS_CHK) && !(ths & THS_IS_REACHED)) {\n    var lg = th.ref.scope.scs.gocLG(\'ti\');\n    var ti = lg.getL(0);\n    if (ti === null) { ti = lg.newL(); ti.name = \'ti\'; lg.seal(); }\n    ti.track(this.cur);\n\n    // that is, no longer check; but, TODO: better make this optimization optional to turn off\n    // class A extends L { constructor() { this/* <-- need */; this /* <-- needn\'t since the previous one has done it */ } }\n    this.thisState &= ~THS_NEEDS_CHK;\n\n    return this.synth_ResolvedThis(n, th, true);\n  }\n\n  return this.synth_ResolvedThis(n, th, false);\n};\n\n');
resolver.set('./src/Transformer/new-transform-ArrayExpression.js', '  import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'ArrayExpression\'] =\nfunction(n, isVal) {\n  this.trList(n.elements, true );\n  return n;\n};\n\n');
resolver.set('./src/Transformer/transform-utils.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.trListChunk =\nfunction(list, isVal, s, e) {\n  while (s<=e) {\n    if (list[s] !== null)\n      list[s] = this.tr(list[s], isVal);\n    s++ ; \n  }\n};\n\ncls.trSAT =\nfunction(n, isVal) {\n  switch (n.type) {\n  case \'Identifier\':\n    return this.toResolvedName(n, \'sat\');\n  case \'MemberExpression\':\n    return this.trSAT_mem(n);\n  }\n  ASSERT.call(this, false, \'SAT !== <\'+n.type+\'>\');\n};\n\ncls.accessTZ =\nfunction(scope) {\n  this.accessJZ();\n  var lg = scope.scs.gocLG(\'tz\');\n  var l = lg.getL(0);\n  if (!l) {\n    l = lg.newL();\n    l.name = \'tz\';\n    lg.seal();\n  }\n  return l.track(this.cur);\n};\n\ncls.accessJZ =\nfunction() {\n  var jzContainer = this.script;\n  if (jzContainer.parent.isBundle())\n    jzContainer = jzContainer.parent;\n\n  var lg = this.script.gocLG(\'jz\');\n  var l = lg.getL(0);\n  if (!l) {\n    l = lg.newL();\n    l.name = \'jz\' ;\n    lg.seal();\n  }\n  return l.track(this.cur);\n};\n\ncls.trList =\nfunction(list, isVal) {\n  return this.trListChunk(list, isVal, 0, list.length-1) ;\n};\n\n\n');
resolver.set('./src/Transformer/new-transform-cls.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {DT_CLSNAME, DT_FNNAME} from \'../other/scope-constants.js\';\n  import {_m} from \'../other/scope-util.js\';\n  import ScopeName from \'../ScopeName/cls.js\';\n  import Ref from \'../Ref/cls.js\';\n  import {Transformers} from \'../other/globals.js\';\n  import {tg} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.transformCls =\nfunction(n, isVal, oBinding) { // o -> outer\n  var scope = this.setScope(n[\'#scope\']), ex = oBinding === null;\n  var ctor = n[\'#ct\'] && n[\'#ct\'].value, reached = {v: true};\n  var list = [];\n\n  var tempsup = null, tempsupSave = null, s = null;\n  if (n.superClass) {\n    n.superClass = this.synth_Heritage(this.tr(n.superClass, true));\n    tempsup = this.allocTemp();\n    tempsupSave = this.synth_TempSave(tempsup, n.superClass);\n    s = ctor && ctor[\'#scope\'].spSuperCall;\n  }\n\n  if (null === ctor) ctor = this.syntheticCtor(n, tempsup);\n  else {\n    ctor = this.transformCtor(ctor, oBinding, reached);\n    if (s) { ctor.scall = { inner: s, outer: tempsup } };\n  }\n  var clsTemp = null;\n  var classSave = null;\n  if (ex) {\n    clsTemp = this.allocTemp();\n    classSave = this.synth_TempSave(clsTemp, ctor);\n  } else\n    classSave = this.synth_ClassSave(oBinding, ctor);\n\n  var jzCreateCls = this.synth_MakeClass(clsTemp, tempsup, oBinding);\n  var tproto = null;\n\n  var memList = n.body.body, i = 0;\n  var m = 0;\n  while (i < memList.length) {\n    var elem = memList[i];\n    if (elem.kind === \'constructor\') {\n      memList[i++] = null;\n      continue;\n    }\n    if (m === 0) {\n      tproto = tempsup || this.allocTemp();\n      jzCreateCls = this.synth_TempSave(tproto, jzCreateCls);\n    }\n    if (elem.computed)\n      elem.key = this.tr(elem.key, true);\n    var mem = elem.value = this.transformMem(elem.value, oBinding, reached);\n    if (mem.cls) mem.cls.outer = clsTemp;\n    m++;\n    i++;\n  }\n\n  tempsupSave && list.push(tempsupSave );\n  list. push(classSave);\n  list. push(jzCreateCls);\n\n  if (m) {\n    var classcut = this.synth_MemList(memList, tproto);\n    list. push(classcut);\n  }\n\n  if (isVal) {\n    ASSERT.call(this, oBinding === null, \'binding\');\n    ASSERT.call(this, clsTemp !== null, \'cls\');\n    list.push(clsTemp);\n  }\n\n  tproto && tproto !== tempsup && this.releaseTemp(tproto);\n  clsTemp && this.releaseTemp(clsTemp);\n  tempsup && this.releaseTemp(tempsup );\n\n  oBinding && this.makeReached(oBinding);\n  this.setScope(scope);\n\n  var cls = this.synth_AssigList(list); // transformed cls\n  cls.raw = n;\n  cls.loc = n.loc;\n  return cls;\n};\n\ncls.transformCtor =\nfunction(ctor, oBinding, r) {\n  var r0 = null;\n  if (oBinding) {\n    r0 = oBinding.reached;\n    oBinding.type |= DT_CLSNAME;\n    oBinding.reached = r;\n    ctor = this.transformRawFn(ctor, true) ;\n    oBinding.reached = r0;\n    oBinding.type &= ~DT_CLSNAME;\n    return ctor;\n  }\n  var scope = ctor[\'#scope\'];\n  REF: { \n    var clsName = ctor[\'#scope\'].parent.scopeName;\n    if (clsName === null) break REF;\n    var ref = scope.findRefU_m(_m(clsName.name));\n    if (ref === null || ref.getDecl_nearest() !== clsName) break REF;\n    var sn = scope.scopeName = new ScopeName(clsName.name, null).t(DT_FNNAME); \n\n    sn.r(new Ref(scope));\n\n    ref.hasTarget = false;\n    ref.parentRef = null;\n    ref.targetDecl_nearest = null;\n    sn.ref.absorbDirect(ref);\n  }\n\n  return this.transformExprFn(ctor);\n};\n\ncls.transformMem =\nfunction(mem, oBinding, r) {\n  var r0 = null, scope = mem[\'#scope\'], cls = scope.parent;\n  if (oBinding) {\n    r0 = oBinding.reached;\n    oBinding.type |= DT_CLSNAME;\n    oBinding.reached = r;\n    mem = this.transformExprFn(mem);\n    oBinding.reached = r0;\n    oBinding.type &= ~DT_CLSNAME;\n    return mem;\n  }\n\n  var sn = null;\n  REF:\n  if (cls.scopeName && !cls.scopeName.isInsignificant()) {\n    sn = cls.scopeName;\n    var ref = scope.findRefU_m(_m(sn.name));\n    if (ref === null) { sn = null; break REF; }\n    ASSERT.call(this, sn === ref.getDecl_nearest(), \'sn\' );\n    sn = new ScopeName(sn.name, null).t(DT_CLSNAME);\n    ASSERT.call(this,scope.parent.isClass(),\'cls\');\n    sn.r(new Ref(scope.parent));\n\n    ref.hasTarget = false;\n    ref.parentRef = null;\n    ref.targetDecl_nearest = null;\n    sn.ref.absorbDirect(ref);\n\n    this.makeReached(sn);\n    this.synthFnExprName(sn);\n  }\n\n  mem = this.transformExprFn(mem);\n  if (sn) mem.cls = { inner: sn, outer: null };\n\n  return mem;\n};\n\ncls.syntheticCtor =\nfunction(cls, heritage) {\n  return {\n    kind: \'synthc\',\n    heritage: heritage,\n    name: cls[\'#scope\'].scopeName,\n    type: \'#Untransformed\'\n  };\n\n};\n\nTransformers[\'ClassExpression\'] =\nfunction(n, isVal) {\n  return this.transformCls(n, isVal, null);\n};\n\nTransformers[\'ClassDeclaration\'] =\nfunction(n, isVal) {\n  var target = tg(n.id );\n  return this.transformCls(n, isVal, target);\n};\n\n\n');
resolver.set('./src/Transformer/new-transform-BinaryExpression.js', '  import {Transformers} from \'../other/globals.js\';\n  import {createObj} from \'../other/util.js\';\n\nTransformers[\'LogicalExpression\'] =\nfunction(n, isVal) {\n  n.left = this.tr(n.left, true);\n  var cvtz = this.setCVTZ(createObj(this.cvtz));\n  var th = this.thisState;\n  n.right = this.tr(n.right, true);\n  this.thisState = th;\n  this.setCVTZ(cvtz );\n  return n;\n};\n\nTransformers[\'BinaryExpression\'] =\nfunction(n, isVal) {\n  if (n.operator === \'**\')\n    this.accessJZ();\n  n.left = this.tr(n.left, true);\n  n.right = this.tr(n.right, true);\n  return n;\n};\n\n');
resolver.set('./src/Transformer/nsynth.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {isTemp, CB} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.synth_Temp =\nfunction(liq) {\n  return {\n    kind: \'temp\',\n    occupied: 0,\n    liq: liq,\n    type: \'#Untransformed\',\n    \'#c\': {},\n    loc: null\n  };\n};\n\ncls.synth_TempSave =\nfunction(t, expr) {\n  ASSERT.call(this, isTemp(t), \'t is not temp\');\n  if (t === expr)\n    return null;\n  return {\n    kind: \'temp-save\',\n    right: expr,\n    left: t,\n    type: \'#Untransformed\',\n    loc: expr.loc,\n    \'#c\': {}\n  };\n};\n\ncls.synth_AssigList =\nfunction(list) {\n  return {\n    kind: \'assig-list\',\n    type: \'#Untransformed\' ,\n    list: list,\n    \'#c\': {},\n    raw: null, // cls-exclusive\n    loc: null\n  };\n};\n\ncls.synth_UCond =\nfunction(t,c,a,tr) {\n  return {\n    kind: \'ucond\' ,\n    test: t,\n    consequent: c,\n    type: tr ? \'ConditionalExpression\' : \'#Untransformed\' ,\n    alternate: a,\n    \'#c\': {}\n  };\n};\n\ncls.synth_ArrIterEnd =\nfunction(iterVal) {\n  return {\n    kind: \'arr-iter-end\' ,\n    type: \'#Untransformed\' ,\n    iter: iterVal,\n    \'#c\': {}\n  };\n};\n\ncls.synth_ArrIter =\nfunction(iterVal) {\n  this.accessJZ();\n  return {\n    kind: \'arr-iter\',\n    type: \'#Untransformed\' ,\n    iter: iterVal,\n    \'#c\': {}\n  };\n};\n\ncls.synth_ArrIterGet =\nfunction(iterVal, at) {\n  return {\n    kind: \'arr-iter-get\',\n    type: \'#Untransformed\',\n    iter: iterVal,\n    idx: at,\n    \'#c\': {}\n  };\n};\n\ncls.synth_SynthAssig =\nfunction(left, right, isB) {\n  return {\n    binding: isB || false,\n    right: right,\n    left: left,\n    type: \'#SynthAssig\',\n    operator: \'=\',\n    \'#c\': {}\n  };\n};\n\ncls.synth_Call =\nfunction(head, mem, list) {\n  return {\n    head: head,\n    mem: mem,\n    list: list,\n    type: \'#Untransformed\' ,\n    kind: \'call\',\n    \'#c\': {},\n    \'#argloc\': null,\n    loc: null\n  };\n};\n\ncls.synth_U =\nfunction(expr) {\n  this.accessJZ();\n  return {\n    kind: \'u\',\n    type: \'#Untransformed\' ,\n    value: expr,\n    \'#c\': {}\n  };\n};\n\ncls.synth_ArrIterGetRest =\nfunction(iter, at) {\n  return {\n    kind: \'arr-iter-get-rest\',\n    type: \'#Untransformed\' ,\n    iter: iter,\n    idx: at,\n    \'#c\': {}\n  };\n};\n\ncls.synth_ObjIter =\nfunction(iterVal) {\n  return {\n    kind: \'obj-iter\',\n    type: \'#Untransformed\' ,\n    iter: iterVal,\n    \'#c\': {}\n  };\n};\n\ncls.synth_ObjIterEnd =\nfunction(iterVal) {\n  return {\n    kind: \'obj-iter-end\' ,\n    type: \'#Untransformed\' ,\n    iter: iterVal,\n    \'#c\': {}\n  };\n};\n\ncls.synth_ObjIterGet =\nfunction(iter, at, isC) {\n  return {\n    kind: \'obj-iter-get\',\n    type: \'#Untransformed\' ,\n    iter: iter,\n    idx: at,\n    computed: isC,\n    \'#c\': {}\n  };\n};\n\ncls.synth_ArgAt =\nfunction(at) {\n  return {\n    type: \'#Untransformed\' ,\n    idx: at,\n    kind: \'arg-at\',\n    \'#c\': {}\n  };\n};\n\ncls.synth_ArgRest =\nfunction(ex, at) {\n  return {\n    idx: at,\n    left: ex,\n    kind: \'arg-rest\',\n    type: \'#Untransformed\',\n    \'#c\': {}\n  };\n};\n\nvar SYNTH_VOID0 = {\n  type: \'UnaryExpression\',\n  operator: \'void\',\n  argument: {\n    type: \'Literal\',\n    value: 0,\n    raw: \'0\',\n    \'#c\': {}\n  },\n  \'#y\': 0,\n  \'#c\': {}\n};\n\ncls.synth_node_BinaryExpression =\nfunction(left,o,right,y) {\n  return {\n    left: left,\n    operator: o,\n    right: right,\n    type: \'BinaryExpression\',\n    \'#y\': y || 0,\n    \'#c\': {}\n  };\n};\n\ncls.synth_Void0 = function() { return SYNTH_VOID0; };\n\ncls.synth_SynthName =\nfunction(liq) {\n  return {\n    type: \'#Untransformed\' ,\n    kind: \'synth-name\',\n    liq: liq,\n    \'#c\': {}\n  };\n};\n\ncls.synth_node_MemberExpression =\nfunction(n,v) {\n  return {\n    loc: null,\n    computed: true,\n    object: n,\n    property: v,\n    \'#y\': 0,\n    \'#c\': {},\n    type: \'MemberExpression\'\n  };\n};\n\ncls.synth_TransformedFn =\nfunction(n, a) {\n  return {\n    type: \'#Untransformed\' ,\n    kind: \'transformed-fn\' ,\n    fun: n,\n    argsPrologue: a,\n    target: null,\n    \'#c\': {},\n    scall: null, cls: null,\n    loc: n.loc,\n    emitted: false\n  };\n};\n\ncls.synth_GlobalUpdate =\nfunction(assig, isU) {\n  return {\n    isU: isU,\n    kind: \'global-update\',\n    assig: assig,\n    type: \'#Untransformed\',\n    \'#c\': {}\n  };\n};\n\ncls.synth_SynthLiteral =\nfunction(l) {\n  switch (l.type) {\n  case \'Literal\':\n    return l;\n  case \'Identifier\':\n    return {\n      kind: \'synth-literal\',\n      raw: l.raw,\n      loc: l.loc,\n      type: \'#Untransformed\',\n      value: l.name,\n      \'#c\': CB(l)\n    };\n  }\n  ASSERT.call(this, false, \'Unknown [\'+l.type+\']\');\n};\n\nvar SKIP = {type: \'#Untransformed\', kind: \'skip\' };\ncls.synth_Skip =\nfunction() { return SKIP; };\n\ncls.synth_ResolvedThis =\nfunction(src, th, chk) {\n  var simp = th.ref.scope === this.cur.getThisBase();\n  return {\n    kind: \'resolved-this\',\n    id: src,\n    target: th,\n    type: \'#Untransformed\' ,\n    chk: chk,\n    loc: src.loc,\n    plain: simp\n  };\n\n};\n\ncls.synth_BareThis =\nfunction(th) {\n  return {\n    type: \'#Untransformed\' ,\n    target: th,\n    kind: \'bthis\',\n    plain: th.ref.scope === this.cur.getThisBase()\n  };\n\n};\n\ncls.synth_MakeClass =\nfunction(cls, herit, target) {\n  return {\n    cls: cls,\n    heritage: herit,\n    kind: \'cls\',\n    type: \'#Untransformed\' ,\n    target: target\n  };\n\n};\n\ncls.synth_RCheck =\nfunction(v,t) {\n  this.accessJZ();\n  return {\n    val: v,\n    th: t,\n    kind: \'rcheck\',\n    type: \'#Untransformed\'\n  };\n\n};\n\ncls.synth_MemList =\nfunction(mList, tProto) {\n  return {\n    m: mList,\n    type: \'#Untransformed\' ,\n    kind: \'memlist\',\n    p: tProto\n  };\n\n};\n\ncls.synth_ClassSave =\nfunction(target, ctor) {\n  return {\n    target: target,\n    ctor: ctor,\n    kind: \'cls-assig\',\n    type: \'#Untransformed\'\n  };\n\n};\ncls.synth_Heritage =\nfunction(h) {\n  return {\n    type: \'#Untransformed\' ,\n    heritage: h,\n    kind: \'heritage\',\n  };\n};\n\ncls.synth_TC =\nfunction(right, rn) {\n  this.accessJZ(); // jz  o\n  return {\n    value: right,\n    kind: \'cvtz\',\n    rn: rn,\n    type: \'#Untransformed\' ,\n  };\n\n};\n\ncls.synth_TVal =\nfunction(ex) {\n  return {\n    type: \'#Untransformed\' ,\n    kind: \'tval\',\n    ex: ex\n  };\n};\n\ncls.synth_NameList =\nfunction(scope, vinit) {\n  return {\n    type: \'#Untransformed\' ,\n    kind: \'llinosa-names\',\n    scope: scope ,\n    withV: vinit\n  };\n\n};\n\ncls.synth_TZCheckPoint =\nfunction(scope) {\n  ASSERT.call(this, scope.hasTZCheckPoint, \'can not create a synth tzchp for a scope that lacks one\');\n  return {\n    type: \'#Untransformed\',\n    kind: \'tzcheckpoint\',\n    scope: scope\n  };\n};\n');
resolver.set('./src/Transformer/whole.js', '  import \'./new-transform-AssignmentExpression.js\';\n  import \'./new-transform-ContinueStatement.js\';\n  import \'./new-transform-while-do.js\';\n  import \'./new-transform-CallExpression.js\';\n  import \'./core.js\';\n  import \'./new-transform-BlockStatement.js\';\n  import \'./new-transform-synth-Bundler.js\';\n  import \'./new-transform-ThisExpression.js\';\n  import \'./new-transform-ArrayExpression.js\';\n  import \'./transform-utils.js\';\n  import \'./new-transform-cls.js\';\n  import \'./new-transform-BinaryExpression.js\';\n  import \'./nsynth.js\';\n  import \'./new-transform-whole-prog.js\';\n  import \'./new-transform-exim.js\';\n  import \'./new-transform-BreakStatement.js\';\n  import \'./new-transform-fn.js\';\n  import \'./new-transform-MemberExpression.js\';\n  import \'./names.js\';\n  import \'./temp.js\';\n  import \'./new-transform-ConditionalExpression.js\';\n  import \'./new-transform-IfStatement.js\';\n  import \'./new-transform-ExpressionStatement.js\';\n  import \'./new-transform-SwitchStatement.js\';\n  import \'./new-transform-SpreadElement.js\';\n  import \'./new-transform-Identifier.js\';\n  import \'./new-transform-NewExpression.js\';\n  import \'./new-transform-UnaryExpression.js\';\n  import \'./new-transform-LabeledStatement.js\';\n  import \'./new-transform-for.js\';\n  import \'./new-transform-ThrowStatement.js\';\n  import \'./new-transform-ReturnStatement.js\';\n  import \'./new-transform-TaggedTemplateExpression.js\';\n  import \'./new-transform-ObjectExpression.js\';\n  import \'./new-transform-For.js\';\n  import \'./new-transform-UpdateExpression.js\';\n  import \'./comment-helpers.js\';\n  import \'./new-transform-TemplateLiteral.js\';\n  import \'./new-transform-SequenceExpression.js\';\n  import \'./new-transform-VariableDeclaration.js\';\n  import \'./new-transform-WhileStatement.js\';\n  import \'./new-transform-TryStatement.js\';\n');
resolver.set('./src/Transformer/new-transform-whole-prog.js', '  import {Transformers} from \'../other/globals.js\';\n  import {ASSERT_EQ, ASSERT} from \'../other/constants.js\';\n\nTransformers[\'Program\'] =\nfunction(n, isVal) {\n  ASSERT_EQ.call(this, isVal, false);\n  this.script = n[\'#scope\'];\n\n  var g = this.global = this.script.parent;\n\n  if (g.isGlobal())\n    g.synth_globals(this.renamer);\n  else\n    ASSERT.call(this, g.isBundle(), \'script can not have a non-global parent\');\n\n\n  var ps = this.setScope(this.script);\n  var ts = this.setTS([]);\n\n  this.cur.synth_start(this.renamer);\n  this.trList(n.body, isVal);\n  this.cur.synth_finish();\n\n  this.setScope(ps);\n  this.setTS(ts);\n\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-exim.js', 'import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'ExportNamedDeclaration\'] = \nfunction(n, isVal) {\n  // TODO: transform local names to rns when bundling is not active\n\n  if (n.declaration !== null)\n    n.declaration = this.tr(n.declaration, false);\n\n  n.type = \'#\' + n.type ;\n  return n;\n};\n\nTransformers[\'ExportDefaultDeclaration\'] =\nfunction(n, isVal) {\n  var elem = n.declaration;\n  var isVal = true, renamedHoisted = false;\n  switch (elem.type) {\n  case \'FunctionDeclaration\':\n    if (elem.id === null) {\n      elem.type = \'FunctionExpression\';\n      renamedHoisted = true;\n    }\n    else\n      isVal = false;\n    break;\n  case \'ClassDeclaration\':\n    if (elem.id === null)\n      elem.type = \'ClassExpression\';\n    else\n      isVal = false;\n    break;\n  }\n\n  n.declaration = this.tr(elem, isVal);\n  n.type = \'#\' + n.type ;\n\n  if (renamedHoisted)\n    this.cur.renamedHoisted.push(n);\n\n  return n;\n};\n\nTransformers[\'ExportAllDeclaration\'] =\nfunction(n, isVal) {\n  n.type = \'#\' + n.type ;\n  return n;\n};\n\nTransformers[\'ImportDeclaration\'] =\nfunction(n, isVal) {\n  n.type = \'#\' + n.type ;\n  return n; \n};\n\n');
resolver.set('./src/Transformer/new-transform-BreakStatement.js', '  import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'BreakStatement\'] =\nfunction(n, isVal) {\n  return n; // TODO: try { break } finally { yield }\n};\n\n');
resolver.set('./src/Transformer/new-transform-fn.js', 'import {ASSERT, THS_NEEDS_CHK, THS_NONE, THS_IS_REACHED, HAS, ASSERT_EQ} from \'../other/constants.js\';\nimport {createObj, tg} from \'../other/util.js\';\nimport {_m} from \'../other/scope-util.js\';\nimport {DT_FNARG} from \'../other/scope-constants.js\';\nimport {Transformers} from \'../other/globals.js\';\nimport {cls} from \'./cls.js\';\n\ncls.transformRawFn =\nfunction(n, isVal) {\n  var s = n[\'#scope\'];\n  s = this.setScope(s);\n  ASSERT.call(this, s.reached, \'not reached\');\n  var unreach = n.type === \'FunctionDeclaration\';\n  if (unreach) s.reached = false;\n\n  var cvtz = this.setCVTZ(createObj(this.cvtz));\n  var ts = this.setTS([]);\n  var th = this.thisState, lg = null, l = null;\n\n  if (this.cur.isCtor() && this.cur.parent.hasHeritage()) {\n    lg = this.cur.gocLG(\'ti\');\n    l = lg.getL(0);\n    if (l===null) { l = lg.newL(); lg.seal(); l.name = \'ti\'; }\n  }\n\n  this.cur.closureLLINOSA = this.cur.parent.scs.isAnyFn() ?\n    createObj(this.cur.parent.scs.closureLLINOSA) : {};\n\n  this.cur.synth_start(this.renamer);\n  ASSERT.call(this, !this.cur.inBody, \'inBody\');\n\n  if (n.type === \'FunctionDeclaration\') {\n    var out = s.scs;\n    this.thisState = out.isCtor() && out.parent.hasHeritage() ?\n      THS_NEEDS_CHK : THS_NONE;\n  }\n\n  var argsPrologue = this.transformParams(n.params);\n  if (argsPrologue) n.params = null;\n\n  if (n.type === \'ArrowFunctionExpression\')\n    this.thisState = th;\n  else\n    this.thisState = this.cur.isCtor() && this.cur.parent.hasHeritage() ?\n      THS_NEEDS_CHK : THS_NONE;\n\n  this.cur.activateBody();\n  var fnBody = n.body.body;\n  this.trList(fnBody, false);\n\n  if (l && !(this.thisState & THS_IS_REACHED) && (this.thisState & THS_NEEDS_CHK)) {\n    var len = fnBody.length;\n    if (len === 0 || fnBody[len-1].type !== \'ReturnStatement\') {\n      l.track(this.cur);\n      fnBody.push(this.synth_RCheck(null, l));\n    }\n  }\n\n  this.cur.deactivateBody();\n  this.cur.synth_finish();\n\n  if (unreach) {\n    ASSERT.call(this, !s.reached, \'reached\');\n    s.reached = true;\n  }\n\n  this.setScope(s);\n  this.setTS(ts);\n\n  this.setCVTZ(cvtz) ;\n  this.thisState = th;\n\n  return this.synth_TransformedFn(n, argsPrologue);\n};\n\ncls.transformDeclFn =\nfunction(n) {\n  var target = tg(n.id);\n  ASSERT.call(this, target, \'unresolved (\'+n.id.name+\')\');\n  n = this.transformRawFn(n, false);\n  n.target = target;\n  return n;\n};\n\ncls.transformExprFn =\nfunction(n) {\n  var sn = n[\'#scope\'].scopeName;\n  if (sn) sn.isInsignificant() || this.synthFnExprName(sn);\n  n = this.transformRawFn(n, true);\n  return n;\n};\n\ncls.transformParams =\nfunction(list) {\n  if (this.cur.firstNonSimple)\n    return this.transformParamsToArgumentsPrologue(list);\n\n  var argd = null, argsmap = {}, e = list.length - 1;\n  while (e >= 0) {\n    var a = list[e];\n    var mname = _m(a.name);\n    if (HAS.call(argsmap, mname)) {\n      if (argd === null) {\n        var lg = this.cur.gocLG(\'argd\');\n        argd = lg.getL(0);\n        if (argd === null) {\n          argd = lg.newL();\n          argd.name = \'_\';\n          lg.seal();\n        }\n        argd.type |= DT_FNARG;\n      }\n      list[e] = this.synth_SynthName(argd );\n    }\n    else {\n      a = this.toResolvedName(a, \'binding\');\n      argsmap[mname] = list[e] = a;\n    }\n    e--;\n  }\n\n  return null;\n};\n\nTransformers[\'FunctionDeclaration\'] =\nfunction(n, isVal) {\n  ASSERT_EQ.call(this, isVal, false);\n  var tr = this.transformDeclFn(n);\n  if (tr.target.isExported() && tr.target.name !== tr.target.synthName) {\n    var scope = tr.target.ref.scope ;\n    ASSERT.call(this, scope.isSourceLevel(), \'scope\');\n    scope.renamedHoisted.push(tr);\n  }\n    \n  this.cur.pushFun(n.id.name, tr);\n\n  return this.synth_Skip();\n};\n\nTransformers[\'ArrowFunctionExpression\'] =\nfunction(n, isVal) {\n  if (n.expression) \n    n.body = this.e2b(n.body);\n  return this.transformExprFn(n);\n};\n\nTransformers[\'FunctionExpression\'] =\nfunction(n, isVal) {\n  return this.transformExprFn(n);\n};\n\ncls.transformParamsToArgumentsPrologue =\nfunction(list) {\n  var a = null, t = null, e = 0;\n  var prologue = [];\n  while (e < list.length) {\n    var left = list[e];\n    if (left.type === \'RestElement\') {\n      left = left.argument;\n      if (left.type === \'Identifier\') {\n        left = this.toResolvedName(left, \'binding\');\n        prologue.push(this.synth_ArgRest(left, e));\n      }\n      else {\n        var t = this.allocTemp();\n        prologue.push(this.synth_ArgRest(t, e));\n        this.releaseTemp(t);\n        a = this.synth_SynthAssig(left, t, true);\n        a = this.tr(a, false);\n        if (a)\n          prologue.push(a);\n      }\n      ASSERT.call(this, e === list.length - 1, \'not last\');\n    }\n    else {\n      a = this.synth_SynthAssig(left, this.synth_ArgAt(e), true);\n      a = this.tr(a, false)\n      if (a)\n        prologue.push(a);\n    }\n    e++;\n  }\n\n  return this.synth_AssigList(prologue);\n};\n\ncls.synthFnExprName =\nfunction(fnName) {\n  ASSERT.call(this, fnName.synthName === \"\", \'synth\');\n//ASSERT.call(this, fnName.ref.scope.isExpr() || fnName.ref.scope.isCtor(), \'fn not an expr\');\n  var baseName = fnName.name, mname = \"\", synthName = this.rename(baseName, 0), num = 0;\n  var rsList = fnName.ref.rsList;\n\n  RENAME:\n  do {\n    mname = _m(synthName);\n    var synth = null;\n    var l = 0;\n\n    while (l < rsList.length) {\n      var scope = rsList[l++ ];\n      if (!scope.synth_ref_may_escape_m(mname, this.renamer))\n        continue RENAME;\n\n      synth = scope.synth_ref_find_homonym_m(mname, this.renamer);\n      if (synth && synth !== fnName)\n        continue RENAME;\n    }\n\n    break;\n  } while (synthName = this.rename(baseName, ++num), true);\n\n  fnName.synthName = synthName;\n};\n\ncls.e2b =\nfunction(ex) {\n  return {\n    type: \'BlockStatement\',\n    body: [{\n      type: \'ReturnStatement\',\n      argument: ex,\n      start: ex.start,\n      end: ex.end,\n      loc: ex.loc,\n      \'#c\': {}, \'#y\': 0\n    }],\n    start: ex.start,\n    end: ex.end,\n    loc: ex.loc, \'#c\': {}, \'#y\': 0\n  };\n};\n\n\n');
resolver.set('./src/Transformer/new-transform-MemberExpression.js', '  import {Transformers} from \'../other/globals.js\';\n  import {cls} from \'./cls.js\';\n\nTransformers[\'MemberExpression\'] =\nfunction(n, isVal) {\n  n.object = this.tr(n.object, true);\n  if (n.computed) n.property = this.tr(n.property, true);\n  return n;\n};\n\ncls.trSAT_mem = Transformers[\'MemberExpression\'];\n\n\n');
resolver.set('./src/Transformer/names.js', '  import {_m} from \'../other/scope-util.js\';\n  import {HAS, CHK_NONE, CHK_T, ASSERT, CVTZ_T} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.getTCCache =\nfunction(decl) {\n  var mname =_m(decl.ref.scope.scopeID+\':\'+decl.name);\n  return decl.ref.scope.reached ? this.cvtz[mname] :\n    HAS.call(this.cvtz, mname) ? this.cvtz[mname] : CHK_NONE;\n};\n\ncls.needsTZ =\nfunction(decl) {\n  if (!decl.isTemporal())\n    return false;\n\n  var tc = this.getTCCache(decl) ;\n  if (tc && (tc & CHK_T))\n    return false;\n\n  TZ: {\n    var tz = false;\n    if (!decl.isReached()) {\n      tz = true;\n      break TZ; \n    }\n    if (decl.isClassName())\n      return tz;\n\n    var ownerScope = decl.ref.scope, cur = this.cur;\n    if (ownerScope === cur) {\n      tz = false;\n      break TZ;\n    }\n    while (cur.parent !== ownerScope) {\n      cur = cur.parent;\n      ASSERT.call(this, cur, \'reached top before decl owner is reached -- tz test is only allowed in scopes that \'+\n        \'can access the decl\');\n    }\n    tz = cur.isHoisted();\n  }\n  tz && this.cacheTZ(decl);\n  return tz;\n};\n\ncls.cacheTZ =\nfunction(decl) {\n  var tc = this.getTCCache(decl);\n  if (tc)\n    ASSERT.call(this, !(tc & CHK_T), \'cache\');\n  else\n    tc = CHK_NONE;\n  this.cvtz[_m(decl.ref.scope.scopeID+\':\'+decl.name)] = tc | CHK_T;\n};\n\ncls.makeReached =\nfunction(target) {\n  ASSERT.call(this, target.reached === null, \'reached used\');\n  target.reached = this.reachedRef;\n};\n\ncls.toResolvedName =\nfunction(id, bes, manualActivation) {\n  ASSERT.call(this, id.type == \'Identifier\', \'no\');\n\n  var ref = id[\'#ref\'], target = ref.getDecl_real();\n  ASSERT.call(this, target, \'unresolved <\'+id.name+\'>\');\n\n  var isB = bes === \'binding\';\n\n  var hasTZ = !isB && this.needsTZ(target);\n  if (hasTZ) {\n    if (target.isClassName())\n      return this.synthCheckForTZ(target, null, -1);\n\n    target.activateTZ();\n    this.accessTZ(target.ref.scope);\n  }\n\n  if (hasTZ) id[\'#cvtz\'] |= CVTZ_T;\n\n  id.type = \'#-ResolvedName.\' + bes;\n  return id;\n};\n\ncls.getDeclFor =\nfunction(name, isB) {\n  ASSERT.call(this, isB === true || isB === false, \'isB\' );\n  var target = null;\n  if (isB)\n    target = this.cur.findDeclAny_m(_m(name));\n  else {\n    var ref = this.cur.findRefAny_m(_m(name));\n    ASSERT.call(this, ref, \'name is not used in the current scope: <\'+name+\'>\');\n    target = ref.getDecl_real();\n  }\n  return target;\n};\n\ncls.synthCheckForTZ =\nfunction(target, t, num) {\n  this.accessJZ();\n  return {\n    liq: t,\n    idx: num,\n    kind: \'tzchk\',\n    type: \'#Untransformed\' ,\n    target: target\n  };\n\n};\n\n\n');
resolver.set('./src/Transformer/temp.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.releaseTemp =\nfunction(t) {\n  ASSERT.call(this, t.occupied, \'unoccupied temp\');\n  t.occupied = 0;\n\n  this.tempStack.push(t);\n  return t;\n};\n \ncls.saveInTemp =\nfunction(expr, list) {\n  var t = this.allocTemp();\n  var tsave = this.synth_TempSave(t, expr);\n  tsave && list.push(tsave);\n  return t;\n};\n\ncls.createTemp =\nfunction() {\n  var liq = this.cur.scs.gocLG(\'<t>\').newL();\n  liq.name = \'t\';\n  return this.synth_Temp(liq);\n};\n\ncls.allocTemp =\nfunction() { \n  var t = null;\n  if (this.tempStack.length !== 0)\n    t = this.tempStack.pop();\n  else \n    t = this.createTemp();\n\n  ASSERT.call(this, t.occupied === 0, \'occupied temp\');\n  t.occupied = 1;\n\n  t.liq.track(this.cur);\n\n  return t;\n};\n\n\n');
resolver.set('./src/Transformer/new-transform-ConditionalExpression.js', '  import {Transformers} from \'../other/globals.js\';\n  import {createObj} from \'../other/util.js\';\n\n// TODO: when transforming is done and the original cvtz is re-activated, it should be augment by the\n// elements common between if.cvtz and else.cvtz; e.g., 12 ? l /* <-- tz */ : l() /* <-- tz */; /* cvtz += if.cvtz :@: else.cvtz let l = l /* has tz but no chk */\nTransformers[\'ConditionalExpression\'] =\nfunction(n, isVal) {\n  n.test = this.tr(n.test, true);\n  var cvtz = this.setCVTZ(createObj(this.cvtz));\n  var th = this.thisState;\n  n.consequent = this.tr(n.consequent, isVal);\n  var thc = this.thisState; this.thisState = th;\n  this.setCVTZ(createObj(cvtz));\n  n.alternate = this.tr(n.alternate, isVal);\n  this.thisState = th|(this.thisState & thc); // same should be done for the tz/cv-thing, below\n  this.setCVTZ(cvtz) ;\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-IfStatement.js', '  import {Transformers} from \'../other/globals.js\';\n  import {ASSERT_EQ} from \'../other/constants.js\';\n\nTransformers[\'IfStatement\'] =\nfunction(n, isVal) {\n  ASSERT_EQ.call(this, isVal, false);\n  var altax = n[\'#elseScope\'], conax = n[\'#ifScope\'];\n\n  n.test = this.tr(n.test, true);\n\n  var s = this.setScope(conax);\n  n.consequent = this.tr(n.consequent, false);\n\n  if (n.alternate) {\n    this.setScope(altax);\n    n.alternate = this.tr(n.alternate, false);\n  }\n\n  this.setScope(s);\n\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-ExpressionStatement.js', '  import {Transformers} from \'../other/globals.js\';\n  import {ASSERT_EQ} from \'../other/constants.js\';\n\nTransformers[\'ExpressionStatement\'] =\nfunction(n, isVal) {\n  ASSERT_EQ.call(this, isVal, false);\n  n.expression = this.tr(n.expression, false);\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-SwitchStatement.js', '  import {Transformers} from \'../other/globals.js\';\n  import {ASSERT_EQ} from \'../other/constants.js\';\n\nTransformers[\'SwitchStatement\'] =\nfunction(n, isVal) {\n  ASSERT_EQ.call(this, isVal, false);\n  n. discriminant = this.tr(n.discriminant, true);\n  var s = this.setScope(n[\'#scope\']);\n  this.trList(n.cases, false);\n  this.setScope(s);\n  return n;\n};\n\nTransformers[\'SwitchCase\'] =\nfunction(n, isVal) {\n  ASSERT_EQ.call(this, isVal, false);\n  if (n.test !== null)\n    n.test = this.tr(n.test, true);\n  var rr = this.setRR({v: true});\n  this.trList(n.consequent, false);\n  rr = this.setRR(rr);\n  rr .v = false;\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-SpreadElement.js', '  import {Transformers} from \'../other/globals.js\';\n  import {ASSERT_EQ} from \'../other/constants.js\';\n\nTransformers[\'SpreadElement\'] =\nfunction(n, isVal) {\n  ASSERT_EQ.call(this, isVal, true);\n  this.accessJZ(); // jz.arr, jz.sp\n  n.argument = this.tr(n.argument, isVal);\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-Identifier.js', '  import {Transformers} from \'../other/globals.js\';\n  import {cls} from \'./cls.js\';\n\nTransformers[\'Identifier\'] =\nfunction(n, isVal) {\n  n = this.toResolvedName(n, \'ex\');\n  return n;\n};\n\ncls.trSAT_name =\nfunction(n, isVal) {\n  n = this.toResolvedName(n, \'sat\');\n  return n;\n};\n\n\n');
resolver.set('./src/Transformer/new-transform-NewExpression.js', '  import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'NewExpression\'] =\nfunction(n, isVal) {\n  n.callee = this.tr(n.callee, true);\n  this.trList(n.arguments, true);\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-UnaryExpression.js', '  import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'UnaryExpression\'] =\nfunction(n, ownerList, isVal) {\n  n.argument = this.tr(n.argument, ownerList, true);\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-LabeledStatement.js', '  import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'LabeledStatement\'] =\nfunction(n, isVal) {\n  n.body = this.tr(n.body, false );\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-for.js', '  import {Transformers} from \'../other/globals.js\';\n\n// Transformers[\'ForOfStatement\'] = function(n, isVal) { return n; };\n// Transformers[\'ForInStatement\'] = function(n, isVal) { return n; };\nTransformers[\'ForStatement\'] = function(n, isVal) { return n; };\n\n');
resolver.set('./src/Transformer/new-transform-ThrowStatement.js', '  import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'ThrowStatement\'] =\nfunction(n, isVal) {\n  n.argument = this.tr(n.argument, true);\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-ReturnStatement.js', '  import {Transformers} from \'../other/globals.js\';\n  import {THS_IS_REACHED, THS_NEEDS_CHK} from \'../other/constants.js\';\n\nTransformers[\'ReturnStatement\'] =\nfunction(n, isVal) {\n  // TODO: try { return \'a\' /* <-- this */ } finally { yield \'b\' }\n  if (n.argument)\n    n.argument = this.tr(n.argument, true);\n  var retRoot = this.cur.scs;\n  RET:\n  if (retRoot.isCtor() && retRoot.parent.hasHeritage()) {\n    var lg = retRoot.gocLG(\'ti\'), l = lg.getL(0);\n    if (l===null) { l = lg.newL(); lg.seal(); l.name = \'ti\'; }\n    if ((this.thisState & THS_IS_REACHED) || !(this.thisState & THS_NEEDS_CHK)) break RET;\n    l.track(this.cur);\n    n.argument = this.synth_RCheck(n.argument, l);\n  }\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-TaggedTemplateExpression.js', '  import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'TaggedTemplateExpression\'] =\nfunction(n, isVal) {\n  n.tag = this.tr(n.tag, true);\n  n.quasi = this.tr(n.quasi, true);\n\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-ObjectExpression.js', '  import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'ObjectExpression\'] =\nfunction(n, isVal) {\n  var t = null;\n  if (n[\'#rest\'] >= 0)\n    t = n[\'#t\'] = this.allocTemp();\n  var list = n.properties, e = 0;\n  while (e < list.length) {\n    var elem = list[e++];\n    if (elem.computed) {\n      this.accessJZ(); // jz#obj\n      elem.key = this.tr(elem.key, true);\n    }\n    elem.value = this.tr(elem.value, true);\n  }\n  t && this.releaseTemp(t);\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-For.js', '  import {Transformers, TransformByLeft} from \'../other/globals.js\';\n\nTransformers[\'ForOfStatement\'] =\nfunction(n, isVal) {\n  var s = this.setScope(n[\'#scope\']);\n  this.cur.synth_defs_to(this.cur.synthBase);\n\n  var t = null;\n  n.right = this.tr(n.right, true);\n  t = this.allocTemp();\n  var l = n.left; \n  n.left = t;\n\n  var lead = null;\n  var tval = this.synth_TVal(t), isVar = false, simp = true;\n  if (l.type === \'VariableDeclaration\') {\n    isVar = true;\n    simp = l.declarations[0].id.type === \'Identifier\'; \n    l.declarations[0].init = tval;\n    lead = this.tr(l, false);\n  }\n  else\n    lead = this.tr(this.synth_SynthAssig(l, tval, false), false);\n\n  if (isVar)\n    lead = this.synth_AssigList([this.synth_NameList(this.cur, true), lead]);\n\n  n.body = this.tr(n.body, false);\n  if (n.body.type === \'BlockStatement\')\n    n.body[\'#lead\'] = lead;\n  else\n    n.body = this.synth_AssigList([lead, n.body]);\n\n  this.releaseTemp(t);\n\n  if (this.cur.hasTZCheckPoint)\n    n = this.synth_AssigList([this.synth_TZCheckPoint(this.cur), n]);\n\n  n.type = \'#ForOfStatement\';\n//if (isVar && simp)\n//  n = this.synth_AssigList([this.synth_NameList(this.cur, false), n]);\n\n  this.setScope(s);\n\n  return n;\n};\n\nTransformers[\'ForInStatement\'] =\nfunction(n, isVal) {\n  var left = n.left;\n  var simp = true;\n  var s = this.setScope(n[\'#scope\']);\n\n  this.cur.synth_defs_to(this.cur.synthBase );\n  var isVar = false;\n  if (left.type === \'VariableDeclaration\') {\n    isVar = true;\n    var elem = left.declarations[0];\n    left = elem.init === null ? elem.id : { // TODO: ugh\n      type: \'AssignmentPattern\',\n      right: elem.init,\n      left: elem.id,\n      end: elem.init.end,\n      loc: { start: elem.id.loc.start, end: elem.init.loc.end },\n      start: elem.id.start,\n      \'#c\': {}\n    };\n\n    n.left = left;\n    simp = left.type === \'Identifier\';\n  }\n\n  var lead = null, t = left.type ;\n\n  if (t === \'Identifier\') // TODO: must also handle renamedGlobals\n    TransformByLeft[\'Identifier\'].call(this, n, false, isVar);\n  else if (t === \'MemberExpression\') {\n    n.right = this.tr(n.right, true);\n    n.left = this.trSAT(n.left);\n  }\n  else {\n    n.right = this.tr(n.right, true);\n    var t = this.allocTemp(); this.releaseTemp(t);\n    var assig = this.synth_SynthAssig(n.left, t, isVar);\n    lead = this.tr(assig, false );\n    n.left = t;\n  }\n\n  if (isVar && !simp) {\n    var a = [this.synth_NameList(this.cur, true)];\n    if (lead) a. push(lead );\n    lead = this.synth_AssigList(a);\n  }\n\n  n.body = this.tr(n.body,false);\n  if (n.body.type === \'BlockStatement\')\n    n.body[\'#lead\'] = lead;\n  else if (lead)\n    n.body = this.synth_AssigList([lead, n.body]);\n\n  n.type = (isVar && simp) ? \'#ForInStatementWithDeclarationHead\' : \n    \'#ForInStatementWithExHead\';\n\n  if (isVar && simp)\n    n = this.synth_AssigList([this.synth_NameList(this.cur, false), n]);\n\n  if (this.cur.hasTZCheckPoint)\n    n = this.synth_AssigList([this.synth_TZCheckPoint(this.cur), n]);\n\n  this.setScope(s);\n  return n;\n};\n\n// TODO: a better way to emit init\'s that are vardecls with tz has to exist\nTransformers[\'ForStatement\'] =\nfunction(n, isVal) {\n  var s = this.setScope(n[\'#scope\']), lead = null;\n  var init = n.init, test = n.test, next = n.update;\n\n  this.cur.synth_defs_to(this.cur.synthBase);\n\n  if (init === null);\n  else if (init.type === \'VariableDeclaration\') {\n    var cutInit = false;\n    if (init.kind !== \'var\')\n      cutInit = true;\n    else {\n      var list = init.declarations, l = 0;\n      while (l < list.length)\n        if (list[l++].id.type !== \'Identifier\') {\n          cutInit = true;\n          break;\n        }\n    }\n    var tr = this.tr(init, false);\n    if (cutInit) {\n      n.init = null;\n      lead = tr;\n    }\n    else { n.init = tr; }\n  }\n  else { n.init = this.tr(init, false); }\n\n  if (test)\n    n.test = this.tr(test, true);\n\n  if (next)\n    n.update = this.tr(next, true);\n\n  n.body = this.tr(n.body, false);\n\n  n.type = \'#ForStatement\';\n\n  if (lead)\n    n = this.synth_AssigList([lead, n]);\n\n  if (this.cur.hasTZCheckPoint)\n    n = this.synth_AssigList([this.synth_TZCheckPoint(this.cur), n]);\n\n  this.setScope(s);\n\n  return n;\n};\n');
resolver.set('./src/Transformer/cls.js', '  import {THS_NONE} from \'../other/constants.js\';\n  import {renamer_incremental} from \'../other/renamer.js\';\n\nexport default function Transformer() {\n  // TODO: `inGen or `flag for more contextual info (doesn\'t `cur have all that, anyway?)\n  // CRUCIAL SCOPES:\n  this.global = null;\n  this.script = null;\n  this.cur = null;\n\n  // this could be per scope (i.e., a scope attibute),\n  this.tempStack = [];\n\n  this.reachedRef = {v: true};\n  this.cvtz = {};\n  this.thisState = THS_NONE;\n\n  // name.activeIf[`cur.scopeID] = `cur if set\n  this.activeIfScope = false;\n\n  // for var n in.ls `activeIfNames: name.activeIf[n#getID] = n\n  this.activeIfNames = null; // TODO: should rename to activeIfOther, because it can actually contain name-, scope-, or bare actices (actixes)\n\n  this.curNS = 0; // sinde-effencts\n  this.curAT = null; // activation target in use (mostly, it is just the same thing as this.cur)\n\n  this.renamer = renamer_incremental;\n}\n\n export var cls = Transformer.prototype;\n');
resolver.set('./src/Transformer/new-transform-UpdateExpression.js', '  import {Transformers} from \'../other/globals.js\';\n  import {isResolvedName, tg} from \'../other/util.js\';\n  import {CVTZ_C} from \'../other/constants.js\';\n\nTransformers[\'UpdateExpression\'] =\nfunction(n, isVal) {\n  var arg = this.trSAT(n.argument);\n  n.argument = arg;\n  if (isResolvedName(arg)) {\n    tg(arg).ref.assigned();\n    var leftsig = false;\n    if (this.needsCVLHS(tg(arg))) {\n      arg[\'#cvtz\'] |= CVTZ_C;\n      this.cacheCVLHS(tg(arg));\n    }\n    if (tg(arg).isRG())\n      n = this.synth_GlobalUpdate(n, true);\n  }\n\n  return n;\n};\n\n');
resolver.set('./src/Transformer/comment-helpers.js', '  import {ASSERT, HAS} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.ac =\nfunction(to, name, from) {\n  if (from === null)\n    return;\n  ASSERT.call(this, from, \'from\');\n  if (!HAS.call(to, name))\n    to[name] = from;\n  else\n    to[name].mergeWith(from );\n};\n\ncls.gec0 =\nfunction(cb, n) {\n  return HAS.call(cb, n) ? cb[n] : null;\n};\n\n\n');
resolver.set('./src/Transformer/new-transform-TemplateLiteral.js', '  import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'TemplateLiteral\'] =\nfunction(n, isVal) {\n  var list = n.expressions, l = 0;\n  while (l < list.length) {\n    var item = list[l];\n    list[l] = this.tr(item, true);\n    l++;\n  }\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-SequenceExpression.js', '  import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'SequenceExpression\'] =\nfunction(n, isVal) {\n  this.trList(n.expressions, isVal);\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-VariableDeclaration.js', '  import {Transformers} from \'../other/globals.js\';\n  import {ASSERT_EQ} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\nTransformers[\'VariableDeclaration\'] =\nfunction(n, isVal) {\n  ASSERT_EQ.call(this, isVal, false);\n  var list = n.declarations, kind = n.kind, l = 0, tr = null;\n  var s = [];\n  while (l < list.length) {\n    tr = this.transformDtor(list[l++], kind );\n    tr && s.push(tr);\n  }\n  return s.length === 1 ? s[0] : this.synth_AssigList(s);\n};\n\ncls.transformDtor =\nfunction(n, kind) {\n  var assig = null, left = n.id, right = n.init;\n  if (right === null) {\n    if (kind === \'var\')\n      return null;\n    right = this.synth_Void0();\n  }\n\n  assig = this.synth_SynthAssig(left, right, true);\n  return this.tr(assig, false);\n};\n\n\n');
resolver.set('./src/Transformer/new-transform-WhileStatement.js', '  import {Transformers} from \'../other/globals.js\';\n\nTransformers[\'WhileStatement\'] =\nfunction(n, isVal) {\n  n.test = this.tr(n.test, true);\n  var w = n[\'#scope\'];\n  var l = this.setScope(w);\n  n.body = this.tr(n.body, false);\n\n  this.setScope(l);\n\n  return n;\n};\n\n');
resolver.set('./src/Transformer/new-transform-TryStatement.js', '  import {Transformers} from \'../other/globals.js\';\n  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\nTransformers[\'TryStatement\'] =\nfunction(n, isVal) {\n//var s = this.setScope(n[\'#tryScope\']);\n//this.cur.synth_defs_to(this.cur.scs);\n  n.block = this.tr(n.block, false);\n//this.setScope(s);\n\n  if (n.handler)\n    n.handler = this.transformCatch(n.handler);\n\n  if (n.finalizer) {\n//  s = this.setScope(n[\'#finScope\']);\n    n.finalizer = this.tr(n.finalizer, false);\n//  this.setScope(s);\n  }\n \n  return n;\n};\n\ncls.transformCatch =\nfunction(n) {\n  var a = null, s = this.setScope(n[\'#scope\']);\n  ASSERT.call(this, !this.inBody, \'inside catch\' );\n\n  if (this.cur.argIsSimple) {\n    this.cur.argIsSignificant = true;\n    this.cur.synth_start(this.renamer);\n  }\n  else {\n    this.cur.synth_start(this.renamer);\n    a = this.transformCatchArgs(n);\n  }\n  this.cur.activateBody();\n  n.body = this.tr(n.body, false);\n  this.cur.deactivateBody();\n  this.cur.argIsSignificant || this.cur.synth_lcv();\n  n.body[\'#lead\'] = a;\n  this.setScope(s);\n  return n;\n};\n\ncls.transformCatchArgs =\nfunction(n) {\n  ASSERT.call(this, !this.cur.argIsSimple, \'catch\' );\n  var l = this.synth_SynthAssig(n.param, this.synth_SynthName(this.cur.catchVar), true);\n\n  return this.tr(l, false);\n};\n\n\n');
resolver.set('./src/Template/core.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\n// TODO: add a mechanism to react to cases where latestVal does not have a property (own or inherited)\n// whose name has the same value as idx\n\ncls.applyTo = function(obj, noErrIfUndefNull) {\n  var latestVal = obj, latestIdx = \"\", list = this.idxList, e = 0;\n  while (e < list.length) {\n    var idx = list[e];\n    if (latestVal === null || latestVal === void 0) {\n      if (noErrIfUndefNull)\n        return latestVal;\n      ASSERT.call(this, false,\n        (e === 0 ?\n          \'the value to apply the template to\' :\n          \'the value for index \' + latestIdx + \'(name=\"\'+list[latestIdx]+\'\")\') +\n        \'is \' + (latestVal !== null ? \'undefined\' : \'null\')\n      );\n    }\n    \n    latestVal = latestVal[idx];\n    latestIdx = e;\n\n    e++;\n  }\n\n  return latestVal;\n};\n\n\n');
resolver.set('./src/Template/whole.js', '  import \'./core.js\';\n');
resolver.set('./src/Template/cls.js', '  import {CH_SINGLEDOT, CH_GREATER_THAN, CH_LESS_THAN, CH_RPAREN, ASSERT, CH_LPAREN} from \'../other/constants.js\';\n\nexport default function Template(idxList) {\n  this.idxList = idxList;\n  this.str = \"\";\n}\n\nfunction readParen(str, i, eof) {\n  var elem = \"\";\n  while (!eof(str, i)) {\n    switch (str.charCodeAt(i)) {\n    case CH_SINGLEDOT: elem += \'.\'; break;\n    case CH_GREATER_THAN: elem += \')\'; break;\n    case CH_LESS_THAN: elem += \'(\'; break;\n    case CH_RPAREN: return elem;\n    default:\n      ASSERT.call(this, false, \n        \'invalid character at index \'+i+\' -- \"\'+str.charAt(i)+\'\"\');\n    }\n    i++;\n  }\n  ASSERT.call(this, false, \n    \'reached eof before any \")\" was found\');\n}\n\nfunction eof_default(str, i) {\n  return i >= str.length;\n}\n\nTemplate.from = function(str, i, eof) {\n  i = i || 0;\n  eof = eof || eof_default;\n  var start = i, needDot = false, list = [], pendingDot = false, elem = \"\";\n  while (!eof(str, i)) {\n    var ch = str.charCodeAt(i);\n    if (ch === CH_SINGLEDOT) {\n      if (pendingDot)\n        break;\n\n      i++;\n      list.push(elem);\n      elem = \"\";\n      if (needDot)\n        needDot = false;\n\n      pendingDot = true;\n      continue;\n    }\n    if (needDot)\n      ASSERT.call(this, false, \'dot expected at index\'+(i-1));\n\n    pendingDot = false;\n    if (ch === CH_LPAREN) {\n      i++;\n      elem += readParen(str, i, eof);\n      if (elem.length === 0)\n        needDot = true; \n      \n      i += elem.length + 1; // length + \')\'.length\n      continue;\n    }\n\n    // TODO: can be faster, yet for its limited use case it looks fast enough\n    elem += str.charAt(i);\n    i++;\n  }\n\n  pendingDot && ASSERT.call(this, false, \n    \'unexpected \' + (!eof(str, i) ? \'dot (index=\'+i+\')\' : \'eof\'));\n\n  if (needDot || elem.length > 0)\n    list.push(elem);\n\n  var template = new Template(list);\n  template.str = (start === 0 && i === str.length) ?\n    str :\n    str.substring(start, i);\n\n  return template;\n};\n\n export var cls = Template.prototype;\n');
resolver.set('./src/Emitter/new-emit-TryStatement.js', '  import {Emitters} from \'../other/globals.js\';\n\nEmitters[\'TryStatement\'] =\nfunction(n, flags, isStmt) {\n  this.w(\'try\').os().emitStmt(n.block, true);\n  var l = n.handler;\n  if (l) {\n    this.l().wm(\'catch\',\'\',\'(\',l[\'#scope\'].catchVar.synthName,\')\',\'\');\n    this.emitStmt(l.body, true);\n  }\n\n  l = n.finalizer;\n  if (l) this.l().w(\'finally\').os().emitStmt(l, true);\n};\n\n');
resolver.set('./src/Emitter/new-uemit-synth-u.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n\nUntransformedEmitters[\'u\'] =\nfunction(n, flags, isStmt) {\n  this.jz(\'u\').w(\'(\').eN(n.value).w(\')\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-emit-UpdateExpression.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB, isResolvedName, tzc, cvc, tg} from \'../other/util.js\';\n  import {EC_EXPR_HEAD, EC_NONE, ETK_ADD, ETK_MIN} from \'../other/constants.js\';\n\n// somevery[:wraplimit:]longid--\n// (someverylongid\n// )--\n//\nEmitters[\'UpdateExpression\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  var hasParen = false;\n  var l = n.argument;\n  var t = false, v = false;\n  if (isResolvedName(l)) { t = tzc(l); v = cvc(l); hasParen = t || v; }\n  else hasParen = flags & EC_EXPR_HEAD;\n\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n\n  if (t) { this.emitAccessChk_tz(tg(l)); this.w(\',\').os(); }\n  if (v) { this.emitAccessChk_invalidSAT(tg(l)); this.w(\',\').os(); }\n\n  var o = n.operator;\n  if (n.prefix) {\n    this.wt(o, o !== \'--\' ? ETK_ADD : ETK_MIN);\n    flags = EC_NONE;\n    this.emitSAT(n.argument, flags, 0);\n  }\n  else {\n    this.emitSAT(n.argument, flags, o.length);\n    this.writeToCurrentLine_raw(o); // hard-write because the wrapping affairs have been take care of when calling emitSAT\n  }\n  hasParen && this.w(\')\');\n  this.emc(cb, \'aft\');\n\n  isStmt && this.w(\';\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-uemit-synth-tval.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {ASSERT, EC_NONE} from \'../other/constants.js\';\n\nUntransformedEmitters[\'tval\'] =\nfunction(n, flags, isStmt) {\n  var ex = n.ex;\n  ASSERT.call(this, ex.type === \'#Untransformed\' && ex.kind === \'temp\', \'t\');\n  this.eN(ex, EC_NONE, false).wm(\'.\',\'val\');\n};\n\n');
resolver.set('./src/Emitter/new-emit-CallExpression.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {EC_NEW_HEAD, EC_NONE, ETK_ID} from \'../other/constants.js\';\n\nEmitters[\'CallExpression\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n);\n  this.emc(cb, \'bef\');\n  var hasParen = flags & EC_NEW_HEAD;\n\n  var c = n.callee;\n  var e = c.type === \'Super\';\n  var l = e ? c[\'#ti\'] : null;\n\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n\n  if (l && l.ref.d) this.jz(\'o\').w(\'(\');\n  if (e)\n    this.wt(c[\'#liq\'].synthName, ETK_ID).wm(\'.\',\'call\');\n  else\n    this.emitCallHead(c, flags);\n\n  this.sl(n[\'#argloc\']);\n\n  this.w(\'(\');\n  if (e) {\n    this.eN(c[\'#this\'], EC_NONE, false );\n    n.arguments.length && this.wm(\',\',\'\');\n  }\n\n  this.emitCommaList(n.arguments);\n  this.emc(cb, \'inner\');\n  this.w(\')\');\n\n  if (l && l.ref.d)\n    this.wm(\',\',\'\',l.synthName,\'\',\'=\',\'\',\'1\').w(\')\');\n  hasParen && this.w(\')\');\n  this.emc(cb, \'aft\');\n  isStmt && this.w(\';\');\n};\n\n');
resolver.set('./src/Emitter/new-emit-AssignmentExpression.js', '  import {EC_EXPR_HEAD, EC_NONE, ASSERT, EC_IN} from \'../other/constants.js\';\n  import {isResolvedName, tg} from \'../other/util.js\';\n  import {Emitters} from \'../other/globals.js\';\n  import {wcb_afterVar} from \'../other/wcb.js\';\n  import {cls} from \'./cls.js\';\n\ncls.emitAssignment_ex =\nfunction(n, flags, isStmt) {\n  var hasParen = flags & EC_EXPR_HEAD;\n  var left = n.left;\n  var target = null, cb = n[\'#c\'];\n\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n\n  this.emc(cb, \'bef\');\n  this.emitSAT(left, flags, 0);\n  this.os();\n\n  if (n.operator === \'**=\') {\n    ASSERT.call(this, isResolvedName(n.left), \'not rn\');\n    this.w(\'=\').os().jz(\'ex\')\n        .w(\'(\').eN(n.left, EC_NONE, false)\n        .w(\',\').os().eN(n.right, flags & EC_IN, false)\n        .w(\')\');\n  }\n  else {\n    if (n.operator === \'+=\') this.sl(n[\'#o\']);\n    this.w(n.operator).os();\n    this.eN(n.right, flags & EC_IN, false);\n  }\n\n  this.emc(cb, \'aft\');\n  hasParen && this.w(\')\');\n  isStmt && this.w(\';\');\n  return true;\n};\n\nEmitters[\'AssignmentExpression\'] =\nfunction(n, flags, isStmt) {\n  return this.emitAssignment_ex(n, flags, isStmt);\n};\n\nEmitters[\'#SynthAssig\'] =\nfunction(n, flags, isStmt) {\n  if (n.binding && !tg(n.left).isVar())\n    return this.emitAssignment_binding(n, flags, isStmt);\n  return this.emitAssignment_ex(n, flags, isStmt);\n};\n\ncls.emitAssignment_binding =\nfunction(n, flags, isStmt) {\n  ASSERT.call(this, isResolvedName(n.left), \'name\');\n\n  var cb = n[\'#c\']; this.emc(cb, \'bef\');\n  tg(n.left).isLLINOSA() || this.w(\'var\').gu(wcb_afterVar).os();\n  this.emitRName_binding(n.left);\n  tg(n.left).isLLINOSA() && this.wm(\'.\',\'v\');\n  this.os().w(\'=\').os();\n  this.eN(n.right, EC_NONE, false);\n  this.w(\';\');\n  this.emc(\'aft\');\n  \n  var l = n.left;\n  tg(l).hasTZCheck && this.os().emitTZCheckPoint(tg(l));\n};\n\n\n');
resolver.set('./src/Emitter/new-emit-break.js', '  import {Emitters} from \'../other/globals.js\';\n\n// Emitters[\'ForOfStatement\'] =\nEmitters[\'ForInStatement\'] =\nEmitters[\'ForStatement\'] =\n// Emitters[\'TryStatement\'] =\n// Emitters[\'LabeledStatement\'] =\n// Emitters[\'ContinueStatement\'] =\n// Emitters[\'BreakStatement\'] =\nfunction(n, flags, isStmt) {\n  console.log(\'SKIPPING\', n.type, \'LEN\', n.end - n.start);\n};\n\n');
resolver.set('./src/Emitter/new-uemit-synth-arg.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {ASSERT_EQ, ETK_ID, ASSERT, EC_NONE} from \'../other/constants.js\';\n  import {CB, isResolvedName, isTemp} from \'../other/util.js\';\n\nUntransformedEmitters[\'arg-at\'] =\nfunction(n, flags, isStmt) {\n  ASSERT_EQ.call(this, isStmt, false);\n  this.wt(\'arguments\', ETK_ID).w(\'[\');\n  this.wm(n.idx+\"\",\']\');\n\n  return true;\n};\n\nUntransformedEmitters[\'arg-rest\'] =\nfunction(n, flags, isStmt) {\n  ASSERT_EQ.call(this, isStmt, true);\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  var l = n.left;\n  ASSERT.call(this, isResolvedName(l) || isTemp(l), \'neither id nor temp\');\n  this.eA(l, EC_NONE, false)\n    .wm(\'\',\'=\',\'\',\'[\',\']\',\';\').l()\n    .wm(\'while\',\'\',\'(\').eA(l, EC_NONE, false)\n    .wm(\'.\',\'length\')\n    .wm(\'+\',n.idx+\"\",\'\',\'<\',\'\',\'arguments\',\'.\',\'length\',\')\').i().l()\n    .eA(l, EC_NONE, false).w(\'[\').eA(l, EC_NONE, false).wm(\'.\',\'length\')\n    .w(\']\')\n    .wm(\'\',\'=\',\' \',\'arguments\',\'[\').\n    eA(l, EC_NONE, false).wm(\'.\',\'length\',\'+\',n.idx+\"\",\']\',\';\').u();\n  this.emc(cb, \'aft\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/emitter2-brevity.js', '  import {cls} from \'./cls.js\';\n\ncls.w =\nfunction(str) {\n  this.writeToCurrentLine_checked(str);\n  return this;\n};\n\ncls.i =\nfunction() { this.indentNextLine(); return this; };\n\ncls.l =\nfunction() { this.flushCurrentLine(); return this; };\n\ncls.jz =\nfunction(str) {\n  // TODO: helpers should be tracked in the transformer\n  this.jzHelpers.use(\'#\'+str)\n  var jzLiquid = this.jzLiquid;\n  return this.w(jzLiquid.synthName).w(\'.\').w(str);\n};\n\ncls.wm =\nfunction() {\n  var len = arguments.length, l = 0;\n  while (l < len) {\n    var str = arguments[l++];\n    switch (str) {\n    case \' \':\n      this.enqueueBreakingSpace();\n      break;\n    case \'\':\n      this.enqueueOmittableSpace();\n      break;\n    default:\n      this.writeToCurrentLine_checked(str);\n\n    }\n  }\n  return this;\n};\n\ncls.wt =\nfunction(str, t) { this.tt(t); return this.w(str); };\n\ncls.os =\nfunction() { this.enqueueOmittableSpace(); return this; };\n\ncls.bs =\nfunction() { this.enqueueBreakingSpace(); return this; };\n\ncls.u =\nfunction() { this.unindentNextLine(); return this; };\n\ncls.hs = \nfunction() { this.writeToCurrentLine_space(); return this; };\n\ncls.gu =\nfunction(guard) { this.insertGuard(guard); return this; };\n\ncls.gar =\nfunction(arg) { this.setGuardArg(arg); return this; };\n\ncls.gmon =\nfunction(listener) { this.monitorGuard(listener); return this; };\n\ncls.grmif =\nfunction(listener) { this.removeGuard_if(listener); return this; };\n\ncls.trygu =\nfunction(guard, listener) {\n  if (this.insertGuard_try(guard)) {\n    this.monitorGuard(listener);\n    return true;\n  }\n  return false;\n};\n\ncls.sl =\nfunction(srcLoc) {\n  this.setSourceLocTo(srcLoc);\n  return this;\n};\n\ncls.eA =\nfunction(n, flags, isStmt) {\n  this.emitAny(n, flags, isStmt);\n  return this;\n};\n\ncls.eH =\nfunction(n, flags, isStmt) {\n  this.emitHead(n, flags, isStmt);\n  return this;\n};\n\ncls.eN =\nfunction(n, flags, isStmt) {\n  this.emitNonSeq(n, flags, isStmt);\n  return this;\n};\n\n\n');
resolver.set('./src/Emitter/new-uemit-synth-temp.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {ETK_ID, EC_EXPR_HEAD, EC_IN} from \'../other/constants.js\';\n  import {CB} from \'../other/util.js\';\n\nUntransformedEmitters[\'temp\'] =\nfunction(n, flags, isStmt) {\n//this.wt(n.liq.name+n.liq.idx, ETK_ID );\n  this.wt(n.liq.synthName, ETK_ID);\n  return true;\n};\n\nUntransformedEmitters[\'temp-save\'] =\nfunction(n, flags, isStmt) {\n  var hasParen = flags & EC_EXPR_HEAD;\n  var cb = CB(n); this.emc(cb, \'bef\');\n  if (hasParen) { this.w(\'(\'); flags &= EC_IN; }\n  this.eA(n.left, flags, false).os().w(\'=\').os().eN(n.right, flags & EC_IN, false);\n  hasParen && this.w(\')\');\n  this.emc(cb, \'aft\');\n  isStmt && this.w(\';\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-uemit-synth-call.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {EC_NEW_HEAD, EC_NONE} from \'../other/constants.js\';\n  import {CB} from \'../other/util.js\';\n\nUntransformedEmitters[\'call\'] = \nfunction(n, flags, isStmt) {\n  var hasParen = flags & EC_NEW_HEAD;\n  var cb = CB(n); this.emc(cb, \'bef\');\n  if (hasParen) { this.w(\'(\'); } \n  if (n.mem !== null) {\n    this.jz(\'cm\');\n    this.sl(n[\'#argloc\']);\n    this.w(\'(\').eN(n.head, EC_NONE, false).w(\',\').os();\n    var m = n.mem;\n    m.type === \'Super\' ? this.w(m[\'#liq\'].synthName) : this.eN(m, EC_NONE, false) ;\n  }\n  else {\n    this.jz(\'c\');\n    this.sl(n[\'#argloc\']);\n    this.w(\'(\');\n    if (n.head.type === \'Super\') this.w(n.head[\'#liq\'].synthName);\n    else this.eN(n.head, EC_NONE, false);\n  }\n\n  this.w(\',\').os();\n  this.jz(\'arr\').w(\'(\').emitElems(n.list, true, cb);\n  this.w(\')\').w(\')\');\n  \n  hasParen && this.w(\')\');\n  isStmt && this.w(\';\');\n\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-emit-ConditionalExpression.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {EC_EXPR_HEAD, EC_NONE} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\nEmitters[\'ConditionalExpression\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n);\n  this.emc(cb, \'bef\' );\n  var hasParen = flags & EC_EXPR_HEAD;\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n  this.emitCondTest(n.test, flags);\n  this.wm(\'\',\'?\',\'\').eN(n.consequent, EC_NONE, false);\n  this.wm(\'\',\':\',\'\').eN(n.alternate, EC_NONE, false);\n  hasParen && this.w(\')\');\n  this.emc(cb, \'aft\');\n  isStmt && this.w(\';\');\n};\n\ncls.emitCondTest = function(n, prec, flags) {\n  var hasParen = false;\n  switch (n.type) {\n  case \'AssignmentExpression\':\n  case \'ConditionalExpression\':\n    hasParen = true;\n  }\n\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n  this.eN(n, false, flags);\n  if (hasParen) this.w(\')\');\n};\n\n\n');
resolver.set('./src/Emitter/new-uemit-synth-heritage.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {ASSERT_EQ, EC_NONE} from \'../other/constants.js\';\n\nUntransformedEmitters[\'heritage\'] =\nfunction(n, flags, isStmt) {\n  ASSERT_EQ.call(this, isStmt, false);\n  this.jz(\'h\').sl(n.heritage.loc.start);\n\n  this.w(\'(\').eN(n.heritage, EC_NONE, false).w(\')\');\n};\n\n');
resolver.set('./src/Emitter/new-uemit-synth-literal.js', '  import {UntransformedEmitters, Emitters} from \'../other/globals.js\';\n\nUntransformedEmitters[\'synth-literal\'] =\nEmitters[\'Literal\'];\n\n');
resolver.set('./src/Emitter/new-uemit-synth-arr-iter.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {EC_NONE} from \'../other/constants.js\';\n\nUntransformedEmitters[\'arr-iter-get\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  this.eA(n.iter, EC_NONE, false).wm(\'.\',\'get\');\n  this.wm(\'(\',\')\');\n  this.emc(cb, \'aft\'); // TODO: unnecessary\n  isStmt && this.w(\';\');\n  return true;\n};\n\nUntransformedEmitters[\'arr-iter-end\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n);\n  this.eA(n.iter, EC_NONE, false).wm(\'.\',\'end\');\n  this.wm(\'(\',\')\');\n  this.emc(cb, \'aft\');\n  isStmt && this.w(\';\');\n  return true;\n};\n\nUntransformedEmitters[\'arr-iter\'] =\nfunction(n, flags, isStmt) {\n  this.jz(\'arrIter\', EC_NONE, false).w(\'(\').eN(n.iter, EC_NONE, false).w(\')\');\n  return true;\n};\n\nUntransformedEmitters[\'arr-iter-get-rest\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n);\n  this.emc(cb, \'bef\' );\n  this.eA(n.iter, EC_NONE, false).wm(\'.\',\'rest\').wm(\'(\',\')\').emc(cb, \'aft\');\n\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-uemit-bundler.js', 'import {ASSERT} from   \'../other/constants.js\';\nimport {Emitters} from \'../other/globals.js\';\nimport {wcb_afterStmt} from \'../other/wcb.js\';\n\nimport {cls} from \'./cls.js\';\nEmitters[\'#Bundler\'] =\nfunction(n, flags, isStmt) {\n  var w = this.allow.jzWrapper /* && this.jzHelpers.active.length() > 0 */;\n\n  if (this.jzLiquid === null) {\n    var lg = n.bundleScope.getLG(\'jz\');\n    if (lg)\n      this.jzLiquid = lg.getL(0);\n    if (w)\n      w = !!this.jzLiquid;\n  }\n\n  if (w) {\n    this.wm(\'(\',\'function\',\'(\', this.jzLiquid.synthName,\')\',\'{\').l();\n    this.allow.jzWrapper = false;\n  }\n\n  this.emitBundleItem(n.rootNode);\n\n  if (w) {\n    this.l().wm(\'}\',\'(\').writeJZHelpers();\n    this.wm(\')\',\')\',\';\');\n  }\n};\n\ncls.emitRenamed =\nfunction(scope, total) {\n  var list = scope.renamedHoisted, l = 0;\n  while (l < list.length) {\n    var item = list[l];\n    switch (item.type) {\n    case \'#ExportDefaultDeclaration\':\n      ASSERT.call(this, item[\'#emitted\'] === false, \'emitted\');\n      this.emitStmt(item);\n      this.l();\n      break;\n    case \'#Untransformed\':\n      ASSERT.call(this, item.kind === \'transformed-fn\', \'hoisted [\'+item.kind+\']\');\n      if (!item.emitted) {\n        this.emitSingleFun(item, true, 0, total>0);\n        item.emitted = true;\n      }\n      break;\n    default:\n      ASSERT.call(this, \'rename hoisted is unknown: \'+n.type);\n    }\n    ++l; \n  }\n\n  scope.renamedHoisted = null;\n  return l;\n};\n \ncls.emitBundleItem =\nfunction(n) {\n  var list = n[\'#scope\'].allImportedScopes, len = list.length(), l = 0;\n  var total = 0;\n  while (l < len) {\n    var scope = list.at(l++);\n    if (scope.renamedHoisted) {\n      total += this.emitRenamed(scope, total);\n      scope.renamedHoisted = null;\n    }\n  }\n\n  list = n[\'#imports\'], len = list === null ? 0 : list.length, l = 0;\n  var lsn = null;\n  var own = {used: false};\n\n  while (l < len) {\n    var im = list[l++];\n    lsn = this.listenForEmits(own);\n    this.emitBundleItem(im);\n    if (lsn.used) {\n      own.used = false;\n      this.trygu(wcb_afterStmt, own);\n    }\n  }\n\n  var nc = this.smSetSrc_str(n[\'#scope\'][\'#uri\']);\n\n  this.emitStmt(n);\n  this.smSetSrc_i(nc);\n\n  own.used || this.grmif(own);\n};\n');
resolver.set('./src/Emitter/new-uemit-export.js', 'import {Emitters} from \'../other/globals.js\';\nimport {EC_START_STMT, ETK_ID, EC_NONE} from \'../other/constants.js\';\n\n/*  TODO: Raw, for alternative bundlers */Emitters[\'#ExportNamedDeclaration\'] = \nfunction(n, isVal) {\n  if (n.declaration)\n    return this.emitAny(n.declaration, EC_START_STMT, true);\n};\n\n/*  TODO: Raw, for alternative bundlers */Emitters[\'#ExportDefaultDeclaration\'] =\nfunction(n, isVal) {\n  if (n[\'#emitted\'])\n    return;\n  var b = n[\'#binding\'];\n  var elem = n.declaration;\n  if (b !== null) { // if it has to have a binding, then it\'s either an expression or a nameless fn or cls\n    this.wt(\'var\',ETK_ID).bs();\n    this.w(b.synthName).os().w(\'=\').os();\n    this.eN(elem, EC_NONE, false).w(\';\');\n  }\n  else \n    this.eA(elem, EC_START_STMT, true);\n  n[\'#emitted\'] = true;\n};\n\n/*  TODO: Raw, for alternative bundlers */Emitters[\'#ImportDeclaration\'] =\nfunction(n, isVal) {};\n\n');
resolver.set('./src/Emitter/new-uemit-synth-assig-list.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {EC_ATTACHED, EC_EXPR_HEAD, EC_NON_SEQ, EC_IN} from \'../other/constants.js\';\n  import {wcb_afterStmt} from \'../other/wcb.js\';\n\nUntransformedEmitters[\'assig-list\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n);\n  var attached = flags & EC_ATTACHED;\n  attached && this.w(\'{\').i().gu(wcb_afterStmt);\n\n  if (isStmt) {\n    this.emc(cb, \'bef\');\n    this.emitStmtList(n.list);\n    this.emc(cb, \'inner\');\n    this.emc(cb, \'left.aft\');\n    this.emc(cb, \'aft\');\n  }\n  else {\n    var hasParen = flags & (EC_EXPR_HEAD|EC_NON_SEQ);\n    if (hasParen) { this.w(\'(\'); flags &= EC_IN; }\n    this.emc(cb, \'bef\');\n    this.emitCommaList(n.list, flags);\n    this.emc(cb, \'inner\');\n    this.emc(cb, \'left.aft\');\n    this.emc(cb, \'aft\');\n    hasParen && this.w(\')\');\n  }\n\n  attached && this.u().l().w(\'}\');\n};\n\n');
resolver.set('./src/Emitter/new-emit-EmptyStatement.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {ASSERT_EQ} from \'../other/constants.js\';\n\nEmitters[\'EmptyStatement\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n);\n  this.emc(cb, \'bef\' );\n  ASSERT_EQ.call(this, isStmt, true);\n  this.w(\';\');\n  this.emc(cb, \'aft\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-emit-BinaryExpression.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB, cmn_erase} from \'../other/util.js\';\n  import {EC_EXPR_HEAD, EC_NONE, ETK_ID, EC_NEW_HEAD} from \'../other/constants.js\';\n  import {wcb_DIV_b, wcb_ADD_b, wcb_MIN_b, wcb_idNumGuard} from \'../other/wcb.js\';\n  import {bp, isLA, isRA} from \'../other/lexer-constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.emitBLE =\nEmitters[\'LogicalExpression\'] =\nEmitters[\'BinaryExpression\'] =\nfunction(n, flags, isStmt) {\n\n  var cb = CB(n);\n  this.emc(cb, \'bef\' );\n\n  var hasParen = flags & EC_EXPR_HEAD;\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n  var o = n.operator;\n  if (o === \'**\')\n    return this.emitPow(n, flags, isStmt);\n\n  var left = n.left, right = n.right;\n  if (isBLE(left))\n    this.emitLeft(left, o, flags);\n  else\n    this.emitBLEP(left, flags);\n\n  o === \'+\' && this.sl(n[\'#o\']);\n\n  switch (o) {\n  case \'/\':\n    this.os().w(o).gu(wcb_DIV_b);\n    break;\n  case \'+\':\n    this.os().w(o).gu(wcb_ADD_b);\n    break;\n  case \'-\':\n    this.os().w(o).gu(wcb_MIN_b);\n    break;\n  case \'in\':\n  case \'instanceof\':\n    this.bs(); // TODO: if writeToCurrentLine_checked keeps tt intact, we could know what the latest written token has been which helps us decide whether a bs is really necessary\n    this.wt(o,ETK_ID).gu(wcb_idNumGuard);\n    break;\n  default:\n    this.wm(\'\',o).os();\n    break;\n  }\n\n  if (isBLE(right))\n    this.emitRight(right, o, EC_NONE);\n  else\n    this.emitBLEP(right, EC_NONE);\n\n  hasParen && this.w(\')\');\n\n  this.emc(cb, \'aft\');\n\n  isStmt && this.w(\';\');\n  return true; // something was actually emitted\n};\n\ncls.emitRight = \nfunction(n, o, flags) {\n  var hasParen = false;\n  var rp = bp(n.operator), lp = bp(o);\n\n  if (lp>rp)\n    hasParen = true;\n  else if (lp === rp)\n    hasParen = isLA(rp);\n\n  var cb = CB(n);\n  this.emcim(cmn_erase(cb, \'bef\'));\n  var aft = cmn_erase(cb, \'aft\');\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n  this.emitBLE(n, flags, false);\n  hasParen && this.w(\')\');\n  this.emcim(aft );\n};\n\ncls.emitLeft =\nfunction(n, o, flags) {\n  var hasParen = false;\n  var rp = bp(o), lp = bp(n.operator);\n\n  if (lp<rp)\n    hasParen = true;\n  else if (lp === rp)\n    hasParen = isRA(lp) ;\n\n  var cb = CB(n);\n  this.emcim(cmn_erase(cb, \'bef\'));\n  var aft = cmn_erase(cb, \'aft\');\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n  this.emitBLE(n, flags, false);\n  hasParen && this.w(\')\');\n  this.emcim(aft );\n};\n\ncls.emitBLEP =\nfunction(n, flags) {\n  switch (n.type) {\n  case \'UnaryExpression\': // it has a higher pr than any other op\n  case \'UpdateExpression\':\n    return this.emitAny(n, flags, false);\n  }\n  return this.emitHead(n, flags, false);\n};\n\ncls.emitPow =\nfunction(n, flags, isStmt) {\n  var hasParen = flags & EC_NEW_HEAD;\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n  this.jz(\'ex\').w(\'(\').eN(n.left, EC_NONE, false).w(\',\').os().eN(n.right, EC_NONE, false).w(\')\');\n  hasParen && this.w(\')\');\n\n  this.emc(CB(n), \'aft\');\n  isStmt && this.w(\';\');\n  return true;\n};\n\nfunction isBLE(n) {\n  switch (n.type) {\n  case \'BinaryExpression\':\n  case \'LogicalExpression\':\n    return true;\n  default:\n    return false;\n  }\n}\n\n\n');
resolver.set('./src/Emitter/new-emit-Untransformed.js', '  import {Emitters, UntransformedEmitters} from \'../other/globals.js\';\n\nEmitters[\'#Untransformed\'] = \nfunction(n, flags, isStmt) {\n  return UntransformedEmitters[n.kind].call(this, n, flags, isStmt);\n};\n\n');
resolver.set('./src/Emitter/new-emit-ThrowStatement.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {ETK_ID, EC_NONE} from \'../other/constants.js\';\n  import {wcb_afterRet} from \'../other/wcb.js\';\n\nEmitters[\'ThrowStatement\'] =\nfunction(n, flags, isStmt) {\n  var r = {hasParen: false}, cb = CB(n);\n  this.emc(cb, \'bef\');\n\n  this.sl(n.loc.start);\n  this.wt(\'throw\',ETK_ID).gu(wcb_afterRet).gar(r);\n  this.eA(n.argument, EC_NONE, false);\n  if (r.hasParen) this.w(\')\');\n  this.w(\';\').emc(cb, \'aft\');\n};\n\n');
resolver.set('./src/Emitter/new-emit-NewExpression.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB, findElem} from \'../other/util.js\';\n  import {ETK_ID, EC_NEW_HEAD, EC_NONE} from \'../other/constants.js\';\n  import {wcb_afterNew} from \'../other/wcb.js\';\n\nEmitters[\'NewExpression\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  var si = findElem(n.arguments, \'SpreadElement\');\n  if (si === -1) {\n    this.wt(\'new\', ETK_ID).gu(wcb_afterNew).os().emitNewHead(n.callee);\n    this.w(\'(\').emitCommaList(n.arguments);\n    this.emc(cb, \'inner\');\n    this.w(\')\');\n  } else {\n    var hasParen = flags & EC_NEW_HEAD;\n    if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n    this.jz(\'n\').w(\'(\').eN(n.callee, EC_NONE, false).wm(\',\',\'\')\n      .jz(\'arr\').w(\'(\').emitElems(n.arguments, si >= 0, cb);\n\n    this.emc(cb, \'inner\');\n    this.w(\')\').w(\')\');\n    hasParen && this.w(\')\');\n  }\n\n  this.emc(cb, \'aft\');\n  isStmt && this.w(\';\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-emit-whole-prog.js', '  import {Emitters} from \'../other/globals.js\';\n  import {wcb_afterStmt} from \'../other/wcb.js\';\n  import {CB} from \'../other/util.js\';\n\nEmitters[\'Program\'] =\nfunction(n, flags, isStmt) {\n  var main = n[\'#scope\'],\n      w = this.allow.jzWrapper /* && this.jzHelpers.active.length() > 0 */;\n  \n  if (this.jzLiquid === null) {\n    var lg = main.getLG(\'jz\');\n    if (lg)\n      this.jzLiquid = lg.getL(0);\n    if (w)\n      w = !!this.jzLiquid;\n  }\n\n  if (w && this.jzLiquid) {\n    this.wm(\'(\',\'function\',\'(\',this.jzLiquid.synthName,\')\',\'{\').l();\n    this.allow.jzWrapper = false;\n  }\n\n  var lsn = null, own = {used: false};\n  lsn = this.listenForEmits(own);\n  this.emitSourceHead(n);\n  if (lsn.used) { own.used = false; this.trygu(wcb_afterStmt, own); }\n\n  this.emitStmtList(n.body);\n  this.emc(CB(n), \'inner\');\n\n  own.used || this.grmif(own);\n\n  if (w) {\n    this.l().wm(\'}\',\'(\').writeJZHelpers();\n    this.wm(\')\',\')\',\';\');\n  }\n};\n');
resolver.set('./src/Emitter/new-uemit-synth-cls.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {ASSERT, EC_NONE, ASSERT_EQ} from \'../other/constants.js\';\n\nUntransformedEmitters[\'cls\'] =\nfunction(n, flags, isStmt) {\n  this.jz(\'cls\').w(\'(\');\n  if (n.cls) {\n    ASSERT.call(this, n.target === null, \'cls\' ); \n    this.eN(n.cls, EC_NONE, false);     \n  }\n  else this.w(n.target.synthName);\n  n.heritage && this.w(\',\').os().eN(n.heritage);\n  this.w(\')\');\n  isStmt && this.w(\';\');\n};\n\nUntransformedEmitters[\'cls-assig\'] =\nfunction(n, flags, isStmt) {\n  ASSERT_EQ.call(this, isStmt, true);\n  var ll = n.target.isLLINOSA();\n  ll || this.w(\'var\').bs();\n  this.w(n.target.synthName);\n  ll && this.wm(\'.\',\'v\');\n  this.wm(\'\',\'=\',\'\').eN(n.ctor, EC_NONE, false);\n  this.w(\';\');\n};\n\n');
resolver.set('./src/Emitter/new-emit-ExpressionStatement.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {ASSERT_EQ, ASSERT, EC_START_STMT} from \'../other/constants.js\';\n\nEmitters[\'ExpressionStatement\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n);\n  this.emc(cb, \'bef\' );\n  ASSERT_EQ.call(this, isStmt, true);\n  ASSERT.call(this, flags & EC_START_STMT, \'must be in stmt context\');\n  this.emitAny(n.expression, flags, true );\n  this.emc(cb, \'aft\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/emitter2-base.js', '  import {EC_EXPR_HEAD, EC_NON_SEQ, EC_NEW_HEAD, EC_CALL_HEAD} from \'../other/constants.js\';\n  import {_u} from \'../other/scope-util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.emitAny =\nfunction(n, flags, isStmt) {\n  var emitters = this.emitters, t = n.type;\n  if (t in emitters)\n    return emitters[t].call(this, n, flags, isStmt );\n\n  this.err(\'unknown.node\');\n};\n\ncls.emitHead =\nfunction(n, flags, isStmt) { return this.emitAny(n, flags|EC_EXPR_HEAD|EC_NON_SEQ, isStmt); };\n\ncls.emitNonSeq =\nfunction(n, flags, isStmt) { return this.emitAny(n, flags|EC_NON_SEQ, isStmt); };\n\ncls.emitNewHead =\nfunction(n, flags, isStmt) {\n  return this.emitHead(n, EC_NEW_HEAD, false);\n};\n\ncls.emitCallHead =\nfunction(n, flags, isStmt) {\n  return this.emitHead(n, flags|EC_CALL_HEAD, false);\n};\n\ncls.start =\nfunction() {\n  this.writeToSMout(\'{\"version\":3,\"mappings\":\"\');\n  this.startFreshLine();\n};\n\ncls.flushAll =\nfunction() {\n  this.flushCurrentLine();\n\n  this.writeToSMout(\'\",\"names\":[\');\n  var list = this.smNameList, l = 0, len = list.length();\n  while (l < len) {\n    if (l) this.writeToSMout(\',\');\n    var str = _u(list.keys[l++]);\n    this.writeToSMout(\'\"\'+str+\'\"\');\n  }\n\n  this.writeToSMout(\'],\"sources\":[\');\n  list = this.smSrcList, l = 0, len = list.length();\n  while (l < len) {\n    if (l) this.writeToSMout(\',\');\n    var str = _u(list.keys[l++]);\n    this.writeToSMout(\'\"\'+str+\'\"\');\n  }\n\n  this.writeToSMout(\']}\');\n};\n');
resolver.set('./src/Emitter/whole.js', '  import \'./new-emit-TryStatement.js\';\n  import \'./new-uemit-synth-u.js\';\n  import \'./new-emit-UpdateExpression.js\';\n  import \'./new-uemit-synth-tval.js\';\n  import \'./new-emit-CallExpression.js\';\n  import \'./new-emit-AssignmentExpression.js\';\n  import \'./new-emit-break.js\';\n  import \'./new-uemit-synth-arg.js\';\n  import \'./emitter2-brevity.js\';\n  import \'./new-uemit-synth-temp.js\';\n  import \'./new-uemit-synth-call.js\';\n  import \'./new-emit-ConditionalExpression.js\';\n  import \'./new-uemit-synth-heritage.js\';\n  import \'./new-uemit-synth-literal.js\';\n  import \'./new-uemit-synth-arr-iter.js\';\n  import \'./new-uemit-bundler.js\';\n  import \'./new-uemit-export.js\';\n  import \'./new-uemit-synth-assig-list.js\';\n  import \'./new-emit-EmptyStatement.js\';\n  import \'./new-emit-BinaryExpression.js\';\n  import \'./new-emit-Untransformed.js\';\n  import \'./new-emit-ThrowStatement.js\';\n  import \'./new-emit-NewExpression.js\';\n  import \'./new-emit-whole-prog.js\';\n  import \'./new-uemit-synth-cls.js\';\n  import \'./new-emit-ExpressionStatement.js\';\n  import \'./emitter2-base.js\';\n  import \'./emitter2-util.js\';\n  import \'./new-uemit-synth-skip.js\';\n  import \'./new-uemit-synth-sname.js\';\n  import \'./new-emit-fn.js\';\n  import \'./emitter2-write.js\';\n  import \'./new-emit-IfStatement.js\';\n  import \'./emitter2-tt.js\';\n  import \'./emitter2-guard.js\';\n  import \'./new-emit-ObjectExpression.js\';\n  import \'./emitter2-wrap.js\';\n  import \'./new-uemit-synth-ucond.js\';\n  import \'./emitter2-out.js\';\n  import \'./new-uemit-for-in-stmt.js\';\n  import \'./new-uemit-for-of-stmt.js\';\n  import \'./new-uemit-synth-tc.js\';\n  import \'./newer.js\';\n  import \'./emitter2-line.js\';\n  import \'./new-emit-TemplateLiteral.js\';\n  import \'./new-uemit-synth-resolved-name.js\';\n  import \'./head.js\';\n  import \'./new-emit-BreakStatement.js\';\n  import \'./new-uemit-synth-obj-iter.js\';\n  import \'./emitter2-sm.js\';\n  import \'./emitter2-indent.js\';\n  import \'./new-emit-MemberExpression.js\';\n  import \'./new-uemit-synth-global-update.js\';\n  import \'./new-emit-UnaryExpression.js\';\n  import \'./new-uemit-synth-mem-list.js\';\n  import \'./emc.js\';\n  import \'./emitter2-space.js\';\n  import \'./new-uemit-synth-resolved-this.js\';\n  import \'./new-emit-ContinueStatement.js\';\n  import \'./new-emit-SequenceExpression.js\';\n  import \'./new-uemit-synth-llinosa-names.js\';\n  import \'./new-emit-ReturnStatement.js\';\n  import \'./new-emit-WhileStatement.js\';\n  import \'./new-uemit-synth-cls.js\';\n  import \'./new-uemit-synth-transformed-fn.js\';\n  import \'./new-emit2-Literal.js\';\n  import \'./new-emit-LabeledStatement.js\';\n  import \'./new-emit-SwitchStatement.js\';\n  import \'./new-uemit-synth-tzchk.js\';\n  import \'./new-emit-BlockStatement.js\';\n  import \'./new-emit-while-do.js\';\n  import \'./new-emit-ArrayExpression.js\';\n  import \'./new-emit-TaggedTemplateExpression.js\';\n  import \'./new-uemit-synth-rcheck.js\';\n  import \'./emit-jzhelpers.js\';\n  import \'./new-uemit-for-stmt.js\';\n');
resolver.set('./src/Emitter/emitter2-util.js', '  import {CH_BACK_SLASH, CH_SINGLE_QUOTE, CH_MULTI_QUOTE, CH_COMPLEMENT, CH_WHITESPACE, CH_VTAB, CH_BACK, CH_FORM_FEED, CH_TAB, CH_CARRIAGE_RETURN, CH_LINE_FEED, ASSERT, ETK_STR, EC_IN, EC_START_STMT, ASSERT_EQ, EC_ATTACHED, EC_NONE, ETK_ID} from \'../other/constants.js\';\n  import {hex2, hex, isAssigList, CB, isResolvedName} from \'../other/util.js\';\n  import {wcb_afterStmt} from \'../other/wcb.js\';\n  import {cls} from \'./cls.js\';\n\ncls.writeStringValue =\nfunction(sv, ql) {\n  var ch = -1, len = sv.length, c = 0, v = \"\";\n  while (c < len) {\n    ch = sv.charCodeAt(c);\n    v = this.isNormalCh(ch) ?\n      sv.charAt(c) :\n      this.stringEscapeFor(ch);\n\n    var vLen = v.length;\n    if (vLen === c+ql)\n      vLen += ql;\n\n    if (this.ol(vLen) > 0) {\n      this.writeToCurrentLine_raw(\'\\\\\');\n      this.nextLineHasLineBreakBefore = true;\n      this.finishCurrentLine();\n      this.curLineIndent = 0;\n    }\n\n    this.writeToCurrentLine_raw(v);\n    c++;\n  }\n};\n\ncls.isNormalCh =\nfunction(ch) {\n  switch (ch) {\n  case CH_BACK_SLASH:\n  case CH_SINGLE_QUOTE:\n  case CH_MULTI_QUOTE:\n    return false;\n  }\n\n  return ch <= CH_COMPLEMENT && ch >= CH_WHITESPACE;\n};\n\ncls.stringEscapeFor =\nfunction(ch) {\n  switch (ch) {\n  case CH_BACK_SLASH: return \'\\\\\\\\\';\n  case CH_SINGLE_QUOTE: return \'\\\\\\\'\';\n  case CH_MULTI_QUOTE: return \'\\\\\\\"\';\n  case CH_VTAB: return \'\\\\v\';\n  case CH_BACK: return \'\\\\b\';\n  case CH_FORM_FEED: return \'\\\\f\';\n  case CH_TAB: return \'\\\\t\';\n  case CH_CARRIAGE_RETURN: return \'\\\\r\';\n  case CH_LINE_FEED: return \'\\\\n\';\n  default:\n    if (ch<=0xFF)\n      return \'\\\\x\'+hex2(ch);\n\n    ASSERT.call(this, ch <= 0xFFFF, \'ch not a 16bit\');\n    return \'\\\\u\'+hex(ch);\n  }\n};\n\ncls.writeString =\nfunction(sv, quotation) {\n  this.tt(ETK_STR);\n  this.writeToCurrentLine_checked(quotation); // must take care of wrapping for the quotation\n  this.writeStringValue(sv, quotation.length);\n\n  // raw because the wrapping has been taken care of when in the writeStringValue routine\n  this.writeToCurrentLine_raw(quotation); \n};\n\ncls.emitCommaList =\nfunction(list, flags) {\n  var e = 0;\n  while (e < list.length) {\n    if (e) this.wm(\',\',\'\');\n    this.eN(list[e], flags, false);\n    if (e === 0) flags &= EC_IN;\n    e++;\n  }\n};\n\ncls.emitStmtList =\nfunction(list) {\n  var own = {used: false};\n\n  var lsn = this.listenForEmits(own), l = 0;\n  while (l < list.length) {\n    this.emitStmt(list[l++]);\n    if (lsn.used) {\n      own.used = false;\n      this.trygu(wcb_afterStmt, own);\n      lsn = this.listenForEmits(own);\n    }\n  }\n\n  own.used || this.grmif(own);\n};\n\ncls.emitStmt =\nfunction(stmt) { return this.emitAny(stmt, EC_START_STMT, true); };\n\ncls.emitTZCheckPoint =\nfunction(l) {\n  ASSERT_EQ.call(this, l.hasTZCheck, true);\n  var tz = l.ref.scope.scs.getLG(\'tz\').getL(0);\n  this.wm(tz.synthName,\'\',\'=\',\'\',l.idx+\"\",\';\');\n};\n\ncls.wsndl =\nfunction(list) {\n  var e = 0;\n  while (e < list.length) {\n    e && this.wm(\',\',\'\');\n    this.writeIDName(list[e].synthName);\n    ++e ;\n  }\n  return true;\n};\n\ncls.emitAttached =\nfunction(stmt) {\n  switch (stmt.type) {\n  case \'BlockStatement\':\n    this.os();\n  case \'EmptyStatement\':\n    return this.emitStmt(stmt);\n  }\n\n  // TODO: eliminate\n  if (stmt.type === \'ExpressionStatement\') {\n    var ex = stmt.expression;\n    if (isAssigList(ex))\n      return this.os().emitAny(ex, EC_START_STMT|EC_ATTACHED, true);\n  }\n  else if (isAssigList(stmt))\n    return this.os().emitAny(stmt, EC_START_STMT|EC_ATTACHED, true);\n\n  this.i();\n  this.l(); // TODO: unnecessary when the body has nothing in it (like as in #Skip nodes)\n\n  var own = {used: false};\n  var lsn = this.listenForEmits(own);\n  this.emitStmt(stmt);\n  this.u();\n  if (!lsn.used) { this.grmif(own); this.w(\';\'); }\n};\n\n// a, b, e, ...l -> [a,b,e],sp(l)\n// a, b, e, l -> a,b,e,l\ncls.emitElems =\nfunction(list, selem /* i.e., it contains a spread element */, cb) {\n  var e = 0, em = 0;\n  while (e < list.length) {\n    em && this.w(\',\').os();\n    var elem = list[e];\n    if (elem && elem.type === \'SpreadElement\') {\n      this.emitSpread(elem);\n      e >= list.length - 1 && this.emc(cb, \'inner\');\n      e++;\n    }\n    else {\n      var br = selem || em;\n      br && this.w(\'[\');\n      e = this.emitElems_toRest(list, e, cb);\n      e >= list.length && this.emc(cb, \'inner\');\n      br && this.w(\']\');\n    }\n    ++em;\n  }\n};\n\ncls.emitSpread =\nfunction(n) {\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  this.jz(\'sp\').sl(n.loc.start);\n  this.w(\'(\').eN(n.argument, EC_NONE, false).w(\')\').emc(cb, \'aft\');\n};\n\ncls.emitElems_toRest =\nfunction(list, s, cb) {\n  var e = s;\n  while (e < list.length) {\n    var elem = list[e];\n    if (elem && elem.type === \'SpreadElement\')\n        break;\n    e > s && this.w(\',\').os();\n    if (elem)\n      this.eN(elem, EC_NONE, false);\n    else {\n      if (cb.h < cb.holes.length) {\n        var holeComments = cb.holes[cb.h];\n        if (holeComments[0] === e)\n          this.emcim(holeComments[1]);\n        cb.h++;\n      }\n          \n      this.w(\'void\').bs().w(\'0\');\n    }\n    ++e; \n  }\n  return e;\n};\n\ncls.writeMemName =\nfunction(memName, asStr) {\n  switch (memName.type) {\n  case \'Literal\':\n    this.eA(memName, EC_NONE, false);\n    return this;\n  case \'Identifier\':\n  case \'#-ResolvedName.ex\':\n  case \'#-ResolvedName.sat\':\n  case \'#-ResolvedName.binding\':\n    var cb = CB(memName); this.emc(cb, \'bef\' );\n    asStr ?\n      this.writeString(memName.name,\"\'\") :\n      this.writeIDName(memName.name);\n    this.emc(cb, \'aft\');\n    return this;\n  }\n  ASSERT.call(this, false, \'unknown name\');\n};\n\ncls.writeIDName =\nfunction(nameStr) { return this.writeToCurrentLine_checked(nameStr); };\n\ncls.emitSAT =\nfunction(n, flags, olen) {\n  if (n.type === \'MemberExpression\')\n    return this.emitSAT_mem(n, flags, olen);\n  if (isResolvedName(n))\n    return this.emitRName_SAT(n, flags);\n\n  ASSERT.call(this, false, \'got <\'+n.type+\'>\');\n};\n\ncls.emitAccessChk_tz =\nfunction(nd, loc) {\n  ASSERT.call(this, nd.hasTZCheck, \'unnecessary tz\');\n  var scope = nd.ref.scope;\n  ASSERT.call(this, scope.hasTZCheckPoint, \'could not find any tz\');\n  var tz = scope.scs.getLG(\'tz\').getL(0);\n  this.wt(tz.synthName,ETK_ID).wm(\'<\',nd.idx+\"\",\'&&\').jz(\'tz\');\n  loc && this.sl(loc);\n  this.w(\'(\').writeString(nd.name, \"\'\");\n  this.w(\')\');\n  return true;\n};\n\ncls.emitAccessChk_invalidSAT =\nfunction(nd, loc) {\n  this.jz(\'cv\');\n  loc && this.sl(loc);\n  this.w(\'(\').writeString(nd.name,\"\'\");\n  this.w(\')\');\n  return true;\n};\n\n\n');
resolver.set('./src/Emitter/new-uemit-synth-skip.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n\nUntransformedEmitters[\'skip\'] =\nfunction(n, flags, isStmt) { return false; };\n\n');
resolver.set('./src/Emitter/new-uemit-synth-sname.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {ETK_ID} from \'../other/constants.js\';\n\nUntransformedEmitters[\'synth-name\'] =\nfunction(n, flags, isStmt) {\n  this.wt(n.liq.synthName, ETK_ID );\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-emit-fn.js', '  import {EC_START_STMT, EC_NEW_HEAD, EC_NONE, ETK_ID} from \'../other/constants.js\';\n  import {wcb_afterVar, wcb_afterRet} from \'../other/wcb.js\';\n  import {cls} from \'./cls.js\';\n\ncls.emitExprFn =\nfunction(n, flags, isStmt) {\n  var hasParen = flags & EC_START_STMT;\n  var raw = n.fun;\n  var scope = raw[\'#scope\'];\n  var scopeName = scope.scopeName;\n  var lonll = scope.getNonLocalLoopLexicals();\n  var isRenamed = scopeName && scopeName.name !== scopeName.synthName;\n  var hasWrapper = n.cls || n.scall || lonll || isRenamed;\n  var em = 0;\n  if (hasWrapper) {\n    if (!hasParen)\n      hasParen = flags & EC_NEW_HEAD;\n  }\n\n  var l = {hasParen: false };\n\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n  if (hasWrapper) {\n    this.wt(\'function\', ETK_ID).w(\'(\');\n    if (n.scall) { this.w(n.scall.inner.synthName); em++; }\n    if (n.cls) { em && this.w(\',\').os(); this.w(n.cls.inner.synthName); em++; }\n    if (lonll) { em && this.w(\',\').os(); this.wsndl(lonll); }\n    this.w(\')\').os().w(\'{\').i().l();\n    if (isRenamed)\n      this.w(\'var\').gu(wcb_afterVar).wt(scopeName.synthName, ETK_ID).wm(\'\',\'=\',\'\');\n    else\n      this.w(\'return\').gu(wcb_afterRet).gar(l);\n  }\n  this.emitTransformedFn(n);\n  if (l.hasParen) this.w(\')\');\n  if (hasWrapper) {\n    this.w(\';\');\n    if (isRenamed) {\n      this.l().w(\'return\').gu(wcb_afterRet).gar(l).wt(scopeName.synthName, ETK_ID);\n      if (l.hasParen) this.w(\')\');\n      this.w(\';\');\n    }\n    this.u().l().wm(\'}\',\'(\');\n    em = 0;\n    if (n.scall) { this.eN(n.scall.outer, EC_NONE, false); em++; }\n    if (n.cls) { em && this.w(\',\').os(); this.eN(n.cls.outer, EC_NONE, false); em++; }\n    if (lonll) { em && this.w(\',\').os(); this.wsndl(lonll); }\n    this.w(\')\');\n  }\n  hasParen && this.w(\')\');\n  isStmt && this.w(\';\');\n};\n\n\n');
resolver.set('./src/Emitter/emitter2-write.js', '  import {ASSERT, STRING_TYPE, ETK_NONE, ETK_NL} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.writeToCurrentLine_checked =\nfunction(rawStr) {\n  ASSERT.call(this, arguments.length === 1, \'write must have only one single argument\');\n\n  ASSERT.call(this, typeof rawStr === STRING_TYPE, \'str\' );\n  ASSERT.call(this, rawStr.length, \'writing \"\"\' );\n\n  var srcLoc = this.pendingSrcLoc;\n  if (srcLoc) { this.pendingSrcLoc = null; }\n\n  if (this.hasPendingSpace())\n    this.effectPendingSpace(rawStr.length);\n\n  var curEmCol = this.emcol_cur;\n  if (curEmCol && this.ol(rawStr.length) > 0)\n    this.wrapCurrentLine();\n\n  if (this.guard) {\n    var tt = this.ttype;\n    tt === ETK_NONE || this.nott();\n    this.runGuard(rawStr, tt);\n    if (this.hasPendingSpace())\n      this.effectPendingSpace(rawStr.length);\n  }\n  else \n    this.ttype === ETK_NONE || this.nott();\n\n  ASSERT.call(this, this.guard === null, \'guard\' );\n  this.ensureNoSpace();\n\n  srcLoc && this.refreshTheCurrentLineLevelSourceMapWith(srcLoc);\n\n  this.writeToCurrentLine_raw(rawStr);\n};\n\ncls.writeToCurrentLine_raw =\nfunction(rawStr) {\n  this.emcol_cur += rawStr.length;\n  this.curLine += rawStr;\n};\n\ncls.writeToCurrentLine_space =\nfunction() {\n  this.ensureNoSpace();\n  if (this.guard) this.runGuard(\' \', ETK_NONE);\n\n  ASSERT.call(this, this.guard === null, \'no\');\n  this.ensureNoSpace();\n\n  this.writeToCurrentLine_raw(\' \');\n};\n\ncls.writeToCurrentLine_virtualLineBreak =\nfunction() {\n  this.ensureNoSpace();\n  this.guard && this.runGuard(\'\\n\', ETK_NL);\n};\n\n\n');
resolver.set('./src/Emitter/new-uemit-for-stmt.js', '  import {Emitters} from \'../other/globals.js\';\n  import {EC_NONE, EC_IN} from \'../other/constants.js\';\n\n  Emitters[\'#ForStatement\'] =\n  function(n, flags, isStmt) {\n    this.w(\'for\').os().w(\'(\');\n    n.init && this.emitAny(n.init, EC_IN, false);\n    this.w(\';\');\n    n.test && this.os().emitAny(n.test, EC_NONE, false);\n    this.w(\';\');\n    n.update && this.os().emitAny(n.update, EC_NONE, false);\n    this.w(\')\').emitAttached(n.body);\n  };\n');
resolver.set('./src/Emitter/new-emit-IfStatement.js', '  import {Emitters} from \'../other/globals.js\';\n  import {ASSERT_EQ, ETK_ID, EC_NONE, EC_START_STMT, EC_ATTACHED} from \'../other/constants.js\';\n  import {CB, isAssigList} from \'../other/util.js\';\n  import {wcb_afterElse, wcb_afterStmt} from \'../other/wcb.js\';\n  import {cls} from \'./cls.js\';\n\nEmitters[\'IfStatement\'] =\nfunction(n, flags, isStmt) {\n  ASSERT_EQ.call(this, isStmt, true);\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  this.wt(\'if\', ETK_ID).emc(cb, \'aft.if\');\n  this.wm(\'\',\'(\').eA(n.test, EC_NONE, false).w(\')\');\n\n  this.emitIfBody(n.consequent);\n  if (n.alternate)\n    this.l().wt(\'else\', ETK_ID).gu(wcb_afterElse).emitElseBody(n.alternate);\n\n  this.emc(cb, \'aft\');\n\n  return true;\n};\n\ncls.emitIfBody =\nfunction(stmt) {\n  switch (stmt.type) {\n  case \'BlockStatement\':\n    this.os();\n  case \'EmptyStatement\':\n    return this.emitStmt(stmt);\n  }\n  if (stmt.type === \'ExpressionStatement\') {\n    if (isAssigList(stmt.expression))\n      this.os().emitAny(stmt.expression, EC_START_STMT|EC_ATTACHED, true);\n    else {\n      this.i();\n      this.l().emitStmt(stmt);\n      this.u();\n    }\n    return true;\n  }\n  var own = {used: false};\n  this.os().w(\'{\').i().gu(wcb_afterStmt).gmon(own);\n  this.emitStmt(stmt); // not attached -- the \'{\' block is, instead.\n  if (this.guard) this.grmif(own);\n  else { this.gu(wcb_afterStmt); }\n  this.u().w(\'}\');\n};\n\ncls.emitElseBody =\nfunction(stmt) {\n  return stmt.type === \'IfStatement\' ?\n    this.emitStmt(stmt) :\n    this.emitAttached(stmt);\n};\n\n\n');
resolver.set('./src/Emitter/emitter2-tt.js', '  import {ASSERT, ETK_NONE} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.tt =\nfunction(tt) {\n  ASSERT.call(this, this.ttype === ETK_NONE, \'none\');\n  this.ttype = tt;\n};\n\ncls.nott =\nfunction() {\n  ASSERT.call(this, this.ttype !== ETK_NONE, \'none\');\n  this.ttype = ETK_NONE;\n};\n\ncls.nott_ifAny =\nfunction() {\n  if (this.ttype === ETK_NONE)\n    return false;\n  this.nott();\n  return true;\n};\n\n\n');
resolver.set('./src/Emitter/emitter2-guard.js', '  import {ASSERT, ASSERT_EQ} from \'../other/constants.js\';\n  import {guard_simpleListener} from \'../other/wcb.js\';\n  import {cls} from \'./cls.js\';\n\ncls.insertGuard =\nfunction(guard) {\n  ASSERT.call(this, this.guard === null, \'existing guard\');\n  ASSERT.call(this, this.guardArg === null, \'existing guardArg\');\n  ASSERT.call(this, this.guardListener === null, \'existing guardListener\');\n\n  ASSERT.call(this, !this.runningGuard, \'running\');\n\n  this.guard = guard;\n};\n\ncls.monitorGuard =\nfunction(listener) {\n  ASSERT.call(this, this.guard !== null, \'no\');\n  ASSERT.call(this, this.guardListener === null, \'listener\');\n\n  this.guardListener = listener;\n};\n\ncls.runGuard =\nfunction(str, t) {\n  var guard = this.guard, guardListener = this.guardListener;\n  this.removeGuard_any();\n\n  this.runningGuard = true;\n  guard.call(this, str, t);\n  if (guardListener) {\n    ASSERT_EQ.call(this, guardListener.used, false);\n    guardListener.used = true;\n  }\n  this.guardArg = null;\n  this.runningGuard = false;\n};\n\ncls.listenForEmits =\nfunction(fallbackListener) {\n  var l = null;\n  if (this.guard === null) {\n    l = fallbackListener;\n    this.insertGuard(guard_simpleListener);\n    this.monitorGuard(l);\n  } else {\n    l = this.guardListener;\n    if (l === null) {\n      l = this.defaultGuardListener;\n      l.used = false;\n      this.monitorGuard(l);\n    }\n  }\n  return l;\n};\n\ncls.removeGuard_any =\nfunction() {\n  ASSERT.call(this, this.guard !== null, \'no\');\n  this.guard = this.guardListener = null;\n};\n\ncls.removeGuard_if =\nfunction(listener) {\n  // TODO: uncomment below\n  // ASSERT.call(this, this.guard !== null, \'no\');\n  if (this.guard === null)\n    return false;\n  var guardListener = this.guardListener;\n\n  // TODO: uncomment below\n  // ASSERT.call(this, guardListener !== null, \'listener\');\n  if (guardListener === null)\n    return false;\n\n  if (listener !== guardListener)\n    return false;\n\n  ASSERT_EQ.call(this, listener.used, false);\n  this.removeGuard_any();\n\n  return true;\n};\n\ncls.setGuardArg =\nfunction(arg) {\n  ASSERT.call(this, arg === null || this.guard !== null, \'no\');\n  ASSERT.call(this, (arg === null ? this.guard : this.guardArg) === null, \'n\');\n\n  this.guardArg = arg;\n};\n\ncls.insertGuard_try =\nfunction(guard) {\n  if (this.guard !== null)\n    return false;\n  this.insertGuard(guard);\n  return true;\n};\n\n\n');
resolver.set('./src/Emitter/new-emit-ObjectExpression.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {EC_NEW_HEAD, EC_START_STMT, EC_NONE} from \'../other/constants.js\';\n\nEmitters[\'ObjectExpression\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  var list = n.properties, ci = n[\'#ci\'], e = 0;\n  var hasParen = false;\n  if (ci >= 0) {\n    hasParen = flags & EC_NEW_HEAD;\n    hasParen && this.w(\'(\');\n    this.jz(\'obj\').w(\'(\');\n  } else {\n    hasParen = flags & EC_START_STMT;\n    hasParen && this.w(\'(\');\n  }\n  this.w(\'{\');\n\n  var cbe = null;\n\n  var item = null, last = ci >= 0 ? ci : list.length;\n\n  while (e < last) {\n    item = list[e];\n    if (e) this.w(\',\').os();\n    cbe = CB(item); this.emc(cbe, \'bef\' );\n    this.writeMemName(item.key, false).w(\':\').os().eN(item.value, EC_NONE, false).emc(cbe, \'aft\');\n    e++;\n  }\n\n  this.emc(cb, \'inner\');\n  this.w(\'}\');\n\n  if (ci >= 0) {\n    while (e < list.length) {\n      this.w(\',\').os();\n      item = list[e];\n      cbe = CB(item); this.emc(cbe, \'bef\' );\n      if (item.computed)\n        this.eN(item.key, EC_NONE, false);\n      else\n        this.writeMemName(item.key, true);\n      this.w(\',\').os().eN(item.value, EC_NONE, false).emc(cbe, \'aft\');\n      e++;\n    }\n    this.emc(cb, \'inner\');\n    this.w(\')\');\n  }\n\n  hasParen && this.w(\')\');\n  this.emc(cb, \'aft\');\n\n  isStmt && this.w(\';\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/emitter2-wrap.js', '  import {ASSERT, ETK_NL} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.wrapCurrentLine =\nfunction() {\n  this.hasPendingSpace() && this.removePendingSpace();\n  this.nextLineHasLineBreakBefore = true;\n\n  if (this.lineBlank()) {\n    if (this.guard) {\n      ASSERT.call(this, !this.curLineHasLineBreakBefore, \'leading guard\');\n      this.runGuard(\'\\n\', ETK_NL);\n    }\n    this.startFreshLine();\n  }\n  else this.finishCurrentLine();\n};\n\ncls.overflowLength =\ncls.ol =\nfunction(len) {\n  var wl = this.wrapLimit;\n  return wl <= 0 ? 0 : this.emcol_cur + len - wl;\n};\n\n\n');
resolver.set('./src/Emitter/new-uemit-synth-ucond.js', '  import {UntransformedEmitters, Emitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n\nUntransformedEmitters[\'ucond\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n);\n  this.emc(cb, \'bef\');\n  Emitters[\'ConditionalExpression\'].call(this, n, flags, isStmt);\n  this.emc(cb, \'aft\');\n};\n\n');
resolver.set('./src/Emitter/emitter2-out.js', '  import {ASSERT_EQ, ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.writeToOut_nonLineBreak =\nfunction(str) {\n  this.ensureOutActive();\n  this.writeToOut_raw(str);\n};\n\ncls.writeToOut_lineBreak =\nfunction() {\n  this.ensureOutActive();\n  this.emline_cur++;\n//this.emcol_cur = 0;\n  this.writeToSMout(\';\'); // TODO: ensure we are allowed to actually write to SM; we must have actually committed anything in lm beforehands\n  this.writeToOut_raw(\'\\n\');\n}; \n\ncls.writeToOut_raw =\nfunction(str) { this.out = this.out.concat(str); this.outLen += str.length; };\n\ncls.useOut =\nfunction(use) {\n  ASSERT_EQ.call(this, !this.outActive, use);\n  this.outActive = use;\n};\n\ncls.ensureOutActive =\nfunction() { ASSERT.call(this, this.outActive, \'out is not in use\' ); };\n\n\n');
resolver.set('./src/Emitter/new-uemit-for-in-stmt.js', '  import {Emitters} from \'../other/globals.js\';\n  import {ASSERT_EQ, EC_NONE, ETK_ID} from \'../other/constants.js\';\n  import {tg} from \'../other/util.js\';\n  import {wcb_idNumGuard} from \'../other/wcb.js\';\n  import {cls} from \'./cls.js\';\n\nEmitters[\'#ForInStatementWithDeclarationHead\' ] =\nfunction(n, flags, isStmt) {\n  ASSERT_EQ.call(this, isStmt, true);\n  return this.emitEnumeration(n, flags, \'dh\');\n};\n\n\nEmitters[\'#ForInStatementWithExHead\' ] =  \nfunction(n, flags, isStmt) {\n  ASSERT_EQ.call(this, isStmt, true);\n  return this.emitEnumeration(n, flags, \'eh\');\n};\n\n\ncls.emitEnumeration =\nfunction(n, flags, t) {\n  var b = t === \'dh\';\n  var l = n.left;\n  this.w(\'for\').os().w(\'(\');\n\n  if (b) {\n    if (tg(l).isLLINOSA()) {\n      this.w(\'(\').emitRName_binding(l);\n      this.wm(\'\',\'=\',\'\',\'{\',\'v\');\n      this.os().wm(\':\',\'void\',\' \',\'0\',\'}\',\')\',\'.\',\'v\').bs();\n    }\n    else {\n      this.w(\'var\').bs().emitRName_binding(l);\n      this.bs();\n    }\n  }\n  else if (l.type === \'MemberExpression\') {\n    this.emitSAT(l, EC_NONE, 0);\n    this.os();\n  }\n  else {\n    this.emitAny(l, EC_NONE, false);\n    this.bs();\n  }\n\n  this.wt(\'in\',ETK_ID );\n  this.gu(wcb_idNumGuard );\n  this.os();\n\n  this.emitAny(n.right, EC_NONE, false);\n  this.w(\')\');\n\n  this.emitAttached(n.body);\n};\n\n\n');
resolver.set('./src/Emitter/new-uemit-for-of-stmt.js', '  import {Emitters} from \'../other/globals.js\';\n  import {EC_NONE} from \'../other/constants.js\';\n\nEmitters[\'#ForOfStatement\'] =\nfunction(n, flags, isStmt) {\n  this.w(\'for\').os().w(\'(\');\n  this.eH(n.left, EC_NONE, false).os().w(\'=\').os().jz(\'of\').w(\'(\');\n  this.eN(n.right, EC_NONE, false).w(\')\');\n\n  this.w(\';\').os();\n  var scope = n[\'#scope\'];\n  if (scope.hasTZCheckPoint) {\n    var tz = scope.scs.getLG(\'tz\').getL(0);\n    this.wm(tz.synthName,\' \',\'=\',\' \',scope.di0+\"\",\',\',\'\');\n  }\n  this.eH(n.left, EC_NONE, false).w(\'.\').wm(\'next\',\'(\',\')\',\';\',\')\');\n  this.emitAttached(n.body);\n};\n');
resolver.set('./src/Emitter/new-uemit-synth-tc.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {ASSERT_EQ} from \'../other/constants.js\';\n  import {tzc, tg, cvc} from \'../other/util.js\';\n\nUntransformedEmitters[\'cvtz\'] =\nfunction(n, flags, isStmt) {\n  ASSERT_EQ.call(this, isStmt, false);\n  this.jz(\'o\').w(\'(\').eN(n.value);\n  if (tzc(n.rn))\n    this.w(\',\').os().emitAccessChk_tz(tg(n.rn), n.rn.loc.start);\n  if (cvc(n.rn))\n    this.w(\',\').os().emitAccessChk_invalidSAT(tg(n.rn), n.rn.loc.start);\n\n  this.w(\')\');\n};\n\n');
resolver.set('./src/Emitter/newer.js', '\n\n\n');
resolver.set('./src/Emitter/emitter2-line.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {vlq} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.flushCurrentLine =\nfunction() {\n  if (this.curLine.length) {\n    this.finishCurrentLine(); \n    return true;\n  }\n  return false;\n};\n\ncls.lineBlank =\nfunction() { return this.curLine.length === 0; };\n\ncls.finishCurrentLine =\nfunction() {\n  var line = this.curLine;\n  ASSERT.call(this, !this.finishingLine, \'finishing\');\n  ASSERT.call(this, line.length, \'line\');\n\n  this.ensureNoSpace();\n\n  this.finishingLine = true;\n  var optimalIndentLevel = this.allow.space ? this.curLineIndent : 0;\n  var tailLineBreak = false, optimalIndentString = \"\", optimalIndentStrLength = 0;\n  optimalIndentStrLength = optimalIndentLevel * this.indentString.length;\n\n  if (optimalIndentStrLength >= 0) {\n    var overflow = this.ol(optimalIndentStrLength);\n    if (overflow > 0) {\n      optimalIndentStrLength -= overflow;\n      if (optimalIndentStrLength < 0)\n        optimalIndentStrLength = 0;\n    }\n  }\n\n  optimalIndentString = this.findIndentStringWithIdealLength(optimalIndentStrLength);\n\n  if (this.nextLineHasLineBreakBefore)\n    this.writeToCurrentLine_virtualLineBreak();\n\n  this.useOut(true);\n\n  if (this.curLineHasLineBreakBefore)\n    this.writeToOut_lineBreak();\n\n  this.writeToOut_raw(optimalIndentString);\n  this.writeToOut_raw(this.curLine);\n\n  this.adjustColumns(optimalIndentStrLength);\n  this.refreshSMOutWithLM();\n\n  this.useOut(false);\n\n  this.startFreshLine();\n\n  this.finishingLine = false;\n};\n\ncls.adjustColumns =\nfunction(lindLen) { // line indentation length\n  if (this.hasRecorded_SMLinkpoint)\n    this.ln_emcol_cur += lindLen;\n  if (this.hasRecorded_emcol_latestRec)\n    this.emcol_latestRec += lindLen;\n  if (this.curLineHasLineBreakBefore)\n    this.ln_emcol_latestRec = 0; // i.e., absolute\n  else\n    this.emcol_cur += lindLen;\n};\n\ncls.startFreshLine =\nfunction() {\n  this.curLineHasLineBreakBefore = this.nextLineHasLineBreakBefore;\n  this.curLineIndent = this.nextLineIndent;\n  this.curLine = \"\";\n\n  if (this.curLineHasLineBreakBefore) {\n    this.emcol_cur = 0;\n    this.smLineStart = true;\n  }\n\n  this.hasRecorded_SMLinkpoint = false;\n  this.hasRecorded_emcol_latestRec = false;\n\n  this.ln_emcol_latestRec = this.emcol_latestRec;\n  this.lm = \"\";\n\n  this.ln_vlq_tail = \"\";\n  this.nextLineHasLineBreakBefore = this.allow.nl;\n};\n\ncls.refreshSMOutWithLM =\nfunction() {\n  var lm0 = \"\", lm = this.lm;\n  if (this.hasRecorded_SMLinkpoint) {\n    var lm0 = vlq(this.ln_emcol_cur - this.ln_emcol_latestRec) + this.ln_vlq_tail;\n    if (lm.length) lm0 += \',\';\n  }\n  if (!this.curLineHasLineBreakBefore) {\n    if (lm.length || lm0.length) {\n      if (this.smLineStart)\n        this.smLineStart = false;\n      else\n        this.writeToSMout(\',\');\n    }\n  }\n  lm0.length && this.writeToSMout(lm0);\n  lm.length && this.writeToSMout(lm);\n};\n\n\n');
resolver.set('./src/Emitter/new-emit-TemplateLiteral.js', '  import {Emitters} from \'../other/globals.js\';\n  import {EC_NONE} from \'../other/constants.js\';\n\nEmitters[\'TemplateLiteral\'] =\nfunction(n, flags, isStmt) {\n  var strList = n.quasis;\n  var eList = n.expressions;\n  var s = 0, writeEx = false, e = 0;\n\n  if (strList[0].value.cooked.length === 0 && !strList[0].tail) {\n    s++;\n    writeEx = true;\n  }\n\n  this.w(\'(\'); // TODO: eliminate when the TemplateLiteral gets treated like an actual ex + str + ... + ex + str\n  while (true) {\n    if (writeEx) {\n      this.w(\'(\').eA(eList[e++], EC_NONE, false).w(\')\');\n      this.wm(\'\', \'+\').os();\n      writeEx = false;\n    } \n    else {\n      var item = strList[s++ ];\n      this.writeString(item.value.cooked, \"\'\");\n      if (!item.tail)\n        this.wm(\'\',\'+\',\'\');\n      else\n        break;\n      writeEx = true;\n    }\n  }\n\n  this.w(\')\');\n\n  isStmt && this.w(\';\');\n};\n\n');
resolver.set('./src/Emitter/new-uemit-synth-resolved-name.js', '  import {Emitters} from \'../other/globals.js\';\n  import {tg, cvc, tzc, CB, isResolvedName} from \'../other/util.js\';\n  import {EC_CALL_HEAD, ASSERT_EQ, EC_EXPR_HEAD, EC_NON_SEQ, EC_NONE, ETK_ID, ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\nEmitters[\'#-ResolvedName.ex\'] = cls.emitRName_ex =\nEmitters[\'#-ResolvedName.sat\'] = cls.emitRName_SAT =\nfunction(n, flags, isStmt) {\n  var hasParen = false;\n  var hasZero = false;\n  var tv = tg(n).isLLINOSA(); // tail v\n  var tz = false;\n\n  if (tv)\n    hasZero = hasParen = flags & EC_CALL_HEAD;\n  if (n.type === \'#-ResolvedName.ex\') {\n    ASSERT_EQ.call(this, cvc(n), false);\n    tz = tzc(n);\n    if (tz) {\n      if (!hasParen) hasParen = flags & (EC_EXPR_HEAD|EC_NON_SEQ);\n      if (hasZero) hasZero = false;\n    }\n  }\n  if (tg(n).isGlobal())\n    this.sl(n.loc.start);\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n\n  if (hasZero) this.wm(\'0\',\',\')\n  else if ( tz) {\n    this.emitAccessChk_tz(tg(n), n.loc.start);\n    this.w(\',\').os();\n  }\n\n  var cb = CB(n); this.emc(cb, \'bef\');\n\n//var ni = this.smSetName(n.id.name);\n  this.wt(tg(n).synthName, ETK_ID );\n  tv && this.wm(\'.\',\'v\');\n//this.sl(n.id.loc.end);\n//this.namei_cur = ni;\n\n  this.emc(cb, \'aft\');\n  hasParen && this.w(\')\');\n//tz && this.sl(n.id.loc.end);\n  isStmt && this.w(\';\');\n  return true;\n};\n\nEmitters[\'#-ResolvedName.binding\'] = cls.emitRName_binding =\nfunction(n, flags, isStmt) {\n  ASSERT.call(this, isResolvedName(n), \'rn\');\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  this.wt(tg(n).synthName, ETK_ID );\n  this.emc(cb, \'aft\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/head.js', '  import {ASSERT, EC_NONE} from \'../other/constants.js\';\n  import {wcb_afterStmt} from \'../other/wcb.js\';\n  import {ATS_SAME} from \'../other/scope-constants.js\';\n  import {CB} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.emitSourceHead =\nfunction(n) {\n  var scope = n[\'#scope\'], em = 0;\n  this.emitJ(scope, em) && em++;\n  this.emitTCheckVar(scope, em) && em++;\n  this.emitThisRef(scope, em) && em++;\n  this.emitFunLists(scope, true, em) && em++;\n  this.emitVarList(scope, em) && em++;\n  this.emitTempList(scope, em) && em++;\n  return em;\n};\n\ncls.emitFnHead =\nfunction(n) {\n  var scope = n.fun[\'#scope\'], em = 0;\n  this.emitTCheckVar(scope, em) && em++;\n  this.emitTempList(scope, em) && em++;\n  this.emitThisRef(scope,em) && em++;\n  this.emitThisChk(scope,em) && em++;\n  this.emitArgumentsRef(scope,em) && em++;\n  if (n.argsPrologue) this.emitTransformedArgs(n, em) && em++;\n  this.emitFunLists(scope, true, em) && em++;\n  this.emitVarList(scope, em) && em++;\n  return em;\n};\n\ncls.emitSimpleHead =\nfunction(n) {\n  var scope = n[\'#scope\'], em = 0;\n  scope.hasTZCheckPoint && this.emitTCHP(scope, em) && em++;\n  this.emitLLINOSAList(scope, em) && em++;\n  this.emitFunLists(scope, false, em) && em++;\n  return em;\n};\n\ncls.emitVarList =\nfunction(scope, hasPrev) {\n  ASSERT.call(this, scope.isSourceLevel() || scope.isAnyFn(), \'source/fn\');\n  var list = scope.defs, i = 0, len = list.length(), em = 0;\n  var own = {used: false};\n  hasPrev && this.trygu(wcb_afterStmt, own);\n  while (i < len) {\n    var elem = list.at(i++);\n    if (!elem.isVar()) continue;\n    if (elem.isFn() || elem.isFnArg()) continue;\n    em ? this.w(\',\').os() : this.w(\'var\').bs();\n    this.w(elem.synthName);\n    em++;\n  }\n  em && this.w(\';\');\n  own.used || this.grmif(own);\n  return em;\n};\n\ncls.emitTempList =\nfunction(scope, hasPrev) {\n  ASSERT.call(this, scope.isSourceLevel() || scope.isAnyFn(), \'source/fn\');\n  var list = scope.getLG(\'<t>\'), i = 0, len = list ? list.length : 0;\n  var own = {used: false};\n  hasPrev && this.trygu(wcb_afterStmt, own);\n  while (i < len) {\n    var elem = list.getL(i);\n    i ? this.w(\',\').os() : this.w(\'var\').bs();\n    this.w(elem.synthName);\n    i++;\n  }\n\n  i && this.w(\';\');\n  own.used || this.grmif(own);\n  return i;\n};\n\ncls.emitFunLists =\nfunction(scope, allowsDecl, hasPrev) {\n  var list = scope.funLists, i = 0, len = list.length(), em = 0;\n  var own = {used: false};\n  hasPrev && this.trygu(wcb_afterStmt, own);\n  while (i < len)\n    this.emitFunList_subList(list.at(i++), allowsDecl, em) && em++;\n\n  own.used || this.grmif(own);\n  return em;\n};\n\ncls.emitLLINOSAList =\nfunction(scope, hasPrev) {\n  ASSERT.call(this, !scope.isSourceLevel() && !scope.isAnyFn(), \'scope/fn\');\n  var list = scope.defs, i = 0, len = list.length(), em = 0;\n  var own = {used: false};\n  hasPrev && this.trygu(wcb_afterStmt, own);\n  while (i < len) {\n    var elem = list.at(i++);\n    if (!elem.isLLINOSA()) continue;\n    em ? this.w(\',\').os() : this.w(\'var\').bs();\n    this.w(elem.synthName).os().w(\'=\').os().wm(\'{\',\'v\',\':\',\'\',\'void\').bs().wm(\'0\',\'}\');\n    em++;\n  }\n\n  em && this.w(\';\');\n  own.used || this.grmif(own);\n  return em;\n};\n\ncls.emitFunList_subList =\nfunction(funList, allowsDecl, hasPrev) {\n  var i = 0, em = 0;\n  var own = {used: false}, lsn = null; \n  hasPrev && this.trygu(wcb_afterStmt, own);\n  while (i < funList.length) {\n    this.emitSingleFun(funList[i], allowsDecl, i, em) && em++;\n    i++;\n  }\n  own.used || this.grmif(own);\n  return em;\n};\n\ncls.emitThisRef =\nfunction(scope, hasPrev) {\n  var th = scope.spThis;\n  if (th === null) return 0;\n  if (th.ref.i === 0) return 0;\n\n  var own = {used: false};\n  hasPrev && this.trygu(wcb_afterStmt, own);\n\n  this.w(\'var\').bs().w(th.synthName).os().w(\'=\').os().w(\'this\').w(\';\');\n\n  own.used || this.grmif(own);\n  return 1;\n};\n\ncls.emitSingleFun =\nfunction(n, allowsDecl, i, hasPrev) {\n  if (n.emitted) return 0;\n  ASSERT.call(this, n.emitted === false, \'n.emitted\');\n\n  var scope = n.fun[\'#scope\'];\n  var target = n.target;\n\n  ASSERT.call(this, target, \'n.target\' );\n\n  var own = {used: false};\n  hasPrev && this.trygu(wcb_afterStmt, own);\n\n  if (allowsDecl && scope.scopeName.getAS() === ATS_SAME)\n    this.emitTransformedFn(n, EC_NONE, true);\n  else {\n    var ll = target.isLLINOSA();\n    if (i === 0 && !ll)\n      this.w(\'var\').bs();\n    this.w(target.synthName);\n    ll && this.wm(\'.\',\'v\');\n    this.wm(\'\',\'=\',\'\');\n    n.target = null;\n    scope.scopeName.synthName = scope.scopeName.name;\n    this.emitExprFn(n, EC_NONE, false);\n    this.w(\';\'); // could have been done above, with true instead of false\n  }\n\n  own.used || this.grmif(own);\n  return 1;\n};\n\ncls.emitTCheckVar =\nfunction(scope, hasPrev) {\n  var tg = scope.getLG(\'tz\');\n  if (tg === null) return 0;\n  tg = tg.getL(0);\n  var own = {used: false};\n  hasPrev && this.trygu(wcb_afterStmt, own);\n  this.w(\'var\').bs().w(tg.synthName).os().w(\'=\').os().w(scope.di0+\"\").w(\';\');\n  own.used || this.grmif(own);\n  return 1;\n};\n\ncls.emitTransformedArgs =\nfunction(n, hasPrev) {\n  var ta = n.argsPrologue;\n  if (ta === null)\n    return 0;\n  var b = CB(n.fun);\n\n  var own = {used: false};\n  hasPrev && this.trygu(wcb_afterStmt, own);\n \n  this.emitStmt(ta);\n  this.emc(b, \'inner\');\n\n  own.used || this.grmif(own);\n  return 1;\n};\n\ncls.emitTCHP =\nfunction(scope, hasPrev) {\n  var tg = scope.scs.getLG(\'tz\').getL(0);\n  if (tg === null)\n    return 0;\n\n  var own = {used: false};\n  hasPrev && this.trygu(wcb_afterStmt, own);\n\n  this.wm(tg.synthName,\'=\',scope.di0+\"\",\';\');\n\n  own.used || this.grmif(own);\n  return 1;\n};\n\ncls.emitArgumentsRef =\nfunction(scope, hasPrev) {\n  var ar = scope.spArguments;\n  if (ar === null) return 0;\n  if (ar.ref.i === 0) return 0;\n\n  var own = {used: false};\n  hasPrev && this.trygu(wcb_afterStmt, own);\n\n  this.wm(\'var\',\' \',ar.synthName,\'\',\'=\',\'\',\'arguments\',\';\');\n\n  own.used || this.grmif(own);\n  return 1;\n};\n\ncls.emitThisChk =\nfunction(scope, hasPrev) {\n  var ti = scope.getLG(\'ti\');\n  if (ti === null) return 0;\n  ti = ti.getL(0);\n  if (ti === null || ti.ref.d <= 0) return 0;\n\n  var own = {used: false};\n  hasPrev && this.trygu(wcb_afterStmt, own);\n  this.wm(\'var\',\' \',ti.synthName,\'\',\'=\',\'\',\'0\',\';\');\n\n  own.used || this.grmif(own);\n  return 1;\n};\n\ncls.emitJ =\nfunction(scope, hasPrev) {\n  return 0;\n  var own = false, u = null, o = {v: false};\n  if (hasPrev) {\n    if (!this.wcb) { this.onw(wcb_afterStmt); own = true; }\n    if (!this.wcbUsed) this.wcbUsed = u = o;\n    else u = this.wcbUsed;\n  }\n\n  this.wm(\'jz\',\'\',\'=\',\'\',\'jz\',\'(\',\')\',\';\');\n\n  if (own) u.v || this.clear_onw();\n  return 1;\n};\n\n\n');
resolver.set('./src/Emitter/new-emit-BreakStatement.js', '  import {Emitters} from \'../other/globals.js\';\n  import {ETK_ID} from \'../other/constants.js\';\n\nEmitters[\'BreakStatement\'] =\nfunction(n, flags, isStmt) {\n  this.wt(\'break\',ETK_ID );\n  var wl = this.wrapLimit;\n  this.wrapLimit = 0;\n  n.label && this.hs().writeToCurrentLine_raw(n.label.name);\n  this.wrapLimit = wl;\n  this.w(\';\');\n};\n\n');
resolver.set('./src/Emitter/new-uemit-synth-obj-iter.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {ASSERT_EQ, EC_NONE} from \'../other/constants.js\';\n\nUntransformedEmitters[\'obj-iter\'] =\nfunction(n, flags, isStmt) {\n  this.eN(n.iter, flags, isStmt);\n};\n\nUntransformedEmitters[\'obj-iter-end\'] =\nfunction(n, flags, isStmt) {\n  ASSERT_EQ.call(this, isStmt, false);\n  this.eN(n.iter, flags, isStmt);\n};\n\nUntransformedEmitters[\'obj-iter-get\'] =\nfunction(n, flags, isStmt) {\n  this.eH(n.iter);\n  if (n.computed)\n    this.w(\'[\').eA(n.idx, EC_NONE, false).w(\']\');\n  else\n    this.w(\'.\').writeMemName(n.idx, false);\n};\n\n');
resolver.set('./src/Emitter/emitter2-sm.js', '  import {_m} from \'../other/scope-util.js\';\n  import {ASSERT} from \'../other/constants.js\';\n  import {vlq} from \'../other/util.js\';\n  import {cls} from \'./cls.js\';\n\ncls.smSetName_str =\nfunction(name) {\n  var nc = -1;\n  if (name.length) {\n    var mname = _m(name), list = this.smNameList;\n    nc = list.has(mname) ? list.get(mname) : list.set(mname, list.length());\n  }\n  return this.smSetName_i(nc);\n};\n\ncls.smSetName_i =\nfunction(i) {\n  var list = this.smNameList;\n  ASSERT.call(this, i >= 0 ? i <= list.length() : i === -1, \'namei\' );\n  var nc = this.namei_cur;\n\n  this.namei_cur = i;\n  return nc;\n};\n\ncls.smSetSrc_str =\nfunction(srcName) {\n  var sc = -1;\n  if (srcName.length) {\n    var mname = _m(srcName), list = this.smSrcList;\n    sc = list.has(mname) ? list.get(mname) : list.set(mname, list.length());\n  }\n  return this.smSetSrc_i(sc);\n};\n\ncls.smSetSrc_i =\nfunction(i) {\n  var list = this.smSrcList;\n  ASSERT.call(this, i >= 0 ? i <= list.length() : i === -1, \'srci\' );\n  var sc = this.srci_cur;\n\n  this.srci_cur = i;\n  return sc;\n};\n\ncls.writeToSMout =\nfunction(lm) { this.sm = this.sm.concat(lm); this.smLen += lm.length; };\n\ncls.refreshTheCurrentLineLevelSourceMapWith =\nfunction(srcLoc) {\n  var l = 0, vlqTail = \"\";\n\n  l = this.srci_cur;\n  vlqTail += vlq(l - this.srci_latestRec);\n  this.srci_latestRec = l;\n\n  var ll = this.loc_latestRec; // latest loc\n  vlqTail += vlq(srcLoc.line - ll.line) + vlq(srcLoc.column - ll.column);\n  this.loc_latestRec = srcLoc;\n\n  if ((l=this.namei_cur) >= 0) {\n    vlqTail += vlq(l - this.namei_latestRec);\n    this.namei_latestRec = l;\n  }\n\n  l = this.emcol_cur;\n  if (this.hasRecorded_SMLinkpoint) {\n    var lm = this.lm;\n    if (lm.length) lm += \',\';\n    this.lm = lm + vlq(l - this.emcol_latestRec) + vlqTail;\n  }\n  else {\n    this.ln_emcol_cur = l;\n    this.ln_vlq_tail = vlqTail;\n    this.hasRecorded_SMLinkpoint = true;\n  }\n  this.emcol_latestRec = l;\n  if (!this.hasRecorded_emcol_latestRec)\n    this.hasRecorded_emcol_latestRec = true;\n  this.emline_latestRec = this.emline_cur;\n};\n\ncls.setSourceLocTo =\nfunction(srcLoc) {\n  ASSERT.call(this, srcLoc, \'lw\');\n  this.pendingSrcLoc = srcLoc;\n};\n\n\n');
resolver.set('./src/Emitter/emitter2-indent.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.findIndentStringWithIdealLength =\nfunction(idealLength) {\n  var INLEN = this.indentString.length;\n//ASSERT.call(this, idealLength % INLEN === 0, \'len\'); // TODO: eliminate\n  var remaining = idealLength % INLEN;\n  idealLength -= remaining;\n  var level = idealLength / INLEN;\n\n  var cache = this.indentCache, l = cache.length;\n  var str = \"\";\n  if (level < l)\n    str = cache[level];\n\n  else {\n    str = cache[l-1];\n    ASSERT.call(this, l > 0, \'l\');\n    while (l <= level) {\n      cache[l] = str = str + this.indentString;\n      l++;\n    }\n  }\n\n  if (remaining)\n    str += this.indentString.substring(0, remaining);\n\n  return str;\n};\n\ncls.indentNextLine =\nfunction() { this.nextLineIndent++; };\n\ncls.unindentNextLine =\nfunction() {\n  ASSERT.call(this, this.nextLineIndent > 0, \'line has a <1 indent\');\n  this.nextLineIndent--;\n};\n\n\n');
resolver.set('./src/Emitter/new-emit-MemberExpression.js', '  import {CB} from \'../other/util.js\';\n  import {EC_NONE} from \'../other/constants.js\';\n  import {Emitters} from \'../other/globals.js\';\n  import {cls} from \'./cls.js\';\n\ncls.emitMemex =\nfunction(n, flags, isStmt, len) {\n  var cb = CB(n); this.emc(cb, \'bef\' );\n//this.sl(n.loc.start);\n  this.eH(n.object, flags, false);\n  this.sl(n[\'#acloc\']);\n  if (n.computed) {\n    this.w(\'[\').eA(n.property, EC_NONE, false);\n    if (len > 0 && this.ol(1+len) > 0) this.wrapCurrentLine();\n    this.w(\']\');\n  }\n  else {\n    this.w(\'.\').emc(CB(n.property), \'bef\');\n    this.writeIDName(n.property.name); // TODO: node itself rather than its name\'s string value\n  }\n  this.emc(cb, \'aft\');\n  isStmt && this.w(\';\');\n  return true;\n};\n\ncls.emitSAT_mem = \nfunction(n, flags, len) { return this.emitMemex(n, flags, false, len); };\n\nEmitters[\'MemberExpression\'] =\nfunction(n, flags, isStmt, len) { return this.emitMemex(n, flags, isStmt, 0); };\n\n\n');
resolver.set('./src/Emitter/new-uemit-synth-global-update.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {EC_NEW_HEAD, ETK_ID, EC_NONE} from \'../other/constants.js\';\n  import {tg} from \'../other/util.js\';\n\nUntransformedEmitters[\'global-update\'] =\nfunction(n, flags, isStmt) {\n  ;\n  var hasParen = flags & EC_NEW_HEAD;\n  var td = tg(n.isU ? n.assig.argument : n.assig.left);\n  hasParen && this.w(\'(\');\n  this.wt(td.synthName+\'u\', ETK_ID).w(\'(\').eN(n.assig, EC_NONE, false).w(\')\');\n  hasParen && this.w(\')\');\n  isStmt && this.w(\';\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-emit-UnaryExpression.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {EC_EXPR_HEAD, EC_NONE, ETK_MIN, ETK_ADD, ETK_ID, ASSERT} from \'../other/constants.js\';\n  import {wcb_MIN_u, wcb_ADD_u, wcb_afterVDT} from \'../other/wcb.js\';\n  import {cls} from \'./cls.js\';\n\nEmitters[\'UnaryExpression\'] = \nfunction(n, flags, isStmt) {\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  var o = n.operator;\n  var hasParen = flags & EC_EXPR_HEAD;\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n\n  switch (o) {\n  case \'!\':\n  case \'~\':\n    this.w(o);\n    break;\n  case \'-\':\n    this.wt(o, ETK_MIN).gu(wcb_MIN_u);\n    break;\n  case \'+\':\n    this.wt(o, ETK_ADD).gu(wcb_ADD_u);\n    break;\n  case \'void\': case \'delete\': case \'typeof\':\n    this.wt(o, ETK_ID).gu(wcb_afterVDT);\n    break;\n  default:\n    ASSERT.call(this, false, \'unary [:\'+o+\':]\');\n    break;\n  }\n\n  this.emitUA(n.argument);\n  hasParen && this.w(\')\');\n  this.emc(cb, \'aft\');\n\n  isStmt && this.w(\';\');\n  return true;\n};\n\ncls.emitUA = function(n) {\n  switch (n.type) {\n  case \'UnaryExpression\':\n  case \'UpdateExpression\':\n    return this.emitAny(n, EC_NONE, false);\n  }\n  return this.emitHead(n, EC_NONE, false);\n};\n\n\n');
resolver.set('./src/Emitter/new-uemit-synth-mem-list.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {EC_NONE} from \'../other/constants.js\';\n\nUntransformedEmitters[\'memlist\'] =\nfunction(n, flags, isStmt) {\n  var list = n.m, tproto = n.p, e = 0;\n  var m = 0;\n  while (e < list.length) {\n    var mem = list[e++];\n    if (mem === null) continue;\n    if (m) isStmt ? this.w(\';\').l() : this.w(\',\').os();\n    this.eH(tproto);\n    if (mem.computed || mem.key.type === \'Literal\')\n      this.w(\'[\').eA(mem.key, EC_NONE, false).w(\']\');\n    else\n      this.w(\'.\').writeMemName(mem.key, false);\n    this.wm(\'\',\'=\',\'\').eA(mem.value, EC_NONE, false );\n    m++;\n  }\n  isStmt && m && this.w(\';\');\n};\n\n');
resolver.set('./src/Emitter/emc.js', '  import {HAS, ETK_DIV, ETK_COMMENT, ETK_NL} from \'../other/constants.js\';\n  import {wcb_afterLineComment} from \'../other/wcb.js\';\n  import {cls} from \'./cls.js\';\n\ncls.emc =\nfunction(cb, i) {\n  if (HAS.call(cb, i)) {\n    var e = cb[i];\n    cb[i] = null;\n    return this.emcim(e);\n  }\n  return false;\n};\n\ncls.emce = // emc erase\nfunction(cb, i) {\n  if (this.emc(cb, i)) {\n    cb[i] = null;\n    return true;\n  }\n  return false;\n};\n\ncls.emcim =\nfunction(comments) { // emc -- immediate\n  if (comments === null)\n    return false;\n\n  var list = comments.c, nl = comments.n, e = 0, l = null;\n  while (e < list.length) {\n    var elem = list[e];\n    var resume = elem.type === \'Line\' ?\n      this.allow.comments.l : this.allow.comments.m;\n\n    if (resume) {\n      if (l) {\n        if (l.type === \'Line\' || l.loc.end.line < elem.loc.start.line)\n          this.l();\n      }\n      l = elem;\n\n      var wflag = ETK_DIV|ETK_COMMENT;\n      if (e === 0 && nl)\n        wflag |= ETK_NL;\n\n      if (elem.type === \'Line\') {\n        this.wt(\'//\', wflag).writeToCurrentLine_raw(elem.value);\n      }\n      else {\n        this.wt(\'/*\', wflag);\n        this.writeToCurrentLine_raw(elem.value);\n        this.writeToCurrentLine_raw(\'*/\');\n      }\n    }\n\n    e++;\n  }\n\n  if (l && l.type === \'Line\') {\n    this.nextLineHasLineBreakBefore = true;\n    this.gu(wcb_afterLineComment);\n  }\n\n  return true;\n};\n\n\n');
resolver.set('./src/Emitter/emitter2-space.js', '  import {ASSERT, SP_NONE, SP_OMITTABLE, SP_BREAKABLE} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.ensureNoSpace =\nfunction() { ASSERT.call(this, !this.hasPendingSpace(), \'hasPendingSpace\' ); };\n\ncls.hasPendingSpace =\nfunction() { return this.pendingSpace !== SP_NONE; };\n\ncls.enqueueOmittableSpace =\nfunction() {\n  this.ensureNoSpace(); ASSERT.call(this, this.notJustAfterLineBreak(), \'leading\');\n  this.pendingSpace = SP_OMITTABLE;\n};\n\ncls.enqueueBreakingSpace =\nfunction() {\n  this.ensureNoSpace(); ASSERT.call(this, this.notJustAfterLineBreak(), \'leading\');\n  this.pendingSpace = SP_BREAKABLE;\n};\n\ncls.removePendingSpace =\nfunction() {\n  var sp = this.pendingSpace;\n  this.pendingSpace = SP_NONE;\n  return sp;\n};\n\ncls.effectPendingSpace =\nfunction(len) {\n  ASSERT.call(this, this.notJustAfterLineBreak(), \'leading\');\n  var pendingSpace = this.removePendingSpace();\n  switch (pendingSpace) {\n  case SP_OMITTABLE:\n    if (this.allow.space && this.ol(len+1) <= 0)\n      this.writeToCurrentLine_space();\n    break;\n  case SP_BREAKABLE:\n    if (this.ol(len+1) <= 0)\n      this.writeToCurrentLine_space();\n    else\n      this.wrapCurrentLine();\n    break;\n  default:\n    ASSERT.call(this, false, \'invalid type for pending space\' );\n    break;\n  }\n};\n\ncls.removePendingSpace_try =\nfunction() {\n  return this.hasPendingSpace() ? \n    this.removePendingSpace() : SP_NONE;\n};\n\ncls.notJustAfterLineBreak =\nfunction() {\n  return this.curLine.length || !this.curLineHasLineBreakBefore;\n};\n\n\n');
resolver.set('./src/Emitter/new-uemit-synth-resolved-this.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {EC_EXPR_HEAD, EC_NON_SEQ, EC_NONE, ETK_ID, ASSERT_EQ} from \'../other/constants.js\';\n\nUntransformedEmitters[\'resolved-this\'] =\nfunction(n, flags, isStmt) {\n  var hasParen = false, b = CB(n.id);\n  var th = n.plain ? \'this\' : n.target.synthName;\n\n  if (n.chk) hasParen = flags & (EC_EXPR_HEAD|EC_NON_SEQ);\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n\n  if (n.chk) { \n    this.w(n.target.ref.scope.scs.getLG(\'ti\').getL(0).synthName)\n      .w(\'||\').jz(\'tz\');\n    this.sl(n.id.loc.start);\n    this.w(\'(\').writeString(\'this\',\"\'\");\n    this.wm(\')\',\',\');\n  }\n  this.emc(b, \'bef\');\n  this.wt(th, ETK_ID);\n  this.emc(b, \'aft\');\n\n  hasParen && this.w(\')\'); \n\n  isStmt && this.w(\';\');\n};\n\nUntransformedEmitters[\'bthis\'] =\nfunction(n, flags, isStmt) {\n  ASSERT_EQ.call(this, isStmt, false);\n  this.w(n.plain ? \'this\' : n.target.synthName);\n};\n\n');
resolver.set('./src/Emitter/new-emit-ContinueStatement.js', '  import {Emitters} from \'../other/globals.js\';\n  import {ETK_ID} from \'../other/constants.js\';\n\nEmitters[\'ContinueStatement\'] =\nfunction(n, flags, isStmt) {\n  this.wt(\'continue\',ETK_ID );\n  var wl = this.wrapLimit;\n  this.wrapLimit = 0;\n  n.label && this.hs().writeIDName(n.label.name);\n  this.wrapLimit = wl;\n  this.w(\';\');\n};\n\n');
resolver.set('./src/Emitter/new-emit-SequenceExpression.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {EC_EXPR_HEAD, EC_NON_SEQ, EC_NONE} from \'../other/constants.js\';\n\nEmitters[\'SequenceExpression\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  var hasParen = flags & (EC_EXPR_HEAD|EC_NON_SEQ);\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n  this.emitCommaList(n.expressions, flags);\n  hasParen && this.w(\')\');\n  this.emc(cb, \'aft\');\n  isStmt && this.w(\';\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-uemit-synth-llinosa-names.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {ASSERT_EQ} from \'../other/constants.js\';\n\nUntransformedEmitters[\'llinosa-names\'] =\nfunction(n, flags, isStmt) {\n  ASSERT_EQ.call(this, isStmt, true);\n  var scope = n.scope, hasV = n.withV, list = scope.defs, em = 0;\n  var l = 0, len = list.length();\n\n  while (l < len) {\n    var item = list.at(l++);\n    if (item.isLLINOSA()) {\n      em ? this.w(\',\').os() : this.w(\'var\').bs();\n      this.w(item.synthName);\n      hasV && this.os().wm(\'=\',\'\',\'{\',\'v\',\':\',\'\',\'void\',\' \',\'0\',\'}\');\n      ++ em;\n    }\n  }\n\n  em && this.w(\';\').l(); // TODO onw(wcb_afterStmt) rather than l\n};\n\n');
resolver.set('./src/Emitter/cls.js', '  import {SP_NONE, ETK_NONE} from \'../other/constants.js\';\n  import SortedObj from \'../SortedObj/cls.js\';\n  import {createObj} from \'../other/util.js\';\n  import {Emitters} from \'../other/globals.js\';\n  import JZMap from \'../JZMap/cls.js\';\n  import {HELPERS} from \'../other/helpers.js\';\n\nexport default function Emitter() {\n  this.indentCache = [\"\"];\n  this.indentString = \'  \';\n  this.indentLevel = 0;\n\n  this.wrapLimit = 0;\n\n  this.curLineIndent = 0;\n  this.curLineHasLineBreakBefore = false;\n  this.curLine = \"\";\n\n  this.pendingSpace = SP_NONE;\n\n  this.nextLineIndent = 0;\n  this.nextLineHasLineBreakBefore = false;\n\n  this.finishingLine = false;\n\n  this.guard = null;\n  this.guardArg = null;\n  this.guardListener = null;\n  this.defaultGuardListener = {v: false};\n  this.runningGuard = false;\n\n  this.ttype = ETK_NONE;\n\n  this.jzHelpers = new JZMap(HELPERS);\n  this.jzLiquid = null;\n\n  // <sourcemap-related>\n  this.emcol_cur = 0;\n  this.emcol_latestRec = 0;\n\n  this.emline_cur = 0;\n  this.emline_latestRec = 0;\n\n  this.srci_cur = 0; // -1;\n  this.srci_latestRec = 0; // -1;\n\n  this.namei_cur = -1;\n  this.namei_latestRec = -1;\n\n  this.loc_latestRec = {line: 1, column: 0};\n\n  this.sm = \"\";\n  this.lm = \"\";\n\n  this.ln_vlq_tail = \"\";\n  this.ln_emcol_cur = 0;\n  this.ln_emcol_latestRec = 0;\n\n  this.pendingSrcLoc = null;\n\n  this.hasRecorded_SMLinkpoint = false;\n  this.hasRecorded_emcol_latestRec = false;\n\n  this.smNameList = new SortedObj();\n  this.smSrcList = new SortedObj();\n  // </sourcemap-related>\n\n  this.smLen = 0;\n  this.smLineStart = false;\n\n  this.outLen = 0;\n\n  this.emitters = createObj(Emitters);\n  this.allow = { space: true, nl: true, comments: { l: true, m: true }, elemShake: false, jzWrapper: false };\n  this.out = \"\";\n  this.outActive = false;\n}\n\n export var cls = Emitter.prototype;\n');
resolver.set('./src/Emitter/new-emit-ReturnStatement.js', '  import {Emitters} from \'../other/globals.js\';\n  import {ASSERT_EQ, ETK_ID, EC_NONE} from \'../other/constants.js\';\n  import {CB} from \'../other/util.js\';\n  import {wcb_afterRet} from \'../other/wcb.js\';\n\nEmitters[\'ReturnStatement\'] =\nfunction(n, flags, isStmt) {\n  ASSERT_EQ.call(this, isStmt, true);\n\n  var cb = CB(n);\n  this.emc(cb, \'bef\');\n\n  this.sl(n.loc.start); // TODO: only ctors without supers\n\n  this.wt(\'return\',ETK_ID);\n  if (n.argument) {\n    var l = {hasParen: false};\n    this.gu(wcb_afterRet).gar(l);\n    this.emitAny(n.argument, EC_NONE, false);\n    if (l.hasParen) this.w(\')\');\n  } else\n    this.emc(cb, \'ret.aft\');\n  this.w(\';\');\n  this.emc(cb, \'aft\');\n};\n\n');
resolver.set('./src/Emitter/new-emit-WhileStatement.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {ETK_ID, EC_NONE} from \'../other/constants.js\';\n\nEmitters[\'WhileStatement\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  this.wt(\'while\', ETK_ID);\n  this.emc(cb, \'while.aft\') || this.os(); \n  this.w(\'(\').eA(n.test, EC_NONE, false).w(\')\');\n  this.emitAttached(n.body);\n  this.emc(cb, \'aft\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-uemit-synth-ctor.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {ASSERT_EQ, ETK_ID} from \'../other/constants.js\';\n  import {wcb_afterRet} from \'../other/wcb.js\';\n\nUntransformedEmitters[\'synthc\'] =\nfunction(n, flags, isStmt) {\n  ASSERT_EQ.call(this, isStmt, false ) ;\n  var s = \'s\';\n  if (n.heritage) {\n    var base = \'s\', num = 0;\n    if (n.name) {\n      var name = n.name.name;\n      while (name === s)\n        s = base + (++num);\n    }  \n    this.wt(\'function\',ETK_ID).wm(\'(\',s,\')\',\'\',\'{\',\'\',\'return\').onw(wcb_afterRet,{hasParen: false});\n    var obj = this.wcbp;\n    this.wt(\'function\',ETK_ID);\n    if (n.name) this.wm(\' \',n.name.name);\n    this.wm(\'(\',\')\',\'\',\'{\',\'\', s,\'.\',\'apply\',\'(\',\n      \'this\',\',\',\'arguments\',\')\',\';\',\'\',\'}\');\n    obj.hasParen && this.w(\')\')\n    this.wm(\';\',\'\',\'}\',\'(\').eN(n.heritage).w(\')\');\n\n  } else {\n    this.w(\'function\');\n    if (n.name) this.wm(\' \',n.name.name);\n    this.wm(\'(\',\')\',\'\',\'{\',\'}\');\n  }\n};\n\n');
resolver.set('./src/Emitter/new-uemit-synth-transformed-fn.js', 'import {UntransformedEmitters} from \'../other/globals.js\';\nimport {CB} from \'../other/util.js\';\nimport {ETK_ID} from \'../other/constants.js\';\nimport {wcb_afterStmt} from \'../other/wcb.js\';\nimport {cls} from \'./cls.js\';\n\nUntransformedEmitters[\'transformed-fn\'] =\nfunction(n, flags, isStmt) {\n  if (n.emitted)\n    return;\n  if (n.target)\n    this.emitDeclFn(n, flags, isStmt);\n  else\n    this.emitExprFn(n, flags, isStmt);\n  n.emitted = true;\n};\n\ncls.emitTransformedFn =\nfunction(n, flags, isStmt) {\n  var raw = n.fun, cb = CB(raw);\n  this.emc(cb, \'bef\');\n  this.wt(\'function\', ETK_ID );\n  this.emc(cb, \'fun.aft\');\n  var scopeName = raw[\'#scope\'].scopeName;\n\n  var ni = this.namei_cur;\n  if (scopeName) {\n    this.bs();\n    var name_cb = scopeName.site && CB(scopeName.site);\n    name_cb && this.emc(name_cb, \'bef\' );\n    ni = this.smSetName_str(scopeName.name);\n    this.writeIDName(scopeName.name);\n    name_cb && this.emc(name_cb, \'aft\');\n  }\n  this.emc(cb, \'list.bef\' );\n  this.sl(raw[\'#argploc\']);\n  this.w(\'(\');\n\n  if (raw.params) {\n    this.emitCommaList(raw.params);\n    this.emc(cb, \'inner\');\n  }\n\n  var own = {used: false}, lsn = null, em = 0;\n  this.wm(\')\',\'\',\'{\').i();\n\n  this.gu(wcb_afterStmt).gmon(own);\n  this.emitFnHead(n);\n  if (own.used) {\n    em++;\n    own.used = false;\n    this.trygu(wcb_afterStmt, own);\n  }\n\n  this.emitStmtList(raw.body.body);\n\n  if (own.used) em++;\n  else { this.grmif(own); }\n\n  this.u();\n\n  em && this.l();\n\n  this.w(\'}\');\n  this.namei_cur = ni;\n  this.emc(cb, \'aft\');\n};\n\n\n');
resolver.set('./src/Emitter/new-emit2-Literal.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB, isInteger} from \'../other/util.js\';\n  import {ETK_ID, ETK_NONE, ETK_NUM, ETK_DIV, BOOL_TYPE, NUMBER_TYPE, ASSERT, STRING_TYPE, HAS} from \'../other/constants.js\';\n  import {wcb_intDotGuard} from \'../other/wcb.js\';\n\nEmitters[\'Literal\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  var isRegex = HAS.call(n, \'regex\');\n  if (n.value === null && !isRegex)\n    this.wt(\'null\',ETK_ID);\n  else\n  switch (typeof n.value) {\n  case STRING_TYPE: \n    this.writeString(n.value,\"\'\");\n    this.ttype = ETK_NONE;\n    break;\n  case BOOL_TYPE: \n    this.wt(n.value ? \'true\' : \'false\', ETK_ID);\n    break;\n  case NUMBER_TYPE:\n    this.wt(n.value+\"\", ETK_NUM);\n    if (isInteger(n.value))\n      this.gu(wcb_intDotGuard );\n    break;\n  default:\n    if (isRegex)\n      this.wt(n.raw,ETK_DIV);\n    else\n      ASSERT.call(this, false, \'unknown value\');\n    break;\n  }\n  this.emc(cb, \'aft\');\n  isStmt && this.w(\';\');\n\n  return true;\n};\n');
resolver.set('./src/Emitter/new-emit-LabeledStatement.js', '  import {Emitters} from \'../other/globals.js\';\n  import {wcb_afterStmt} from \'../other/wcb.js\';\n\nEmitters[\'LabeledStatement\'] =\nfunction(n, flags, isStmt) {\n  this.writeIDName(n.label.name);\n  this.w(\':\').gu(wcb_afterStmt);\n  var own = {used: false};\n  this.gmon(own);\n  if (n.body) this.emitStmt(n.body);\n\n  own.used || this.grmif(own);\n};\n\n');
resolver.set('./src/Emitter/new-emit-SwitchStatement.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {ETK_ID, EC_NONE} from \'../other/constants.js\';\n  import {wcb_afterStmt, wcb_afterCase} from \'../other/wcb.js\';\n\nEmitters[\'SwitchStatement\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  this.wt(\'switch\', ETK_ID).emc(cb, \'switch.aft\');\n  this.wm(\'\',\'(\').eA(n.discriminant, EC_NONE, false).w(\')\');\n  this.emc(cb, \'cases.bef\') || this.os();\n  this.w(\'{\');\n\n  var own = {used: false};\n  this.gu(wcb_afterStmt).gmon(own);\n  this.emitStmtList(n.cases); // TODO: emitCases(cases []SwitchCase), to make less use of new `{used: false}` objects\n  own.used ? this.l() : this.grmif(own);\n  this.emc(cb, \'inner\');\n  this.w(\'}\').emc(cb, \'aft\');\n  return true;\n};\n\nEmitters[\'SwitchCase\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  n.test === null ?\n    this.wt(\'default\', ETK_ID).emc(cb, \'default.aft\') :\n    this.wt(\'case\', ETK_ID).gu(wcb_afterCase).eA(n.test, EC_NONE, false);\n\n  var own = {used: false};\n  this.w(\':\').i().gu(wcb_afterStmt).gmon(own);\n  this.emitStmtList(n.consequent);\n  this.u().grmif(own);\n  this.emc(cb, \'aft\');\n  this.emc(cb, \'inner\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-uemit-synth-tzchk.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {EC_NON_SEQ, EC_EXPR_HEAD, EC_NEW_HEAD, EC_NONE, ASSERT} from \'../other/constants.js\';\n\nUntransformedEmitters[\'tzchk\'] =\nfunction(n, flags, isStmt) {\n  var hasParen = false;\n  if (!isStmt)\n    hasParen = n.li ? flags & (EC_NON_SEQ|EC_EXPR_HEAD ) :\n      flags & EC_NEW_HEAD;\n  \n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n  if (n.liq === null) { this.jz(\'tz\').w(\'(\').writeString(n.target.name,\"\'\"); this.w(\')\'); }\n  else ASSERT.call(this, false,  \'l\');\n\n  isStmt && this.w(\';\');\n};\n\nUntransformedEmitters[\'tzcheckpoint\'] =\nfunction(n, flags, isStmt) {\n  ASSERT.call(this, n.scope.hasTZCheckPoint, \'could not find a tzcheckpoint\');\n  this.w(n.scope.scs.getLG(\'tz\').getL(0).synthName).wm(\'\',\'=\').wm(\'\',n.scope.di0+\"\");\n  isStmt && this.w(\';\');\n};\n');
resolver.set('./src/Emitter/new-emit-BlockStatement.js', '  import {Emitters} from \'../other/globals.js\';\n  import {EC_ATTACHED, ASSERT_EQ} from \'../other/constants.js\';\n  import {CB} from \'../other/util.js\';\n  import {wcb_afterStmt} from \'../other/wcb.js\';\n\nEmitters[\'BlockStatement\'] =\nfunction(n, flags, isStmt) {\n  var attached = flags & EC_ATTACHED;\n  attached && this.os();\n\n  ASSERT_EQ.call(this, isStmt, true);\n  var cb = CB(n);\n  this.emc(cb, \'bef\');\n  this.w(\'{\').i();\n  var lead = n[\'#lead\'];\n\n  var own = {used: false}, lsn = null;\n\n  this.gu(wcb_afterStmt).gmon(own);\n\n  var em = 0;\n  if (lead) {\n    this.emitStmt(lead, false);\n    if (own.used) { em++; this.trygu(wcb_afterStmt, own); }\n  }\n\n  var lsn = this.listenForEmits(own);\n  this.emitSimpleHead(n);\n  if (lsn.used) { em++; own.used = false; this.trygu(wcb_afterStmt, own); }\n\n  lsn = this.listenForEmits(own);\n  this.emitStmtList(n.body);\n  lsn.used && em++;\n\n  this.grmif(own);\n\n  this.u();\n  em && this.l();\n\n  this.emc(cb, \'inner\');\n  this.w(\'}\');\n  this.emc(cb, \'aft\');\n\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-emit-while-do.js', '  import {Emitters} from \'../other/globals.js\';\n  import {CB} from \'../other/util.js\';\n  import {ASSERT_EQ, ETK_ID, EC_NONE} from \'../other/constants.js\';\n  import {wcb_afterStmt} from \'../other/wcb.js\';\n\nEmitters[\'DoWhileStatement\'] =\nfunction(n, flags, isStmt) {\n  var cb = CB(n); this.emc(cb, \'bef\' );\n  ASSERT_EQ.call(this, isStmt, true);\n  this.wt(\'do\',ETK_ID).os();\n\n  var nbody = n.body, notBlock = nbody.type !== \'BlockStatement\';\n\n  var own = null;\n  if (notBlock) {\n    own = {used: false};\n    this.w(\'{\').i().gu(wcb_afterStmt).gmon(own);\n  }\n\n  this.emitStmt(n.body);\n\n  if (notBlock) {\n    this.u();\n    if (own.used) this.l();\n    else\n      this.grmif(own);\n    this.w(\'}\');\n  }\n\n  this.os().w(\'while\');\n  this.emc(cb, \'while.aft\') || this.os();\n  this.w(\'(\').eA(n.test, EC_NONE, false).w(\')\').emc(cb, \'cond.aft\');\n  this.w(\';\').emc(cb, \'aft\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/emit-jzhelpers.js', '  import Parser from \'../Parser/cls.js\';\n  import Transformer from \'../Transformer/cls.js\';\n  import {cls} from \'./cls.js\';\n  import {EC_NONE} from \'../other/constants.js\';\n\n  cls.writeJZHelpers =\n  function() {\n    var helperSrc = \'(function(){var o={};\' + this.jzHelpers.asCode() + \'return o;}())|0\';\n    var helperNode = new Parser(helperSrc).parseProgram();\n    var ntr = new Transformer().tr(helperNode, false);\n    this.emitAny(ntr.body[0].expression.left, EC_NONE, false);\n  };\n');
resolver.set('./src/Emitter/new-emit-ArrayExpression.js', '  import {Emitters} from \'../other/globals.js\';\n  import {EC_NEW_HEAD} from \'../other/constants.js\';\n\nEmitters[\'ArrayExpression\'] =\nfunction(n, flags, isStmt) {\n  var cb = n[\'#c\'];\n  var si = n[\'#si\'];\n  var hasParen = false;\n  if (si >= 0) {\n    hasParen = flags & EC_NEW_HEAD;\n    hasParen && this.w(\'(\');\n    this.emc(cb, \'bef\');\n    this.jz(\'arr\').w(\'(\');\n  } else\n    this.emc(cb, \'bef\');\n\n  var l = n.elements;\n  if (l.length) {\n    this.emitElems(l, true, cb);\n    si >= 0 && this.w(\')\');\n  } else {\n    this.w(\'[\').emc(cb, \'inner\');\n    this.w(\']\');\n  }\n\n  this.emc(cb, \'aft\');\n  hasParen && this.w(\')\');\n\n  isStmt && this.w(\';\');\n  return true;\n};\n\n');
resolver.set('./src/Emitter/new-emit-TaggedTemplateExpression.js', '  import {Emitters} from \'../other/globals.js\';\n  import {EC_NEW_HEAD, EC_NONE} from \'../other/constants.js\';\n\nEmitters[\'TaggedTemplateExpression\'] =\nfunction(n, flags, isStmt) {\n  var callee = n.tag;\n  var hasParen = flags & EC_NEW_HEAD;\n  if (hasParen) { this.w(\'(\'); flags = EC_NONE; }\n\n  this.eH(callee, flags, false).w(\'(\');\n  this.jz(\'t\').w(\'(\');\n\n  var list = n.quasi.quasis, l = 0;\n  this.w(\'[\');\n  while (l < list.length) {\n    l && this.wm(\',\',\'\');\n    this.writeString(list[l++].value.cooked, \"\'\");\n  }\n  this.wm(\']\',\',\').os();\n\n  l = 0;\n  this.w(\'[\');\n  while (l < list.length) {\n    l && this.wm(\',\',\'\');\n    var item = list[l++ ];\n    if (item.value.raw === item.value.cooked)\n      this.writeString(\'\', \'\"\');\n    else\n      this.writeString(item.value.raw, \"\\\'\");\n  }\n  this.w(\']\');\n\n  this.w(\')\');\n\n  list = n.quasi.expressions; l = 0;\n  while (l < list.length)\n    this.wm(\',\',\'\').eN(list[l++], EC_NONE, false);\n\n  this.w(\')\');\n  hasParen && this.w(\')\');\n\n  isStmt && this.w(\';\');\n};\n\n');
resolver.set('./src/Emitter/new-uemit-synth-rcheck.js', '  import {UntransformedEmitters} from \'../other/globals.js\';\n  import {EC_NONE} from \'../other/constants.js\';\n\nUntransformedEmitters[\'rcheck\'] =\nfunction(n, flags, isStmt) {\n  this.jz(\'r\').w(\'(\');\n  if (n.val) { this.eN(n.val, EC_NONE, false).w(\',\').os(); }\n  this.wm(n.th.synthName,\')\');\n  isStmt && this.w(\';\');\n};\n\n');
resolver.set('./src/ParenScope/core.js', '  import {ASSERT} from \'../other/constants.js\';\n  import {cls} from \'./cls.js\';\n\ncls.finish = \nfunction() {};\n\ncls.makeParams =\nfunction(paramScope) {\n  paramScope.setRefsAndArgRefs(this.refs);\n  this.updateParentForSubScopesTo(paramScope);\n  this.hasDissolved = true;\n};\n\ncls.makeSimple =\nfunction() {\n  var list = this.refs;\n  var i = 0;\n  var len = list.length();\n\n  var p = this.parent;\n  while (i<len) {\n    var mname = list.keys[i], ref = p.findRefAny_m(mname);\n    var elem = list.get(mname);\n    if (ref) ref.absorbDirect(elem);\n    else { elem.scope = p; p.insertRef_m(mname, elem); }\n    i++;\n  }\n\n  this.updateParentForSubScopesTo(p);\n  this.hasDissolved = true;\n};\n\ncls.updateParentForSubScopesTo =\nfunction(sParent) {\n  var list = this.ch, i = 0;\n  while (i<list.length) {\n    var elem = list[i];\n    if (elem.isParen()) {\n      ASSERT.call(this, elem.hasDissolved,\n        \'paren sub-scopes are not allowed to have remained intact -- they must have dissolved earlier\');\n      elem.updateParentForSubScopesTo(sParent);\n    }\n    else {\n      ASSERT.call(this, elem.isAnyFn() || elem.isClass(),\n        \'currently fn scopes are the only scope allowed \'+\n       \'to come in a paren\');\n      if (elem.parent === this)\n        elem.parent = sParent;\n    }\n    i++;\n  }\n};\n\n\n');
resolver.set('./src/ParenScope/whole.js', '  import \'./core.js\';\n');
resolver.set('./src/ParenScope/cls.js', '  import Scope from \'../Scope/cls.js\';\n  import {ST_PAREN} from \'../other/scope-constants.js\';\n\nexport default function ParenScope(sParent) {\n  Scope.call(this, sParent, ST_PAREN);\n\n  this.hasDissolved = false;\n  this.ch = [];\n}\n\n import {createObj} from \'../other/util.js\';\n export var cls = ParenScope.prototype = createObj(Scope.prototype);\n');
var asNode = resolver.asNode; resolver.asNode = function(uri) { return asNode.call(this, jazzle.normalize(uri)); }; ["hasInCache", "loadNew", "cache", "loadCached"].forEach(function(name) { resolver[name] = jazzle.FileResourceResolver.prototype[name]; });
  var goal = "./src/goal.js";
  var o = {
    sourceType: "module",
    rootUri: goal,
    resolver: resolver,
    bundle: true
  };
  if (options)
    for (var name in options)
       if (options.hasOwnProperty(name))
         o[name] = options[name];
  console.log(jazzle.transform(resolver.fsMap[goal+"%"], o));
};
</script></body></html>
